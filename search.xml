<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM64分页机制「paging」</title>
    <url>/posts/3c176007/</url>
    <content><![CDATA[<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>armv8 arch</category>
      </categories>
      <tags>
        <tag>paging</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8体系架构概述</title>
    <url>/posts/9e834789/</url>
    <content><![CDATA[<p>为了更深入地剖析kernel，了解ARMv8体系架构是非常必要的。本文尽量全面地概述ARMv8体系架构涉及的基础知识。Linux内核的绝大部分代码是与体系架构无关的「independent」，但是还存在大量的代码「spinlock、cache管理」都是与体系架构相关的「dependent」，这些代码不仅会在启动时被运行而且在系统正常运行期间也会被经常调用执行。不仅仅Linux内核牵涉了很多的体系架构知识，而且编译器（比如LLVM「Low Level Virtual Machine」）以及与内核紧密相关的领域（比如虚拟机）也都涉及了大量体系架构方面的知识，为了使系统或软件最大地利用硬件的特点和性能，学习了解体系架构的知识就显得格外重要。尽管ARMv8设备已被广泛地应用到各个领域，但是关于ARMv8体系架构的书籍不是太多，还比较零散，因此我希望本文能够尽量全面的介绍ARMv8体系架构方面的知识点，使我们在研究Linux内核代码不会因为体系架构知识短缺而困惑。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h4 id="ARMv8简介"><a href="#ARMv8简介" class="headerlink" title="ARMv8简介"></a>ARMv8简介</h4><p><img data-src="/images/04/arm_evolution.svg" alt="arm_evolution"></p>
<center>图1 ARM体系架构的演进</center>

<p><img data-src="/images/04/armv8_exception_model.svg" alt="armv8_exception_model"></p>
<center>图2 ARMv8异常模型「exception model」</center>

<p><img data-src="/images/04/execution_state_change.svg" alt="execution_state_change"></p>
<center>图3 执行环境的对比</center>

<p><img data-src="/images/04/aarch64_register_64bit_and_32bit.svg" alt="aarch64_register_64bit_and_32bit"></p>
<center>图4 AArch64寄存器的32bit和64bit用法</center>

<h4 id="ARMv8寄存器"><a href="#ARMv8寄存器" class="headerlink" title="ARMv8寄存器"></a>ARMv8寄存器</h4><p><img data-src="/images/04/aarch64_spsr_register.svg" alt="aarch64_spsr_register"></p>
<center>图5 AArch64 SPSR寄存器</center>

<h4 id="exception-handling「异常处理机制」"><a href="#exception-handling「异常处理机制」" class="headerlink" title="exception handling「异常处理机制」"></a>exception handling「异常处理机制」</h4><h4 id="cache「缓存器」"><a href="#cache「缓存器」" class="headerlink" title="cache「缓存器」"></a>cache「缓存器」</h4><h4 id="memory-order「内存访问秩序」"><a href="#memory-order「内存访问秩序」" class="headerlink" title="memory order「内存访问秩序」"></a>memory order「内存访问秩序」</h4><h4 id="MMU「内存管理单元」"><a href="#MMU「内存管理单元」" class="headerlink" title="MMU「内存管理单元」"></a>MMU「内存管理单元」</h4><p>MMU「Memory Management Unit，内存管理单元」的主要功能就是将CPU核心给出的虚拟地址「virtual address」转换成物理地址「physical address」。除此之外，它还具备其他功能，比如访问权限和TLB「Translation Lookaside Buffer，地址转译后援缓冲器」的设置。正是MMU的这些功能才确保各个进程能够在自己独有的虚拟地址空间中运行。如图17所示，给出一个PIPT 「physical indexes physical tags」cache的例子，MMU输出的物理地址被用作检索cacheline的index和tag。</p>
<p><img data-src="/images/04/MMU_example.svg" alt="MMU_example"></p>
<center>图17 MMU的一种使用场景</center>

<p>MMU的存在使应用程序能够在不顾虑其他应用程序的情况下灵活使用虚拟地址访问代码数据，即使物理内存比较零散，它也能通过映射「mapping」呈现一个连续的虚拟内存，并且虚拟地址空间与物理地址空间是完全分开的。<center>图18给出了虚拟地址空间与物理地址空间之间的纽带——转换表「translation table」。</p>
<p><img data-src="/images/04/MMU_translation.svg" alt="MMU_translation"></p>
<center>图18 通过转换表「translation table」完成地址的转换</center>

<h5 id="转换虚拟地址成物理地址的原理"><a href="#转换虚拟地址成物理地址的原理" class="headerlink" title="转换虚拟地址成物理地址的原理"></a>转换虚拟地址成物理地址的原理</h5><p><img data-src="/images/04/VA_to_PA.svg" alt="VA_to_PA"></p>
<center>图19 虚拟地址转换成物理地址的过程</center>


<h4 id="multi-core-processor「多核处理器」"><a href="#multi-core-processor「多核处理器」" class="headerlink" title="multi-core processor「多核处理器」"></a>multi-core processor「多核处理器」</h4><h4 id="power-management「电源管理」"><a href="#power-management「电源管理」" class="headerlink" title="power management「电源管理」"></a>power management「电源管理」</h4>]]></content>
      <categories>
        <category>armv8 arch</category>
      </categories>
      <tags>
        <tag>armv8</tag>
        <tag>aarch64</tag>
        <tag>cache</tag>
        <tag>MMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Buddy Allocator</title>
    <url>/posts/5dc99f9b/</url>
    <content><![CDATA[<p>本文主要阐述伙伴分配器的原理和实现细节。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<p><img data-src="/images/05/buddy-allocator.svg" alt="buddy-allocator.svg"></p>
<center>图1 buddy-allocator</center>

<p><img data-src="/images/05/buddy-allocator-0-1.svg" alt="buddy-allocator.svg"></p>
<center>图2 buddy-allocator-0-1</center>

<p><img data-src="/images/05/buddy-allocator-1.svg" alt="buddy-allocator.svg"></p>
<center>图3 buddy-allocator-1</center>

<p><img data-src="/images/05/buddy-allocator-2.svg" alt="buddy-allocator.svg"></p>
<center>图4 buddy-allocator-2</center>

<p><img data-src="/images/05/buddy-allocator-3.svg" alt="buddy-allocator.svg"></p>
<center>图5 buddy-allocator-3</center>

<p><img data-src="/images/05/buddy-allocator-4.svg" alt="buddy-allocator.svg"></p>
<center>图6 buddy-allocator-4</center>

<p><img data-src="/images/05/buddy-allocator-4-5.svg" alt="buddy-allocator.svg"></p>
<center>图7 buddy-allocator-4-5</center>

<p><img data-src="/images/05/buddy-allocator-5.svg" alt="buddy-allocator.svg"></p>
<center>图8 buddy-allocator-5</center>

<p><img data-src="/images/05/buddy-allocator-6.svg" alt="buddy-allocator.svg"></p>
<center>图9 buddy-allocator-6</center>


<p><img data-src="/images/05/buddy-allocator-7.svg" alt="buddy-allocator.svg"></p>
<center>图10 buddy-allocator-7</center>

<p><img data-src="/images/05/buddy-allocator-8.svg" alt="buddy-allocator.svg"></p>
<center>图11 buddy-allocator-8</center>


<p><img data-src="/images/05/buddy-free.svg" alt="buddy-allocator.svg"></p>
<center>图12 buddy-free</center>

<p><img data-src="/buddy-free-1.svg" alt="buddy-allocator.svg"></p>
<center>图13 buddy-free-1</center>

<p><img data-src="/images/05/buddy-free-2.svg" alt="buddy-allocator.svg"></p>
<center>图14 buddy-free-2</center>

<p><img data-src="/images/05/buddy-free-3.svg" alt="buddy-allocator.svg"></p>
<center>图15 buddy-free-3</center>
]]></content>
      <categories>
        <category>memory management</category>
      </categories>
      <tags>
        <tag>buddy</tag>
        <tag>memory allocator</tag>
      </tags>
  </entry>
  <entry>
    <title>Compaction</title>
    <url>/posts/4455d2d0/</url>
    <content><![CDATA[<p>本文主要阐述内存规整「compaction」的原理和实现细节。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<p>虽然看起来系统目前还存在很多空闲页帧，能够满足指定阶数「order」的分配请求，但是系统内存碎片化可能很严重，这时不可能完成高阶的内存分配请求。在这种情况下，通过迁移已经被其他任务使用的可移动页帧来整理获得空闲的连续的页帧块，这种方法称之为规整「compaction」。</p>
<ul>
<li>用户态程序分配使用的内存或者文件缓存属于可移动页帧「movable pages」</li>
<li>内核态程序分配使用的内存属于不可移动页帧「unmovable pages」，不可能被规整</li>
</ul>
<p>如下图所示，示意了如何进行规整来满足2阶的页帧分配请求<br><img data-src="/images/06/compaction-0.svg" alt="compaction-0.svg"></p>
<center>图1 compaction-0</center>

<p><img data-src="/images/06/compaction-1.svg" alt="compaction-1.svg"></p>
<center>图2 compaction-1</center>

<p><img data-src="/images/06/compaction-2.svg" alt="compaction-2.svg"></p>
<center>图3 compaction-2</center>


<p><img data-src="/images/06/compaction-5.svg" alt="compaction-5.svg"></p>
<center>图3 compaction-5</center>

<p><img data-src="/images/06/compaction-6.svg" alt="compaction-6.svg"></p>
<center>图3 compaction-6</center>

<p><img data-src="/images/06/compaction-7.svg" alt="compaction-7.svg"></p>
<center>图3 compaction-7</center>

<p><img data-src="/images/06/compaction-8.svg" alt="compaction-8.svg"></p>
<center>图9 compaction-8</center>

<p><img data-src="/images/06/compaction-9.svg" alt="compaction-9.svg"></p>
<center>图10 compaction-9</center>

<p><img data-src="/images/06/compaction-10.svg" alt="compaction-10.svg"></p>
<center>图11 compaction-10</center>

<p><img data-src="/images/06/compaction-11.svg" alt="compaction-11.svg"></p>
<center>图12 compaction-11</center>

<p><img data-src="/images/06/compaction-12.svg" alt="compaction-12.svg"></p>
<center>图13 compaction-12</center>

<p><img data-src="/images/06/compaction-13.svg" alt="compaction-13.svg"></p>
<center>图14 compaction-13</center>
]]></content>
      <categories>
        <category>memory management</category>
      </categories>
      <tags>
        <tag>memory compaction</tag>
        <tag>defragmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下常用设备权限问题</title>
    <url>/posts/7c3053a9/</url>
    <content><![CDATA[<blockquote>
<p>就好比你在跑马拉松时，无论一开始的速度多快、力气多足，能跑到终点的只有一种人，就是没有停下奔跑的人。  —- 人民日报 《[夜读] 失败只有一种，就是半途而废》</p>
</blockquote>
<p>在ubuntu-16.04环境下，经常我们使用串口应用或者摄像头应用，会提示权限不足，无法打开设备的错误</p>
<span id="more"></span>
<h3 id="查看设备文件的属性"><a href="#查看设备文件的属性" class="headerlink" title="查看设备文件的属性"></a>查看设备文件的属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ll /dev/ttyUSB0</span><br><span class="line">crw-rw---- 1 root dialout 188, 0 9月  11 10:31 /dev/ttyUSB0</span><br></pre></td></tr></table></figure>
<p>可以看到除了root用户和dialout组的用户有读写权限外，其他任何用户都不能操作这个设备</p>
<h3 id="彻底的解决方法"><a href="#彻底的解决方法" class="headerlink" title="彻底的解决方法"></a>彻底的解决方法</h3><p>我们把自己添加到dialout组就就可以了。同样道理，video设备，audio设备都是这样操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG dialout $USER</span><br></pre></td></tr></table></figure>

<h3 id="video设备"><a href="#video设备" class="headerlink" title="video设备"></a>video设备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ll /dev/video0</span><br><span class="line">crw-rw----+ 1 root video 81, 0 9月  11 08:51 /dev/video0</span><br><span class="line"></span><br><span class="line">$ sudo usermod -aG video $USER</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>ubuntu-16.04</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Page Frame Allocator</title>
    <url>/posts/b1d50440/</url>
    <content><![CDATA[<p>本文主要阐述页帧分配器的原理和实现细节。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<p><img data-src="/images/07/page-allocator.svg" alt="page-allocator.svg"></p>
<center>图1 page-allocator</center>

<p><img data-src="/images/07/watermark-0.svg" alt="watermark-0.svg"></p>
<center>图2 watermark-0</center>

<p><img data-src="/images/07/watermark-1.svg" alt="watermark-1.svg"></p>
<center>图3 watermark-1</center>]]></content>
      <categories>
        <category>memory management</category>
      </categories>
      <tags>
        <tag>memory allocator</tag>
        <tag>page frame allocator</tag>
      </tags>
  </entry>
  <entry>
    <title>Qemu Co-simulation</title>
    <url>/posts/6c41dfb6/</url>
    <content><![CDATA[<p>本文将展示如何使用qemu+systemC来完成IP的simulation，复用已有的高级语言实现的benchmark来剖析IP的性能。</p>
<span id="more"></span>


<p><img data-src="/images/25/qemu.jpg" alt="qemu-simulaton-uart"></p>
<center>图1 verilog-uart的Qemu co-simulation</center>

<p><img data-src="/images/25/qemu-ethernet.jpg" alt="qemu-simulaton-ethernet"></p>
<center>图2 verilog-ethernet的Qemu co-simulation</center>

<p><img data-src="/images/25/mult-process-qemu.jpg" alt="mult-process-qemu"></p>
<center>图3 Multi-Process Qemu的协同仿真</center>

<h3 id="Qemu-inside-VirtualBox"><a href="#Qemu-inside-VirtualBox" class="headerlink" title="Qemu inside VirtualBox"></a>Qemu inside VirtualBox</h3><p><img data-src="/images/25/qemu-network.png" alt="qemu-network-inside-virtualbox"></p>
<center>图4 在VirtualBox环境下QEMU网络配置</center>

<h4 id="三个OS"><a href="#三个OS" class="headerlink" title="三个OS"></a>三个OS</h4><ul>
<li>Host OS: Windows 11</li>
<li>VirtualBox Guest OS: Ubuntu 20.04 x86_64</li>
<li>Qemu AArch64 OS: AArch64 Embedded OS</li>
</ul>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>在PC物理机上面安装Windows Host OS，在Windows里面安装VirtualBox软件，通过VirtualBox提供一个虚拟机环境，在此环境中安装一个Ubuntu 20.04 Guest OS，然后我们进入Ubuntu操作系统内下运行qemu-system-aarch64软件，通过Qemu再提供一个虚拟机环境， 在这个Qemu提供的VM环境中，我们运行AArch64 Linux OS。这样就得到一个虚拟机里面再嵌套一个虚拟机的环境（VM inside VM）</p>
<p>Physical Host OS<br>&ensp;&ensp;&ensp;&ensp;Ubuntu Guest OS<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;Qemu AArch64 OS</p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul>
<li><p>关注Ubuntu Guest OS和Windows Host OS之间的网络通路<br>通过NAT技术将Ubuntu OS里面的网络报文传递给Host OS，在Ubuntu的环境中我们可以直接ping到Host OS网络和外部网络。也就是说，在Ubuntu环境下我们可以访问Host OS提供的网络服务和外部网络服务，但是在Host OS环境下，我们不能直接通过NAT技术ping到Ubuntu OS网络，只能通过VirtualBox提供的Host-only network访问Ubuntu OS里面提供的服务。</p>
</li>
<li><p>关注QEMU AArch64 OS和Ubuntu Guest OS之间的网络通路<br>通过TAP桥接的方式将Qemu OS里面的网络报文传递给Ubuntu OS，在Qemu OS里面可以直接ping到Ubuntu OS网络，在Ubuntu OS里面也可以直接ping到Qemu OS网络。也就是说，在QEMU OS里面我们可以直接访问Ubuntu OS提供的服务，在Ubuntu OS里面也可以直接访问Qemu OS提供的服务，相当于Qemu OS和Ubuntu OS以直连的方式进行通信。</p>
</li>
<li><p>关注QEMU AArch64 OS和Windows Host OS之间的网络通路<br>不能直接ping，也就是说，我们在Qemu AArch64 OS里面不能直接ping到Host OS网络和外部网络，这时候需要借助Ubuntu里面安装的tinyporxy代理将Qemu OS里面发出的网络报文转发到Host OS和外部网络，这样Qemu OS才能访问到Host OS和外部网络提供的服务</p>
</li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>emulator</tag>
        <tag>verilog</tag>
        <tag>systemC</tag>
      </tags>
  </entry>
  <entry>
    <title>Per-CPU Page Allocator</title>
    <url>/posts/7e1df158/</url>
    <content><![CDATA[<p>本文主要阐述per-CPU页帧分配器的原理和实现细节。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<p><img data-src="/images/08/pcp-0.svg" alt="pcp-0.svg"></p>
<center>图1 pcp-0</center>


<p><img data-src="/images/08/pcp-1.svg" alt="pcp-1.svg"></p>
<center>图2 pcp-1</center>

<p><img data-src="/images/08/pcp-2.svg" alt="pcp-2.svg"></p>
<center>图3 pcp-2</center>

<p><img data-src="/images/08/pcp-3.svg" alt="pcp-3.svg"></p>
<center>图4 pcp-3</center>]]></content>
      <categories>
        <category>memory management</category>
      </categories>
      <tags>
        <tag>memory allocator</tag>
        <tag>PCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Qemu新增的芯片平台</title>
    <url>/posts/27c3d8a8/</url>
    <content><![CDATA[<p>随着芯片开发的规模越来越大，验证无处不在，在整个开发流程中能够将系统软件的开发尽量向左前移，那么我们开发的芯片就能够更早地推向市场，甚至抢占先机。</p>
<p>使用Qemu来模拟仿真我们开发的芯片，从而能够让软件开发人员与芯片设计人员并行开发，但是Qemu通常是没有我们自研芯片的虚拟平台（VP），因此我们要根据芯片手册，新增实现一个虚拟原型或者虚拟芯片平台，也就是说基于Qemu现有的代码，我们新开发一个自研芯片的虚拟原型（VP），基于这个开发的虚拟原型（VP），我们可以开始进行BSP代码开发，不用再等待FPGA原型验证环境准备好，就能够提前推进系统软件代码的开发验证。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Qemu:</strong> <code>v7.2.0</code></li>
<li><strong>Host OS:</strong> <code>Ubuntu-20.04</code></li>
<li><strong>GCC:</strong> <code>9.4.0</code></li>
</ul>
<hr>
<h3 id="Qemu特征"><a href="#Qemu特征" class="headerlink" title="Qemu特征"></a>Qemu特征</h3><ul>
<li>新增Cortex-A78ae CPU支持</li>
<li>新增Cortex-R52 CPU支持</li>
<li>新增THead-E907 CPU支持<ul>
<li>移植THead扩展指令集</li>
</ul>
</li>
<li>新增PCIe UFS支持</li>
<li>新增eMMC和SD Card支持<ul>
<li>支持RPMB分区</li>
<li>支持Boot分区</li>
<li>支持Synopsys和Cadence SDHCI</li>
</ul>
</li>
<li>新增ARM SMMUv3支持<ul>
<li>仅单独支持stage-1和stage-2，不支持stage-1和stage-2同时起作用</li>
<li>参考<a href="https://lore.kernel.org/qemu-devel/20230516203327.2051088-1-smostafa@google.com/">Qemu support for SMMUv3</a></li>
</ul>
</li>
<li>新增Synopsys ethernet QoS支持<ul>
<li>仅支持在U-Boot下收发功能，中断未模拟实现</li>
</ul>
</li>
<li>新增synopsys GPIO and I2C Controller支持</li>
</ul>
<h3 id="新增的平台"><a href="#新增的平台" class="headerlink" title="新增的平台"></a>新增的平台</h3><p>在我们开发Qemu machine之前，我们需要先熟悉芯片的基础架构：</p>
<ol>
<li>芯片的地址映射（memory map）</li>
<li>芯片的中断映射（interrupt map）</li>
<li>芯片的指令集架构（ARM、RISC-V等）</li>
<li>芯片涉及的外设（GIC、timer、UART和ethernet等）</li>
</ol>
<h4 id="目前新支持的平台"><a href="#目前新支持的平台" class="headerlink" title="目前新支持的平台"></a>目前新支持的平台</h4><center>表1 Qemu支持的平台</center>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;}
.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-c1u6{background-color:#D2E4FC;font-family:"Times New Roman", Times, serif !important;font-size:14px;text-align:left;
  vertical-align:top}
.tg .tg-8mgi{font-family:"Times New Roman", Times, serif !important;font-size:14px;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-8mgi">SoC Platform</th>
    <th class="tg-8mgi">Machine Name</th>
    <th class="tg-8mgi">Arch</th>
    <th class="tg-8mgi">U-Boot defconfig</th>
    <th class="tg-8mgi">Kernel defconfig</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c1u6">hobot</td>
    <td class="tg-c1u6">hobot-sigi-virt</td>
    <td class="tg-c1u6">aarch64</td>
    <td class="tg-c1u6">hobot-sigi-virt_defconfig</td>
    <td class="tg-c1u6">hobot_sigi_tiny_defconfig</td>
  </tr>
  <tr>
    <td class="tg-8mgi">lambert</td>
    <td class="tg-8mgi">lmt-virt</td>
    <td class="tg-8mgi">aarch64</td>
    <td class="tg-8mgi">lambert-qemu-virt_defconfig</td>
    <td class="tg-8mgi">lambert-tiny_defconfig</td>
  </tr>
  <tr>
    <td class="tg-c1u6">lambert safety</td>
    <td class="tg-c1u6">lmt-riscv-virt</td>
    <td class="tg-c1u6">riscv32(M-mode only)</td>
    <td class="tg-c1u6">lambert-qemu-riscv-without-dram_defconfig</td>
    <td class="tg-c1u6">NA</td>
  </tr>
</tbody>
</table>

<h4 id="hobot平台"><a href="#hobot平台" class="headerlink" title="hobot平台"></a>hobot平台</h4><p>支持的设备如下：</p>
<ul>
<li>four CPUs (ARM Cortex-A78ae)</li>
<li>GICv3 (GIC-600)</li>
<li>four NS16550 UARTs (synopsys)</li>
<li>two SDHCI (Cadence)</li>
<li>OCM (32 MiB)</li>
<li>two GPIO Ctrl (synopsys)</li>
<li>DRAM (96 GiB)</li>
<li>PCIe (ECAM)</li>
<li>USB (synopsys)</li>
<li>NVMe</li>
</ul>
<center>表2 hobot平台的内存映射和中断映射</center>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:0px auto;}
.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-ul38{position:-webkit-sticky;position:sticky;text-align:left;top:-1px;vertical-align:top;will-change:transform}
.tg .tg-j1i3{border-color:inherit;position:-webkit-sticky;position:sticky;text-align:left;top:-1px;vertical-align:top;
  will-change:transform}
.tg .tg-hmp3{background-color:#D2E4FC;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
@media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;margin: auto 0px;}}</style>
<div class="tg-wrap"><table class="tg">
<thead>
  <tr>
    <th class="tg-j1i3">IP name</th>
    <th class="tg-ul38">memory <br>base address</th>
    <th class="tg-ul38">memory <br>map size</th>
    <th class="tg-ul38">interrupt</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">OCM</td>
    <td class="tg-hmp3">0x0400_0000</td>
    <td class="tg-0lax">0x0200_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
  <tr>
    <td class="tg-0lax">flash</td>
    <td class="tg-hmp3">0x1800_0000</td>
    <td class="tg-0lax">0x0800_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
  <tr>
    <td class="tg-0lax">pmu</td>
    <td class="tg-hmp3">0x2319_0000</td>
    <td class="tg-0lax">0x0001_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
  <tr>
    <td class="tg-0lax">gicv3</td>
    <td class="tg-hmp3">0x30b0_0000</td>
    <td class="tg-0lax">0x0001_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
  <tr>
    <td class="tg-0lax">gicv3 redist</td>
    <td class="tg-hmp3">0x30b6_0000</td>
    <td class="tg-0lax">0x0010_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
  <tr>
    <td class="tg-0lax">PCIe Ctrl</td>
    <td class="tg-hmp3">0x3400_0000</td>
    <td class="tg-0lax">0x0040_0000</td>
    <td class="tg-hmp3">127~130</td>
  </tr>
  <tr>
    <td class="tg-0lax">PCIe PIO</td>
    <td class="tg-hmp3">0x7000_0000</td>
    <td class="tg-0lax">0x1000_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
  <tr>
    <td class="tg-0lax">PCIe MMIO</td>
    <td class="tg-hmp3">0x8000_0000</td>
    <td class="tg-0lax">0x4000_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
  <tr>
    <td class="tg-0lax">PCIe high MMIO</td>
    <td class="tg-hmp3">0x80_0000_0000</td>
    <td class="tg-0lax">0x80_0000_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
  <tr>
    <td class="tg-0lax">sdhci0</td>
    <td class="tg-hmp3">0x3903_0000</td>
    <td class="tg-0lax">0x0001_0000</td>
    <td class="tg-hmp3">120</td>
  </tr>
  <tr>
    <td class="tg-0lax">sdhci1</td>
    <td class="tg-hmp3">0x3904_0000</td>
    <td class="tg-0lax">0x0001_0000</td>
    <td class="tg-hmp3">122</td>
  </tr>
  <tr>
    <td class="tg-0lax">UART0</td>
    <td class="tg-hmp3">0x3905_0000</td>
    <td class="tg-0lax">0x0001_0000</td>
    <td class="tg-hmp3">73</td>
  </tr>
  <tr>
    <td class="tg-0lax">UART1</td>
    <td class="tg-hmp3">0x3906_0000</td>
    <td class="tg-0lax">0x0001_0000</td>
    <td class="tg-hmp3">74</td>
  </tr>
  <tr>
    <td class="tg-0lax">UART2</td>
    <td class="tg-hmp3">0x3907_0000</td>
    <td class="tg-0lax">0x0001_0000</td>
    <td class="tg-hmp3">75</td>
  </tr>
  <tr>
    <td class="tg-0lax">UART3</td>
    <td class="tg-hmp3">0x3908_0000</td>
    <td class="tg-0lax">0x0001_0000</td>
    <td class="tg-hmp3">76</td>
  </tr>
  <tr>
    <td class="tg-0lax">low DRAM</td>
    <td class="tg-hmp3">0xC000_0000</td>
    <td class="tg-0lax">0x4000_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
  <tr>
    <td class="tg-0lax">high DRAM</td>
    <td class="tg-hmp3">0x30_0000_0000</td>
    <td class="tg-0lax">0x18_0000_0000</td>
    <td class="tg-hmp3"></td>
  </tr>
</tbody>
</table></div>

<h4 id="lambert平台"><a href="#lambert平台" class="headerlink" title="lambert平台"></a>lambert平台</h4><h5 id="基于aarch64的lmt-virt"><a href="#基于aarch64的lmt-virt" class="headerlink" title="基于aarch64的lmt-virt"></a>基于aarch64的lmt-virt</h5><p>支持的设备如下：</p>
<ul>
<li>8 CPUs (ARM Cortex-A76)</li>
<li>2 NS16550 UART (synopsys)</li>
<li>DWC Ethernet QoS (synopsys)</li>
<li>GICv2 (GIC-400)</li>
<li>DRAM (48 GiB)</li>
<li>iRAM (128 KiB)</li>
<li>Safety iRAM (512 KiB)</li>
</ul>
<center>表3 lmt-virt平台的内存映射和中断映射</center>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:0px auto;}
.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-hmp3{background-color:#D2E4FC;text-align:left;vertical-align:top}
.tg .tg-x8j9{background-color:#D2E4FC;border-color:inherit;font-family:"Times New Roman", Times, serif !important;font-size:16px;
  text-align:left;vertical-align:top}
.tg .tg-rxf2{border-color:inherit;font-family:"Times New Roman", Times, serif !important;font-size:16px;position:-webkit-sticky;
  position:sticky;text-align:left;top:-1px;vertical-align:top;will-change:transform}
.tg .tg-ud8r{border-color:inherit;font-family:"Times New Roman", Times, serif !important;font-size:16px;text-align:left;
  vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
@media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;margin: auto 0px;}}</style>
<div class="tg-wrap"><table class="tg">
<thead>
  <tr>
    <th class="tg-rxf2">IP Name</th>
    <th class="tg-rxf2">Memory<br>Base Address</th>
    <th class="tg-rxf2">Memory<br>Map Size</th>
    <th class="tg-rxf2">Interrupt</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-ud8r">iRAM</td>
    <td class="tg-x8j9">0x0000_0000</td>
    <td class="tg-ud8r">0x0002_0000</td>
    <td class="tg-x8j9"></td>
  </tr>
  <tr>
    <td class="tg-ud8r">GICv2</td>
    <td class="tg-x8j9">0x0044_8000</td>
    <td class="tg-ud8r">0x0000_8000</td>
    <td class="tg-x8j9"></td>
  </tr>
  <tr>
    <td class="tg-ud8r">UART0</td>
    <td class="tg-x8j9">0x1068_a000</td>
    <td class="tg-ud8r">0x0000_1000</td>
    <td class="tg-x8j9">73</td>
  </tr>
  <tr>
    <td class="tg-ud8r">UART1</td>
    <td class="tg-x8j9">0x1068_b000</td>
    <td class="tg-ud8r">0x0000_1000</td>
    <td class="tg-x8j9">74</td>
  </tr>
  <tr>
    <td class="tg-0lax">ETH</td>
    <td class="tg-hmp3">0x6082_4000</td>
    <td class="tg-0lax">0x0000_4000</td>
    <td class="tg-hmp3">112</td>
  </tr>
  <tr>
    <td class="tg-ud8r">iRAM safety</td>
    <td class="tg-x8j9">0x60c0_0000</td>
    <td class="tg-ud8r">0x0008_0000</td>
    <td class="tg-x8j9"></td>
  </tr>
  <tr>
    <td class="tg-ud8r">DRAM</td>
    <td class="tg-x8j9">0x4_0000_0000</td>
    <td class="tg-ud8r">0xC_0000_0000</td>
    <td class="tg-x8j9"></td>
  </tr>
</tbody>
</table></div>

<h5 id="基于riscv32的lmt-riscv-virt"><a href="#基于riscv32的lmt-riscv-virt" class="headerlink" title="基于riscv32的lmt-riscv-virt"></a>基于riscv32的lmt-riscv-virt</h5><p>支持的设备如下：</p>
<ul>
<li>2 CPUs (THead E907 or base rv32)</li>
<li>CLINT (timer interrupt or SGI)</li>
<li>CLIC</li>
<li>2 NS16550 UART (synopsys)</li>
<li>iRAM (512 KiB)</li>
<li>fake DRAM (4 MiB)</li>
</ul>
<center>表4 lmt-riscv-virt平台的内存映射和中断映射</center>
<style type="text/css">
.tg  {border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:0px auto;}
.tg td{background-color:#EBF5FF;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#444;
  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{background-color:#409cff;border-color:#9ABAD9;border-style:solid;border-width:1px;color:#fff;
  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-zkuo{background-color:#D2E4FC;font-family:"Times New Roman", Times, serif !important;font-size:16px;text-align:left;
  vertical-align:top}
.tg .tg-bcyb{font-family:"Times New Roman", Times, serif !important;font-size:16px;position:-webkit-sticky;position:sticky;
  text-align:left;top:-1px;vertical-align:middle;will-change:transform}
.tg .tg-l3g0{font-family:"Times New Roman", Times, serif !important;font-size:16px;text-align:left;vertical-align:top}
@media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;margin: auto 0px;}}</style>
<div class="tg-wrap"><table class="tg">
<thead>
  <tr>
    <th class="tg-bcyb">IP Name</th>
    <th class="tg-bcyb">Memory<br>Base Address</th>
    <th class="tg-bcyb">Memory<br>Map Size</th>
    <th class="tg-bcyb">Interrupt</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-l3g0">iRAM</td>
    <td class="tg-zkuo">0x60c0_0000</td>
    <td class="tg-l3g0">0x0008_0000</td>
    <td class="tg-zkuo"></td>
  </tr>
  <tr>
    <td class="tg-l3g0">CLINT</td>
    <td class="tg-zkuo">0x60c8_0000</td>
    <td class="tg-l3g0">0x0008_0000</td>
    <td class="tg-zkuo"></td>
  </tr>
  <tr>
    <td class="tg-l3g0">CLIC</td>
    <td class="tg-zkuo">0x60d2_4000</td>
    <td class="tg-l3g0">0x0000_1000</td>
    <td class="tg-zkuo"></td>
  </tr>
  <tr>
    <td class="tg-l3g0">UART0</td>
    <td class="tg-zkuo">0x60d4_2000</td>
    <td class="tg-l3g0">0x0000_1000</td>
    <td class="tg-zkuo">16</td>
  </tr>
  <tr>
    <td class="tg-l3g0">UART1</td>
    <td class="tg-zkuo">0x60d4_3000</td>
    <td class="tg-l3g0">0x0000_1000</td>
    <td class="tg-zkuo">17</td>
  </tr>
  <tr>
    <td class="tg-l3g0">fake DRAM</td>
    <td class="tg-zkuo">0x60e0_0000</td>
    <td class="tg-l3g0">0x0040_0000</td>
    <td class="tg-zkuo"></td>
  </tr>
</tbody>
</table></div>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>SoC</tag>
        <tag>emulation</tag>
      </tags>
  </entry>
  <entry>
    <title>SMP子系统</title>
    <url>/posts/67a07310/</url>
    <content><![CDATA[<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>task management and process scheduling</category>
      </categories>
      <tags>
        <tag>CPU topology</tag>
        <tag>SMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Slub allocator</title>
    <url>/posts/cee2afeb/</url>
    <content><![CDATA[<p>本文主要阐述slub分配器的原理和实现细节。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<p><img data-src="/images/10/slub-allocator.svg" alt="slub-allocator.svg"></p>
<center>图1 slub-allocator</center>

<p><img data-src="/images/10/slab-cache.svg" alt="slab-cache.svg"></p>
<center>图2 slab-cache</center>

<p><img data-src="/images/10/slab-cache-2.svg" alt="slab-cache-2.svg"></p>
<center>图3 slab-cache-2</center>

<p><img data-src="/images/10/slab-cache-3.svg" alt="slab-cache-3.svg"></p>
<center>图4 slab-cache-3</center>

<p><img data-src="/images/10/slab-cache-4.svg" alt="slab-cache-4.svg"></p>
<center>图5 slab-cache-4</center>

<p><img data-src="/images/10/slab-cache-5.svg" alt="slab-cache-5.svg"></p>
<center>图6 slab-cache-5</center>

<p><img data-src="/images/10/slub-object-layout.svg" alt="slub-object-layout.svg"></p>
<center>图7 slub-object-layout.svg</center>

<p><img data-src="/images/10/slub-object-layout-1.svg" alt="slub-object-layout-1.svg"></p>
<center>图8 slub-object-layout-1.svg</center>

<p><img data-src="/images/10/slub-object-layout-2.svg" alt="slub-object-layout-2.svg"></p>
<center>图9 slub-object-layout-2.svg</center>

<p><img data-src="/images/10/slub-object-layout-3.svg" alt="slub-object-layout-3.svg"></p>
<center>图10 slub-object-layout-3.svg</center>

<p><img data-src="/images/10/slub-object-layout-4.svg" alt="slub-object-layout-4.svg"></p>
<center>图11 slub-object-layout-4.svg</center>

<p><img data-src="/images/10/slab-init.svg" alt="slab-init.svg"></p>
<center>图12 slab-init.svg</center>

<p><img data-src="/images/10/slab-init-1.svg" alt="slab-init-1.svg"></p>
<center>图13 slab-init-1.svg</center>

<p><img data-src="/images/10/slab-init-2.svg" alt="slab-init-2.svg"></p>
<center>图14 slab-init-2.svg</center>

<p><img data-src="/images/10/slab-init-3.svg" alt="slab-init-3.svg"></p>
<center>图15 slab-init-3.svg</center>

<p><img data-src="/images/10/slab-init-4.svg" alt="slab-init-4.svg"></p>
<center>图16 slab-init-4.svg</center>

<p><img data-src="/images/10/slab-init-5.svg" alt="slab-init-5.svg"></p>
<center>图17 slab-init-5.svg</center>

<p><img data-src="/images/10/slab-init-6.svg" alt="slab-init-6.svg"></p>
<center>图18 slab-init-6.svg</center>

<p><img data-src="/images/10/slab-create-1.svg" alt="slab-create-1.svg"></p>
<center>图19 slab-create-1</center>

<p><img data-src="/images/10/slab-order-calc.svg" alt="slab-order-calc.svg"></p>
<center>图20 slab-order-calc</center>
]]></content>
      <categories>
        <category>memory management</category>
      </categories>
      <tags>
        <tag>memory allocator</tag>
        <tag>slab</tag>
        <tag>slub</tag>
      </tags>
  </entry>
  <entry>
    <title>Temporary notes</title>
    <url>/posts/9b45ad28/</url>
    <content><![CDATA[<p>本文主要用于记录自己平时学习工作遇到的问题和解决方法，此外还有临时学习整理的一些零散东西，很可能没有背景介绍，只为自己以后方便查询！</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h4 id="PCIe相关内容"><a href="#PCIe相关内容" class="headerlink" title="PCIe相关内容"></a>PCIe相关内容</h4><p><img data-src="/images/01/pcie_enumeration_codeflow.svg" alt="pcie_enumeration_codeflow.svg"></p>
<center>图1 PCIe总线的初始化枚举过程</center>


<h4 id="u-boot相关内容"><a href="#u-boot相关内容" class="headerlink" title="u-boot相关内容"></a>u-boot相关内容</h4><p>Driver Model 先bind后probe</p>
<p><img data-src="/images/01/dm_bind_codeflow.svg" alt="dm_bind_codeflow.svg"></p>
<center>图2 u-boot 设备模型的初始化流程</center>

<!-- <img data-src="Temporary-notes/dm_bind_codeflow.svg" width="50%" height="50%" title="拼写检查工具Grammarly." alt="拼写检查工具Grammarly."/> -->]]></content>
      <categories>
        <category>Miscellaneous</category>
      </categories>
      <tags>
        <tag>PCIe</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu-18.04系统迁移</title>
    <url>/posts/260ea319/</url>
    <content><![CDATA[<p>通常我们安装好ubuntu-18.04后都要花很长时间来配置使其更好地符合自己的使用习惯，但是当换新的设备或者硬盘后不可能再花很多时间重新配置一遍，这既浪费时间又没有意义的苦差事，因此通过系统备份还原能够快速地实现系统的迁移复制。</p>
<span id="more"></span>

<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>必备硬件：</strong> 一个至少4GiB的U盘用于，一个移动硬盘用于存放系统备份数据<br>先从官网<a href="https://releases.ubuntu.com/18.04.5/?_ga=2.54093288.1303791633.1599998557-796045859.1597154791">Ubuntu 18.04.5 LTS (Bionic Beaver)</a> 下载ubuntu-18.04.4-desktop-amd64.iso文件，然后用<code>Startup Disk Creator</code>工具制作一个Ubuntu启动盘，用于在系统还原时提供一个操作环境。也可以使用下列命令下载iso文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://releases.ubuntu.com/18.04.4/ubuntu-18.04.4-desktop-amd64.iso</span><br></pre></td></tr></table></figure>
<p>如下图所示用ubuntu-18.04.4-desktop-amd64.iso制作一个可启动U盘，点击<code>Make Startup Disk</code>按钮开始进行启动U盘的制作。</p>
<p><img data-src="/images/03/startupdiskcreator.png" alt="startupdiskcreator"></p>
<center>图1 制作启动U盘</center>

<p>下面安装备份还原使用的工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install dump</span><br><span class="line">sudo apt-get download dump</span><br></pre></td></tr></table></figure>
<p>上面最后一个命令会下载<a href="/downloads/dump_0.4b46-3_amd64.deb">dump_0.4b46-3_amd64.deb</a>，需要将这个工具安装到使用U盘启动的Live操作系统。</p>
<h3 id="系统备份"><a href="#系统备份" class="headerlink" title="系统备份"></a>系统备份</h3><p>查看当前系统硬盘分区和文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk -f</span><br><span class="line">或</span><br><span class="line">parted -l</span><br><span class="line">或</span><br><span class="line">fdisk -l</span><br><span class="line">或</span><br><span class="line"><span class="built_in">df</span> -T</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/03/filesystem.png" alt="filesystem"></p>
<center>图2 当前的分区和文件系统信息</center>

<p>也可以打开<code>/etc/fstab</code>文件来验证分区和文件系统的信息</p>
<p><img data-src="/images/03/fstab.png" alt="fstab"></p>
<center>图3 fstab文件的内容</center>

<p><img data-src="/images/03/dump.png" alt="dump"></p>
<center>图4 dump命令介绍</center>

<p><img data-src="/images/03/restore.png" alt="restore"></p>
<center>图5 restore命令介绍</center>

<p>将根分区<code>/</code>、<code>/home</code>和<code>/boot</code>三个分区都备份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dump -0u -f /media/charleye/Material/filesystem-backup/root/2020-09-13/full-root-backup.20200913 /dev/mapper/lvmroot-root -z</span><br><span class="line">sudo dump -0u -f /media/charleye/Material/filesystem-backup/home/2020-09-13/full-home-backup.20200913 /dev/mapper/lvmhome-home  -z</span><br><span class="line">sudo dump -0u -f /media/charleye/Material/filesystem-backup/boot/2020-09-13/full-boot-backup.20200913 /dev/sda1 -z</span><br></pre></td></tr></table></figure>

<h3 id="系统还原"><a href="#系统还原" class="headerlink" title="系统还原"></a>系统还原</h3><p>在新设备上让BIOS从U盘启动引导进入Live Ubuntu-18.04操作系统，然后手动安装dump工具，然后根据备份时得到的设备分区信息对现在的新硬盘进行相同的分区并格式化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i dump_0.4b46-3_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面分区根据具体情况而定</span></span><br><span class="line">sudo pvcreate /dev/sda2</span><br><span class="line">sudo pvcreate /dev/sda3</span><br><span class="line"></span><br><span class="line">sudo vgcreate lvmroot /dev/sda2</span><br><span class="line">sudo vgcreate lvmhome /dev/sda3</span><br><span class="line"></span><br><span class="line">sudo lvcreate -L +70G -n root lvmroot</span><br><span class="line">sudo lvcreate -L +1T -n home lvmhome</span><br><span class="line"></span><br><span class="line">sudo mkfs.ext4 /dev/mapper/lvmroot-root</span><br><span class="line">sudo mkfs.ext4 /dev/mapper/lvmhome-home</span><br><span class="line">sudo mkfs.ext4 /dev/sda1	 <span class="comment"># 对应/boot分区</span></span><br><span class="line"></span><br><span class="line">sudo mount /dev/lvmroot/root /mnt/</span><br><span class="line"><span class="built_in">pushd</span> /mnt/</span><br><span class="line"></span><br><span class="line">sudo restore -f /media/charleye/Material/filesystem-backup/root/2020-09-13/full-root-backup.20200913 -r</span><br><span class="line"></span><br><span class="line">sudo mount /dev/sda1 /mnt/boot/</span><br><span class="line"><span class="built_in">pushd</span> /mnt/boot/</span><br><span class="line">sudo restore -f /media/charleye/Material/filesystem-backup/boot/2020-09-13/full-boot-backup.20200913 -r</span><br><span class="line"></span><br><span class="line">sudo mount /dev/lvmhome/home /mnt/home</span><br><span class="line"><span class="built_in">pushd</span> /mnt/home</span><br><span class="line">sudo restore -f /media/charleye/Material/filesystem-backup/root/2020-09-13/full-root-backup.20200913 -r</span><br><span class="line"></span><br><span class="line">sudo mount --<span class="built_in">bind</span> /dev/ /mnt/dev/</span><br><span class="line">sudo mount --<span class="built_in">bind</span> /proc/ /mnt/proc/</span><br><span class="line">sudo mount  --<span class="built_in">bind</span> /sys/ /mnt/sys/</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">cp</span> /etc/resolv.conf rootfs/etc/resolv.conf</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">chroot</span> /mnt</span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install resolvconf</span><br><span class="line"></span><br><span class="line">update-grub</span><br><span class="line">grub-install /dev/sda</span><br><span class="line"></span><br><span class="line">dpkg-reconfigure resolvconf</span><br><span class="line">dpkg-reconfigure tzdata</span><br><span class="line">vim /etc/systemd/system/network-online.target.wants/networking.service</span><br><span class="line"><span class="comment"># 将TimeoutStartSec=5min改为TimeoutStartSec=2sec</span></span><br><span class="line"><span class="comment"># 不然的话，在还原系统后第一次重启因为网络配置参数不对会等待五分钟以后才能进入登录界面，</span></span><br><span class="line"><span class="comment"># 提示信息是A start job is running for Raise network interface(5min 1s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># blkid查看/dev/sda1分区的UUID</span></span><br><span class="line"><span class="comment"># 将fstab文件中/boot分区对应的UUID用这个新的替换掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理掉挂载</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">sudo umount /mnt/proc</span><br><span class="line">sudo umount /mnt/sys</span><br><span class="line">sudo umount /mnt/dev</span><br><span class="line">sudo umount /mnt</span><br></pre></td></tr></table></figure>
<p>至此，重启之后就能够正常进入系统，说明系统迁移复制成功。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ubuntu-18.04</tag>
        <tag>dump</tag>
        <tag>restore</tag>
      </tags>
  </entry>
  <entry>
    <title>percpu内存分配器</title>
    <url>/posts/f7f26963/</url>
    <content><![CDATA[<p>percpu变量指的是为每个CPU都创建一个同样的变量，也就是为每个CPU分配一份单独的内存空间，用来保存各自私有的数据。在SMP「Symmetry Multi-Processor」系统中，为了确保多个CPU能够正确地访问同一个资源，同步机制是必不可少的，比如缓存一致性「cache coherence」和自旋锁「spinlock」。但是通过使用percpu变量，内核能够使每个CPU只访问自己私有的内存空间，因此可以避免使用同步机制「free-lock」。本文将逐步揭开percpu内存管理机制的面纱。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>percpu是一种内存管理机制，它不仅能为每个CPU私有的变量分配内存空间，并且对percpu变量所用的内存空间进行集中统一管理。通过使用每个CPU自己的单独内存空间，内核既能够避免多CPU并发访问需要的锁机制不仅能够提高系统的性能，还能够改善处理器（CPU）的缓存命中率「cache hit rate」。</p>
<h5 id="percpu机制主要特点"><a href="#percpu机制主要特点" class="headerlink" title="percpu机制主要特点"></a>percpu机制主要特点</h5><p>percpu内存管理机制是在内核2.6版本引入的。在SMP系统中，如果只访问CPU私有的数据，那么将极大减少对同步机制的依赖。为此，内核可以借助percpu机制在其管理的区域「percpu chunk」内为每个CPU分配一段内存空间，用于保存各自私有的数据，也就是每个CPU都有一份自己的数据副本。当你想在不使用锁机制的情况实现大量的写操作时，percpu机制在设计阶段就应该首先考虑进去。不过，percpu机制不是无条件的，在使用时还是需要考虑中断和内核抢占时的保护任务。不管怎样，percpu机制在内核被广泛使用，比如网络报文统计、磁盘IO统计和内核对象计数等。由于不需要使用锁机制，所以在需要完成每秒上千次的数据更新时percpu机制的性能还是有大幅提升和改进的。</p>
<p><img data-src="/images/09/percpu_count.svg" alt="percpu_count.svg"></p>
<center>图1 percpu count</center>

<p><img data-src="/images/09/percpu_unit_size.svg" alt="percpu_unit_size.svg"></p>
<center>图2 percpu chunck</center>

<p><img data-src="/images/09/percpu_chunck_layout.svg" alt="percpu_chunck_layout.svg"></p>
<center>图3 percpu chunck layout</center>

<p><img data-src="/images/09/percpu_unit_map.svg" alt="percpu_unit_map.svg"></p>
<center>图4 数组pcpu_unit_map[]</center>

<p><img data-src="/images/09/percpu_unit_offset.svg" alt="percpu_unit_offset.svg"></p>
<center>图5 数组pcpu_unit_offsets[]</center>

<p><img data-src="/images/09/percpu_alloc_info.jpg" alt="percpu_alloc_info.jpg"></p>
<center>图6 设置struct pcpu_alloc_info实例</center>

<p><img data-src="/images/09/pcpu_cpu_to_unit.svg" alt="pcpu_cpu_to_unit.svg"></p>
<center>图7 cpu->unit映射</center>

<p><img data-src="/images/09/pcpu_chunk_config.svg" alt="pcpu_chunk_configuration.svg"></p>
<center>图8 chunk配置</center>

<p><img data-src="/images/09/percpu_base_addr_location.svg" alt="percpu_base_addr_location.svg"></p>
<center>图9 pcpu_base_addr定位</center>

<p><img data-src="/images/09/percpu_first_chunk.svg" alt="percpu_first_chunk.svg"></p>
<center>图10 first chunk与unit的关系</center>

<p><img data-src="/images/09/percpu_mapping_management.svg" alt="percpu_mapping_management.svg"></p>
<center>图11 first chunk的地址空间映射</center>]]></content>
      <categories>
        <category>memory management</category>
      </categories>
      <tags>
        <tag>memory allocator</tag>
        <tag>percpu</tag>
      </tags>
  </entry>
  <entry>
    <title>中断延迟处理机制「interrupt delay processing」</title>
    <url>/posts/undefined/</url>
    <content><![CDATA[<p>本文主要讨论中断的延迟处理机制，不仅说明了什么是上半部分「top-half」和下半部分「bottom-half」，还介绍了如何使用下半部分实现中断的延迟处理。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h4 id="top-half「上半部分」和bottom-half「下半部分」"><a href="#top-half「上半部分」和bottom-half「下半部分」" class="headerlink" title="top-half「上半部分」和bottom-half「下半部分」"></a>top-half「上半部分」和bottom-half「下半部分」</h4><p>在调用中断处理函数前会禁止中断，如果执行中断处理函数占用的时间越长，那么系统的响应性就越差，也就越有可能丢失更多中断。同时，在禁止中断后调用执行可阻塞函数很可能导致死锁或者增大响应延迟， 比如在中断禁止期间调用sleep函数，系统将会挂死「hang」。为了解决这些问题，一方面确保中断处理函数被隔离在一个安全的执行环境「中断上下文」内运行，另一方面提高中断处理函数的执行速度。</p>
<p>将中断处理函数要完成的任务一分为二，得出上半部分和下半部分，上半部分在执行中断处理函数期间完成，下半部分则推迟到中断处理函数完成之后才开始处理。上半部分在中断上下文「interrupt context」内越快完成越好，而可中断任务或其他费时任务都尽量推迟在下半部分进行。除此之外，上半部分还主要负责为下一个中断的发生做好准备和设置并调度下半部分执行的任务，而下半部分主要负责在进程上下文「process context」或中断上下文「interrupt context」内处理对时间要求较宽松的任务。比如，假设一个设备为了传输数据而产生了一个中断，上半部分负责从设备拷贝数据到内存，而下半部分负责完成较费时的数据处理任务，当然这样的方式不一定是最好的，但如果设备拥有足够大的硬件缓冲区，那么根据设备这个特性将可能通过其他方法完成数据的处理。尽管可以根据下半部分代码的要求选择临时禁用本地中断，但禁止中断的时间越短越好。</p>
<div align="center">表1 top-half与bottom-half的对比
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">比对内容</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">top-half</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">bottom-half</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">执行位置</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">在硬中断处理程序中完成<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">在执行完硬件中断处理程序后进行</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">执行环境</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">硬中断上下文</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">软中断上下文或进程上下文</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">中断状态</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">在禁止中断的状态下执行</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">在容许中断的状态下执行</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">主要任务</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">尽量执行最少的任务，越快执行完越好，防止丢失后续发生的中断<br>并利用下半部分的机制延迟处理任务</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">处理较费时的或可能阻塞的延迟任务</td></tr></table></div>

<p>在Linux内核中，实现的多个下半部分机制分别是softirq、tasklet、workqueue和kernel thread。注意hardirq和softirq与top-half和bottom-half并不等同，softirq和tasklet都是执行在中断上下文「interrupt context」，而workqueue「工作队列」和kernel thread「内核线程」都是执行在进程上下文「process context」。</p>
<p><img data-src="/images/24/interrupt_delay_top_bottom.svg" alt="top-half vs bottom-half"></p>
<center>图1 上半部分与下半部分</center>

<h5 id="硬中断「hardirq」和软中断「softirq」"><a href="#硬中断「hardirq」和软中断「softirq」" class="headerlink" title="硬中断「hardirq」和软中断「softirq」"></a>硬中断「hardirq」和软中断「softirq」</h5><p>在<a href="https://chasinglulu.github.io/2019/07/07/%E4%B8%AD%E6%96%AD%E3%80%8Cinterrupt%E3%80%8D/">中断「interrupt」</a> 的第一节，从体系架构的角度说明了硬件中断「hardware irq」和软件中断「software irq」。在Linux内核，所有中断也划分为两类：硬件中断和软件中断。接下来看看Linux内核是如何定义硬中断和软中断的，硬中断指的是处理硬件中断和IPIs「Inter Processor Interrupts」的硬中断上下文「hard interrupt context」，其既不可能出现睡眠也不可能被抢占「preemption」，对处理时间的要求比较苛刻，中断处理程序执行的速度越快越好，这样能够提高系统的实时性。软中断指的是处理费时任务的软中断上下文，其既不可能出现睡眠也不可能被软中断上下文执行的其它任务抢占，但可以被硬中断上下文执行的处理任务抢占， 对处理时间的要求较宽松，主要处理比较耗时的和可中断的任务。不过，在硬中断上下文和软中断上下文之间出现共享数据时必须考虑数据同步「synchronization」问题。</p>
<h4 id="softirq「软中断」"><a href="#softirq「软中断」" class="headerlink" title="softirq「软中断」"></a>softirq「软中断」</h4><p>softirq也是Linux下半部分「bottom-half」机制中的一种延迟处理机制，运行在软中断上下文并能高效地处理延迟任务。</p>
<div align="center">表2 softirq的优先级和功能
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center;vertical-align:top">优先级「priority」<br></th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center;vertical-align:top">名 称</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center;vertical-align:top">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">0</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">HI_SOFTIRQ<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">最高优先级，用于处理TASKLET_HI<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">1</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">TIMER_SOFTIRQ<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于处理每个CPU的计时器中断「timer interrupt」<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">2</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">NET_TX_SOFTIRQ<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于处理网络设备的报文发送中断<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">3</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">NET_RX_SOFTIRQ</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于处理网络设备的报文接收中断</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">4</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">BLOCK_SOFTIRQ</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于处理块设备「block device」的中断</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">5</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">IRQ_POLL_SOFTIRQ</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于执行IOPOLL的回调函数「handler」</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">6</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">TASKLET_SOFTIRQ</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于处理tasklet</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">7</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">SCHED_SOFTIRQ</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于处理调度「schedule」相关的IPI和执行CFS的负载均衡例程</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">8</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">HRTIMER_SOFTIRQ</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">目前没有使用，还保留也只是为了占用一个数字</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">9</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">RCU_SOFTIRQ</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于处理RCU中断，最低优先级，因此每次都在最后处理</td></tr></table></div>

<p>通过查看&#x2F;proc&#x2F;softirq能够获得系统各个CPU的softirq统计信息。</p>
<p><img data-src="/images/24/softirqs_stat.jpeg" alt="softirqs_stat"></p>
<center>图2 读取/proc/softirqs时输出内容 </center>

<h5 id="softirq机制初始化"><a href="#softirq机制初始化" class="headerlink" title="softirq机制初始化"></a>softirq机制初始化</h5><p>在start_kernel()中，先完成中断硬件的初始化，然后才进行softirq机制的初始化。由于tasklet是softirq「软中断」的一部分，在softirq初始化中不仅为实现tasklet机制做准备，而且还注册处理tasklet的动作「action」。</p>
<p><strong>kernel&#x2F;softirq.c的softirq_init()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">			&amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">		per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">			&amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">	open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过遍历支持的所有CPU「possible cpu」初始化每个CPU对应的tasklet_vec和tassklet_hi_vec两个链表。这样做的缘由是分别指向两个链表头部的两个tasklet变量都被声明为percpu变量，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_vec)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_hi_vec)</span>;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/24/tasklet_vec_list.svg" alt="tasklet_vec_list"></p>
<center>图3 tasklet_vec链表的示意图</center>

<p>为TASKLET_SOFTIRQ和HI_SOFTIRQ分别指定了tasklet_action和tasklet_hi_action处理函数，至于其他的softirq的处理函数也都是在它们各自的初始化函数中通过open_softirq函数指定的。</p>
<h6 id="softirq与tasklet"><a href="#softirq与tasklet" class="headerlink" title="softirq与tasklet"></a>softirq与tasklet</h6><p>让我们对比一下softirq和tasklet的功能特点。softirq是在编译链接时静态定义的，也就是提前分配的，而tasklet是在运行时动态创建和注册的。一个softirq的处理函数能够并行地运行在多个CPU 上，因此softirq的处理函数对共享资源操作时需要同步。然而同一个tasklet处理函数不能同时运行，因此同步是不必要的。</p>
<div align="center">表3 softirq与tasklet的对比
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center;vertical-align:top">比对的特点</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center;vertical-align:top">softirq</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center;vertical-align:top">tasklet</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:middle">并行能力<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">同一个softirq处理函数能够同时运行在多个CPU上，因此同步是必要的<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">同一个tasklet处理函数不能同时运行在多个CPU上，因此同步是不必要的</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:middle">中断处理函数的注册方法<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">只能在编译链接时静态注册<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">不仅能静态注册而且还能动态注册</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:middle">优先级<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">每个softirq都具有一个执行优先级 ，如果在同一时刻有多个待处理的softirq，那么最高优先级的softirq会被先处理<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">tasklet只有两种优先级：高优先级「high priority」和正常优先级「normal priority」</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:middle">使用场景<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">仅在执行非常频繁且需要并行处理的场景下才使用<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">在softirq不能胜任和需要串行化处理的情况下使用，同时在设备驱动中也是可以使用的</td></tr></table></div>

<h5 id="softirq处理函数注册"><a href="#softirq处理函数注册" class="headerlink" title="softirq处理函数注册"></a>softirq处理函数注册</h5><p>内核为每个softirq指定一个处理函数，正如硬件中断一样也具有处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;kernel/softirq.c&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br><span class="line">&#123;</span><br><span class="line">	softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过softirq对应编号索引softirq_vec数组，为指定的softirq设置处理函数「action」。</p>
<h5 id="softirq触发"><a href="#softirq触发" class="headerlink" title="softirq触发"></a>softirq触发</h5><p>接下解释内核是如何触发软中断的。不过目前为了触发软中断，多数是调用raise_softirq()函数来触发指定软中断。</p>
<p><strong>kernel&#x2F;softirq.c中raise_softirq()和raise_softirq_irqoff</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	raise_softirq_irqoff(nr);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function must run with irqs disabled!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">raise_softirq_irqoff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	__raise_softirq_irqoff(nr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we&#x27;re in an interrupt or softirq, we&#x27;re done</span></span><br><span class="line"><span class="comment">	 * (this also catches softirq-disabled code). We will</span></span><br><span class="line"><span class="comment">	 * actually run the softirq once we return from</span></span><br><span class="line"><span class="comment">	 * the irq or softirq.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Otherwise we wake up ksoftirqd to make sure we</span></span><br><span class="line"><span class="comment">	 * schedule the softirq soon.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!in_interrupt())</span><br><span class="line">		wakeup_softirqd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __raise_softirq_irqoff(<span class="type">unsigned</span> <span class="type">int</span> nr)</span><br><span class="line">&#123;</span><br><span class="line">	trace_softirq_raise(nr);</span><br><span class="line">	or_softirq_pending(<span class="number">1UL</span> &lt;&lt; nr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>保存当前的硬件中断状态并禁止当前核心的中断，本质上它就是local_irq_disabled()函数又添加了一个中断状态保存功能。是否需要调用保存中断状态的local_irq_save()取决于具体的需求和场景。</li>
<li>在中断禁止的状态下调用触发softirq的函数</li>
<li>进一步调用内部触发softirq的函数</li>
<li>如果当前没有处在中断上下文，将唤醒ksoftirqd内核线程。内核线程ksoftirqd是在启动阶段预先创建的，而且每个CPU都对应一个该内核线程，其优先级是SCHED_NORMAL。这里所说的中断上下文既可以是硬件中断「hardirq」上下文也可以是软中断「softirq」上下文。</li>
<li>标记指定的softirq为待处理「pending」状态。本质上，内核用irq_cpustat_t数据结构静态定义了一个percpu irq_stat变量，它包含了一个<code>__softirq_pending</code>字段，该字段中每个bit位都对应一种softirq，一旦当前CPU私有<code>__softirq_pending</code>字段中某一个bit位被置1，那就是表示当前CPU上至少有一个对应的softirq是待处理的。如果在当前CPU所属的<code>__softirq_pending</code>字段中特定softirq对应的bit位未置位，那么该函数就会将其对应bit位置1，以表示至少有一个该softirq是待处理的。</li>
</ul>
<h5 id="softirq处理"><a href="#softirq处理" class="headerlink" title="softirq处理"></a>softirq处理</h5><p>下面将分析待处理softirq的处理过程。一旦完成硬件中断的处理过程，如果存在待处理的softirq，那么将进入软中断上下文「不是硬件中断上下文」开始进行未处理softirq的处理过程。因此，在下半部机制中softirq是实时性最好的和处理最及时的。图4给出了el1_irq的执行路径。除此之外，驱动代码或其他函数会先禁用了下半部机制，然后它们在处理完后需再次激活下半部机制，那么此时将可能对待处理softirq进行处理，图4右边的流程正是这种情况的处理路径。最后，内核线程ksoftirqd也可能进行softirq的处理，而且每个CPU都有一个这样的内核线程。如下几种情况会使用内核线程来处理softirq：</p>
<ul>
<li>调用raise_softirq()来触发softirq</li>
<li>在硬件中断处理路径上检测到已经设置了force_irqthreads（在内核命令行添加threadirqs参数）</li>
<li>已经较长时间在__do_softirq()内处理待处理的softirq或超过了最大重复次数</li>
</ul>
<p><img data-src="/images/24/softirq_flow.svg" alt="softirq_execution_path"></p>
<center>图4 softirq的处理流程</center>

<h6 id="do-softirq-：核心的softirq处理函数"><a href="#do-softirq-：核心的softirq处理函数" class="headerlink" title="__do_softirq()：核心的softirq处理函数"></a>__do_softirq()：核心的softirq处理函数</h6><p>接下来详细地分析一下softirq是如何在__do_softirq函数中被准确处理的。</p>
<p><strong>kernel&#x2F;softirq.c中__do_softirq()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __softirq_entry __do_softirq(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> end = jiffies + MAX_SOFTIRQ_TIME;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> old_flags = current-&gt;flags;</span><br><span class="line">	<span class="type">int</span> max_restart = MAX_SOFTIRQ_RESTART;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line">	<span class="type">bool</span> in_hardirq;</span><br><span class="line">	__u32 pending;</span><br><span class="line">	<span class="type">int</span> softirq_bit;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Mask out PF_MEMALLOC s current task context is borrowed for the</span></span><br><span class="line"><span class="comment">	 * softirq. A softirq handled such as network RX might set PF_MEMALLOC</span></span><br><span class="line"><span class="comment">	 * again if the socket is related to swap</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	current-&gt;flags &amp;= ~PF_MEMALLOC;</span><br><span class="line"></span><br><span class="line">	pending = local_softirq_pending();</span><br><span class="line">	account_irq_enter_time(current);</span><br><span class="line"></span><br><span class="line">	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET);</span><br><span class="line">	in_hardirq = lockdep_softirq_start();</span><br><span class="line"></span><br><span class="line">restart:</span><br><span class="line">	<span class="comment">/* Reset the pending bitmask before enabling irqs */</span></span><br><span class="line">	set_softirq_pending(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	h = softirq_vec;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((softirq_bit = ffs(pending))) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> vec_nr;</span><br><span class="line">		<span class="type">int</span> prev_count;</span><br><span class="line"></span><br><span class="line">		h += softirq_bit - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		vec_nr = h - softirq_vec;</span><br><span class="line">		prev_count = preempt_count();</span><br><span class="line"></span><br><span class="line">		kstat_incr_softirqs_this_cpu(vec_nr);</span><br><span class="line"></span><br><span class="line">		trace_softirq_entry(vec_nr);</span><br><span class="line">		h-&gt;action(h);</span><br><span class="line">		trace_softirq_exit(vec_nr);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(prev_count != preempt_count())) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\n&quot;</span>,</span><br><span class="line">			       vec_nr, softirq_to_name[vec_nr], h-&gt;action,</span><br><span class="line">			       prev_count, preempt_count());</span><br><span class="line">			preempt_count_set(prev_count);</span><br><span class="line">		&#125;</span><br><span class="line">		h++;</span><br><span class="line">		pending &gt;&gt;= softirq_bit;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcu_bh_qs();</span><br><span class="line">	local_irq_disable();</span><br><span class="line"></span><br><span class="line">	pending = local_softirq_pending();</span><br><span class="line">	<span class="keyword">if</span> (pending) &#123;</span><br><span class="line">		<span class="keyword">if</span> (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;</span><br><span class="line">		    --max_restart)</span><br><span class="line">			<span class="keyword">goto</span> restart;</span><br><span class="line"></span><br><span class="line">		wakeup_softirqd();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lockdep_softirq_end(in_hardirq);</span><br><span class="line">	account_irq_exit_time(current);</span><br><span class="line">	__local_bh_enable(SOFTIRQ_OFFSET);</span><br><span class="line">	WARN_ON_ONCE(in_interrupt());</span><br><span class="line">	current_restore_flags(old_flags, PF_MEMALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="workqueue「工作队列」"><a href="#workqueue「工作队列」" class="headerlink" title="workqueue「工作队列」"></a>workqueue「工作队列」</h4><p><img data-src="/images/24/workqueu_state_change.svg" alt="workqueu_state_change"></p>
<center>图5 wokequeue的状态变化</center>

<h5 id="cmwq「Concurrency-Managed-Workqueues」"><a href="#cmwq「Concurrency-Managed-Workqueues」" class="headerlink" title="cmwq「Concurrency-Managed Workqueues」"></a>cmwq「Concurrency-Managed Workqueues」</h5><p><img data-src="/images/24/cmwq_structure.svg" alt="cmwq_structure"></p>
<center>图6 cmwq框架结构</center>

<p><img data-src="/images/24/queue_work_call_flow.svg" alt="__queue_work_call_flow"></p>
<center>图7 __queue_work()调用流程 I</center>

<p><img data-src="/images/24/queue_work_call_flow_II.svg" alt="__queue_work_call_flow_II"></p>
<center>图8 __queue_work()调用流程 II</center>]]></content>
      <categories>
        <category>interrupt management</category>
      </categories>
      <tags>
        <tag>interrupt</tag>
        <tag>softirq</tag>
        <tag>tasklet</tag>
        <tag>workqueue</tag>
      </tags>
  </entry>
  <entry>
    <title>内存模型「memory model」</title>
    <url>/posts/dae1ffea/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;不同Linux内存模型以不同方式管理和组织可用物理内存，具体方式取决于系统物理内存是否不连续且存在空隙。本文讨论Linux支持的三种内存模型以及如何管理每种内存模型的内存映射「memory map」，比如FLATMEM模型的mem_map。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h3 id="内存模型种类"><a href="#内存模型种类" class="headerlink" title="内存模型种类"></a>内存模型种类</h3><h4 id="三种内存模型"><a href="#三种内存模型" class="headerlink" title="三种内存模型"></a>三种内存模型</h4><p>&ensp;&ensp;&ensp;&ensp;Linux目前支持三种内存模型：FLATMEM、DISCONTIGMEM和SPARSEMEM。某些体系架构支持多种内存模型，但在内核编译构建时只能选择使用一种内存模型。</p>
<p><img data-src="/images/18/memory_model.svg" alt="memory_model.svg"></p>
<center>图1 支持的内存模型</center>

<h4 id="内存模型特点"><a href="#内存模型特点" class="headerlink" title="内存模型特点"></a>内存模型特点</h4><p>下面分别讨论每种内存模型的特点：</p>
<ul>
<li>FLATMEM<ul>
<li>内存连续且不存在空隙</li>
<li>在大多数情况下，应用于UMA系统「Uniform Memory Access」</li>
</ul>
</li>
<li>DISCONTIGMEM<ul>
<li>多个内存节点不连续并且存在空隙「hole」</li>
<li>适用于UMA系统和NUMA系统「Non-Uniform Memory Access」</li>
<li>ARM在2010年已移除了对DISCONTIGMEM内存模型的支持<ul>
<li><a href="https://github.com/torvalds/linux/commit/be370302742ff9948f2a42b15cb2ba174d97b930">ARM: Remove DISCONTIGMEM support</a></li>
</ul>
</li>
</ul>
</li>
<li>SPARSEMEM<ul>
<li>多个内存区域不连续并且存在空隙</li>
<li>支持内存热插拔「hot-plug memory」，但性能稍逊色于DISCONTIGMEM</li>
<li>在x86或ARM64内核采用了最近实现的SPARSEMEM_VMEMMAP变种，其性能比DISCONTIGMEM更优并且与FLATMEM相当</li>
<li>对于ARM64内核，默认选择SPARSEMEM内存模型</li>
<li>以section为单位管理online和hot-plug内存</li>
</ul>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;section大小从几十MiB到几GiB不等，取决于体系架构和内核的配置。通常在系统配置中将内存扩展单元「memory expansion unit」用作section大小。比如，如果系统内存可扩展至64GiB，并且最小内存扩展单元为1GiB，则设置section大小也为1GiB。当使用Linux系统作为hypervisor的客户操作系统「guest OS」，也是以section大小为单元在运行时向Linux系统增添内存和移除Linux系统的内存。</p>
<div align="center">表1 主流体系架构支持的内存模型
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">体系架构</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">FLATMEM</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#fff;background-color:#409cff;text-align:center;vertical-align:top">DISCONTIGMEM</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#fff;background-color:#409cff;text-align:center;vertical-align:top">SPARSEMEM</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">ARM</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">O（默认）</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">X</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">Δ（某些系统的可选配置）</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">ARM64</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">X<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">X</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">O（默认）</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">x86_32</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">O（默认）<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">X</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">O</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">x86_32 with NUMA</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">X</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">O（默认）</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">O</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">x86_64</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">X</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">X</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">O（默认）</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">x86_64 with NUMA</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">X</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center;vertical-align:top">X</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center;vertical-align:top">O（默认）</td></tr></table></div>

<h4 id="选择内存模型的配置选项"><a href="#选择内存模型的配置选项" class="headerlink" title="选择内存模型的配置选项"></a>选择内存模型的配置选项</h4><p>&ensp;&ensp;&ensp;&ensp;如果在一个体系架构中有多种内存模型可用（ARM64只支持一种内存模型），通过可选的内核配置选项来决定使用哪种内存模型。首先，打开ARCH_SELECT_MEMORY_MODEL和SELECT_MEMORY_MODEL内核配置选项以允许用户能够手动选择内存模型。此后，每种内存模型要求的内核配置选项如图2所示。</p>
<p><img data-src="/images/18/memory_model_options.svg" alt="memory_model_options.svg"></p>
<center>图2 确定内存模型的内核配置选项</center>

<h4 id="更多关于内存模型的配置选项"><a href="#更多关于内存模型的配置选项" class="headerlink" title="更多关于内存模型的配置选项"></a>更多关于内存模型的配置选项</h4><p>&ensp;&ensp;&ensp;&ensp;一旦已确定使用的内存模型，还可以设置与内存模型相关的其他配置选项。每种内存模型牵涉的具体配置选项如图3所示。</p>
<p><img data-src="/images/18/memory_model_detail.svg" alt="memory_model_detail.svg"></p>
<center>图3 与内存模型相关的具体配置选项</center>

<p>内存模型涉及的配置选项如下表所示。</p>
<div align="center">表2 与内存模型相关的各个配置选项
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">内核配置选项</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_NEED_MULTIPLE_NODES</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">DISCONTIGMEM内存模型和NUMA系统会选择该配置选项，通常它们需要多个内存节点来组织内存。通过NODE_DATA()宏能够获得每个节点的内存映射「mem_map」，一个pglist_data实例用于管理一个节点的内存，全局数组node_data[ ]保存指向pglist_data实例的指针，通过直接使用node_data[ ]也能够访问每个节点的内存映射「mem_map」。在只有一个内存节点的情况下，将不启用该配置选项，仅使用全局变量*mem_map（指向struct page实例的数组）管理这唯一节点的内存</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_FLAT_NODE_MEM_MAP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">FLATMEM内存模型和DISCONTIGMEM内存模型都能选择它。通过pglist_data实例的node_mem_map成员能够访问节点的内存映射「mem_map」<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_HAVE_MEMORY_PRESENT</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">在SPARSEMEM内存模型中，指定的内存地址空间很可能存在多个空隙，它意味着以section为单元对分散的内存进行管理。<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_SPARSEMEM_EXTREME<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">使**mem_section指向一个动态分配的指针数组，其每个元素再指向struct mem_section实例数组的首地址，这个实例数组也是根据情况动态分配的。通常存在较多section的情况下会选择它。<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_SPARSEMEM_STATIC<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">使用在编译时声明定义的mem_section[ ][ ]去管理内存。通常section数量较少的情况下会选择它。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_SPARSEMEM_VMEMMAP<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">通过vmemmap能够在pfn和page实例地址之间快速转换。它多用于具有较大vmalloc区域的64位系统。<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_MEMORY_HOTREMOVE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">内存能在系统运行期间被移除。当CONFIG_MEMORY_HOTPLUG、CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE和CONFIG_MIGRATION配置选项可用时才能选择它。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_HAVE_MEMBLOCK_NODE_MAP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">将一个节点的内存只用作可移动内存「movable memory」，用于阻止内存碎片。若选择了该配置选项并在内核命令行设置movable_node参数， 在使热插入的内存节点online前通过sysfs设置对应节点的state属性为`online_movable`，那么该内存节点就是可移动节点。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_MEMORY_HOTPLUG_SPARSE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">SPARSEMEM和MEMORY_HOTPLUG配置选项决定该配置选项是否被选择。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_NO_BOOTMEM</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">不启用内核的早期内存分配器bootmem。ARM已经用memblock取代了bootmem，越来越多的架构弃用bootmem并过渡到memblock。<br>2018年linux-4.20版本已经彻底移除bootmem「[mm: remove bootmem allocator implementation.](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=355c45affca7114ab510e296a5b7012943aeea17)」</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_HAVE_MEMBLOCK</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">使用早期内存分配器memblock</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_HIGHMEM</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">在32位系统，highmem不会被线性映射到内核地址空间。无论何时要使用这部分内存，必须先映射然后才能访问。如果32位系统的物理内存大于内核地址空间的大小，开启CONFIG_HIGHMEM配置选项能使更多的物理内存可用。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">CONFIG_HIGHPTE</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">在32位内核中，启用该配置选项会使第二级PTE占用的内存从highmem分配。如果32位系统拥有很多物理内存，将第二级PTE放入highmem能减少lowmem的消耗。</td></tr></table></div>

<h3 id="内存映射「memory-map」"><a href="#内存映射「memory-map」" class="headerlink" title="内存映射「memory map」"></a>内存映射「memory map」</h3><p>&ensp;&ensp;&ensp;&ensp;内存映射「mem_map」是一个页帧描述符「page frame descriptor」数组，其管理顺序排列的页帧。页帧描述符包括页帧的属性和管理数据。在Linux内核，用struct page表示页帧描述符。涉及内存映射的主要内容如下：</p>
<ul>
<li>页用途管理 「page usage management」</li>
<li>伙伴内存分配器「buddy memory allocator」</li>
<li>slab内存分配器「slab memory allocator」</li>
<li>页统计信息「page count information」</li>
</ul>
<p>管理内存映射的方式取决于选用的内存模型。</p>
<ul>
<li>FLATMEM: 用全局指针变量*mem_map管理单个连续内存，其指向struct page类型数组的首地址。</li>
<li>DISCONTIGMEM: 用全局数组node_data[]管理所有节点的内存，CONFIG_NODES_SHIFT配置选项决定数组的容量，数组元素数量应尽可能与内存节点个数一样。数组每个元素是指向pglist_data实例的指针，一个pglist_data实例管理一个节点的内存。struct pglist_data的node_mem_map字段指向struct page类型数组的首地址，用于管理节点的所有物理页帧。</li>
<li>SPARSEMEM: 用全局数组mem_section[]管理分散稀疏的内存，数组大小等于在编译时体系架构可用物理地址空间的大小(可由配置选项设置)除以section大小。数组每个元素是指向mem_section实例的指针，如果一个section存在物理内存，则用一个mem_section实例进行管理（注意：数组名称mem_section[]和结构体名称struct mem_section相同）。struct mem_section的section_mem_map字段指向struct page类型数组的首地址，用于管理section的所有物理页帧。</li>
</ul>
<p>如图4所示显示了不同内存模型的内存映射方法。</p>
<p><img data-src="/images/18/memory_model_mem_map.svg" alt="memory_model_mem_map.svg"></p>
<center>图4 对三种内存模型的内存映射进行对比</center>

<p>接下来仔细分析一下每种内存模型的内存映射。</p>
<h4 id="平坦内存模型「flat-memory-model」的内存映射管理"><a href="#平坦内存模型「flat-memory-model」的内存映射管理" class="headerlink" title="平坦内存模型「flat memory model」的内存映射管理"></a>平坦内存模型「flat memory model」的内存映射管理</h4><p>&ensp;&ensp;&ensp;&ensp;在平坦内存模型中，毗邻连续地排列所有页帧描述符。全局指针变量mem_map指向首个页帧描述符。同时结构体变量contig_page_data的node_mem_map成员也指向第一个页帧描述符。</p>
<p><img data-src="/images/18/memory_model_flat.svg" alt="memory_model_flat.svg"></p>
<center>图5 FLATMEM的内存映射管理</center>

<h4 id="不连续内存模型「discontiguous-memory-model」的内存映射管理"><a href="#不连续内存模型「discontiguous-memory-model」的内存映射管理" class="headerlink" title="不连续内存模型「discontiguous memory model」的内存映射管理"></a>不连续内存模型「discontiguous memory model」的内存映射管理</h4><p>&ensp;&ensp;&ensp;&ensp;非连续内存模型由多个内存节点组成，每个节点的页帧数决定了页帧描述符的数量。通过node_data数组获取指定节点的实例，然后使用节点实例的node_mem_map成员来管理每个节点的页帧描述符。</p>
<p><img data-src="/images/18/memory_model_discontiguous.svg" alt="memory_model_discontiguous.svg"></p>
<center>图6 DISCONTIGMEM的内存映射管理</center>

<h4 id="稀疏内存模型「sparse-memory-model」的内存映射管理"><a href="#稀疏内存模型「sparse-memory-model」的内存映射管理" class="headerlink" title="稀疏内存模型「sparse memory model」的内存映射管理"></a>稀疏内存模型「sparse memory model」的内存映射管理</h4><p>&ensp;&ensp;&ensp;&ensp;稀疏内存模型以固定大小的单元统一管理分散的内存，易于内存管理。这个固定大小的单元被称为内存段「section」。通过这种方式划分整个物理地址空间以及当前存在的内存。结构体struct mem_section管理一个section，并通过section_mem_map成员指向一个页帧描述符数组（page数组），数组元素数量为PAGES_PER_SECTION。在稀疏内存模型中，section是最小的单元，其大小从几十MB到几GB不等，用于管理online&#x2F;offline（热插拔）内存。目前存在两种方法用于管理不同数量的section。</p>
<ul>
<li>CONFIG_SPARSEMEM_STATIC：大多数32位系统和section数量不多的情况会利用这种方法管理内存。在编译时就能确定section数量。</li>
<li>CONFIG_SPARSEMEM_EXTREME（ARM64默认启用）：大多数64位系统和section数量较多的情况会利用这种方法管理内存。如果内存中存在较大的空隙，使用两级section管理数组能够减少内存的浪费。在初始化时创建第一级管理数组（一个指针数组mem_section[ ]），只有在必要的情况下才创建第二级管理数组（mem_section实例数组）。</li>
</ul>
<p>图7所示显示了一个启用了CONFIG_SPARSEMEM_STATIC配置选项的例子。</p>
<p><img data-src="/images/18/memory_model_sparse_static.svg" alt="memory_model_sparse_static.svg"></p>
<center>图7 SPARSEMEM的内存映射管理（CONFIG_SPARSEMEM_STATIC）</center>

<p>图8所示显示了一个启用了CONFIG_SPARSEMEM_EXTREME配置选项的例子。</p>
<p><img data-src="/images/18/memory_model_sparse_dynamic.svg" alt="memory_model_sparse_dynamic.svg"></p>
<center>图8 SPARSEMEM的内存映射管理（CONFIG_SPARSEMEM_EXTREME）</center>

<blockquote>
<p>页帧描述符扩展(page_ext)「page frame descriptor extension」<br>内存调试需要使用page_ext，把它从页帧描述符中分离出来是为了防止struct page变大。当开启了内存调试，并且在内核命令行指定相关的参数，比如<code>debug_guardpage_minorder</code>、<code>debug_pagealloc</code>和<code>page_owner</code>等内核参数，page_ext实例在启动或内存热插拔时被分配创建。在内存调试完成后，如果删除了所有相关内核命令行参数，那么在重启内核时，将不会再生成page_ext实例。</p>
</blockquote>
]]></content>
      <categories>
        <category>memory management</category>
      </categories>
      <tags>
        <tag>memory model</tag>
      </tags>
  </entry>
  <entry>
    <title>内核启动分析1「head.S」</title>
    <url>/posts/17d36bed/</url>
    <content><![CDATA[<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a><ul>
<li>DDR3: 4GiB</li>
</ul>
</li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>armv8 arch</category>
      </categories>
      <tags>
        <tag>head.S</tag>
      </tags>
  </entry>
  <entry>
    <title>中断「interrupt」</title>
    <url>/posts/a0d0775f/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;中断使交互式计算的实现成为可能。如果在任务执行期间发生了中断，操作系统将响应处理中断请求，然后继续执行上一个任务或新任务。借助中断，内核能够实现多任务处理「multitasking」。其实在计算机中有很多场景会发生中断，比如从网络设备发送和接收数据包「packet」、通过鼠标或触摸屏等输入设备接收用户输入内容。本文首先从硬件角度了解了什么是中断，然后介绍了从中断硬件抽象出来的Linux通用中断处理层「generic interrupt handling layer」，最后分析了中断子系统的初始化。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h3 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h3><h4 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h4><p>&ensp;&ensp;&ensp;&ensp;中断就是硬件或软件生成的信号「signal」和事件「event」。一旦中断发生，处理器会立即中止现在的执行并响应中断请求。硬件中断就是从设备发送给处理器的物理信号「physical signal」。一旦设备满足特定条件，它就会通知处理器并要求立刻处理。软件中断是由运行在处理器上的软件生成的信号，且它多发生在特殊情况，比如执行系统调用「system call」、陷阱「trap」指令或系统提供的其他中断生成指令。</p>
<h4 id="中断控制器「interrupt-controller」"><a href="#中断控制器「interrupt-controller」" class="headerlink" title="中断控制器「interrupt controller」"></a>中断控制器「interrupt controller」</h4><p>&ensp;&ensp;&ensp;&ensp;处理器能不能接受和处理很多设备同时发送的中断？实际上这是可能的，正是由于中断控制器的存在，使多个设备产生的中断复用处理器的一条中断线。中断控制器仲裁并按顺序转递设备发出的中断给处理器。在多核系统「multicore system」中，每个核心都可以接收中断，因此中断控制器要与每个核心的控制接口相连接。</p>
<p><img data-src="/images/23/interrupt.svg" alt="interrupt"></p>
<center>图1 中断与中断控制器</center>

<h5 id="中断控制器的功能"><a href="#中断控制器的功能" class="headerlink" title="中断控制器的功能"></a>中断控制器的功能</h5><p>中断控制器有如下主要功能：</p>
<ul>
<li>中断复用和路由「interrupt multiplexing and routing」</li>
<li>中断优先处理「interrupt prioritizing」</li>
<li>中断屏蔽「interrupt masking」</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;除了以上主要功能外，中断控制器目前引入越来越多的其他功能，比如支持多核处理器「multicore processor」、支持唤醒事件「wakeup event」以及生成软件中断等。随着各个体系架构的改进，中断控制器所需的功能也在不断变化。例如，ARM定义了通用中断控制器「Generic Interrupt Controller，GIC」，随着ARM体系架构的演进，GIC的版本也在不断迭代，目前已经迭代到GICv3&#x2F;v4。比如，最新的GICV3&#x2F;v4支持了ARMv8架构的安全扩展[security extension]和虚拟化扩展[virtualization extension]，其能够分配安全和非安全状态【secure&#x2F;non-secure state】的中断，以及能够触发产生虚拟中断并发送给虚拟机【virtual machine, VM】</p>
<h5 id="多中断控制器的结构"><a href="#多中断控制器的结构" class="headerlink" title="多中断控制器的结构"></a>多中断控制器的结构</h5><p>&ensp;&ensp;&ensp;&ensp;一个简单的系统仅需使用一个中断控制器，但有些系统却需使用多个中断控制器。比如，在有些系统中GPIO控制器具有中断功能，通常以级联方式将它与主中断控制器相连，并被配置成从中断控制器。如图2所示，给出了两种关于多个中断控制器的配置示例。</p>
<p><img data-src="/images/23/interrupt_multiple.svg" alt="multiple interrupt controller structure"></p>
<center>图2 多个中断控制器的连接方式</center>

<h3 id="Linux中断子系统"><a href="#Linux中断子系统" class="headerlink" title="Linux中断子系统"></a>Linux中断子系统</h3><p>&ensp;&ensp;&ensp;&ensp;尽管中断控制器硬件差异很大，但通常都可以对中断控制器进行编程配置，使其能够按照设置进行操作。为了使Linux支持多种硬件系统，因此内核从中断控制器和中断信号的物理特性抽象出一个通用中断处理层「generic interrupt handling layer 」。当设备驱动调用诸如请求「requesting」、取消「canceling」、启用「enabling」和禁止「disabling」等中断操作函数时，配置数据会通过通用中断处理层被传递给中断控制器驱动的处理函数。正是由于这个抽象层的存在，不管体系架构和平台如何变化，设备驱动都能以相似的方式处理中断。相关代码都位于&lt;kernel &#x2F; irq&gt;目录下。</p>
<p><img data-src="/images/23/interrupt_irq_handling.svg" alt="linux generic irq handling layer"></p>
<center>图3 Linux通用IRQ处理方式</center>

<h4 id="irq-chip：-描述中断控制器的结构体"><a href="#irq-chip：-描述中断控制器的结构体" class="headerlink" title="irq_chip： 描述中断控制器的结构体"></a>irq_chip： 描述中断控制器的结构体</h4><p>结构体struct irq_chip用于描述和管理硬件中断芯片（控制器），称之为中断芯片描述符，其大部分字段都是由中断控制器驱动程序负责初始化的函数指针。在初始化后，内部中断处理函数「函数前面带有两个下划线__」就能直接调用它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;include/linux/irq.h&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	*<span class="title">parent_device</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span>	<span class="params">(*irq_startup)</span><span class="params">(<span class="keyword">struct</span> irq_data *data)</span>;</span><br><span class="line">	<span class="type">void</span>		(*irq_shutdown)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_enable)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_disable)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_ack)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_mask)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_mask_ack)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_unmask)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_eoi)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>		(*irq_set_affinity)(<span class="keyword">struct</span> irq_data *data, <span class="type">const</span> <span class="keyword">struct</span> cpumask *dest, <span class="type">bool</span> force);</span><br><span class="line">	<span class="type">int</span>		(*irq_retrigger)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">int</span>		(*irq_set_type)(<span class="keyword">struct</span> irq_data *data, <span class="type">unsigned</span> <span class="type">int</span> flow_type);</span><br><span class="line">	<span class="type">int</span>		(*irq_set_wake)(<span class="keyword">struct</span> irq_data *data, <span class="type">unsigned</span> <span class="type">int</span> on);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_bus_lock)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_bus_sync_unlock)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_cpu_online)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_cpu_offline)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_suspend)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_resume)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_pm_shutdown)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_calc_mask)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_print_chip)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">struct</span> seq_file *p);</span><br><span class="line">	<span class="type">int</span>		(*irq_request_resources)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line">	<span class="type">void</span>		(*irq_release_resources)(<span class="keyword">struct</span> irq_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*irq_compose_msi_msg)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">struct</span> msi_msg *msg);</span><br><span class="line">	<span class="type">void</span>		(*irq_write_msi_msg)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">struct</span> msi_msg *msg);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>		(*irq_get_irqchip_state)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="type">bool</span> *state);</span><br><span class="line">	<span class="type">int</span>		(*irq_set_irqchip_state)(<span class="keyword">struct</span> irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="type">bool</span> state);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>		(*irq_set_vcpu_affinity)(<span class="keyword">struct</span> irq_data *data, <span class="type">void</span> *vcpu_info);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*ipi_send_single)(<span class="keyword">struct</span> irq_data *data, <span class="type">unsigned</span> <span class="type">int</span> cpu);</span><br><span class="line">	<span class="type">void</span>		(*ipi_send_mask)(<span class="keyword">struct</span> irq_data *data, <span class="type">const</span> <span class="keyword">struct</span> cpumask *dest);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如表1所示，将详细说明结构体的部分主要字段。</p>
<div align="center">表1 结构体struct irq_chip的字段描述
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">字段名称</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">name</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">当读取/proc/interrupts时输出的中断芯片名称<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">irq_ack</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">当开始处理新中断时调用的回调函数<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">irq_mask</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">回调函数，用于屏蔽（禁止）特定的中断源<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">irq_eoi</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">在完成中断处理后调用的回调函数</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">irq_set_type</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">回调函数，用于设置中断流「interrupt flow」的类型，比如IRQ_TYPE_EDGE_RISING和IRQ_TYPE_LEVEL_HIGH</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">irq_get_irqchip_state</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">回调函数，获取特定中断在irqchip内部的状态<br>1. IRQCHIP_STATE_PENDING： 中断是否在挂起状态中（待处理）<br>2. IRQCHIP_STATE_ACTIVE： 中断是否在处理状态中<br>3. IRQCHIP_STATE_MASKED：中断是否在屏蔽状态中<br>4. IRQCHIP_STATE_LINE_LEVEL：IRQ管脚是否在高电平状态中</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">irq_set_irqchip_state</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">回调函数，为指定中断设置在irqchip内部的状态</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">flags</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">记录irqchip相关的控制信息</td></tr></table></div>

<h4 id="irq-domain：中断域「interrupt-domain」"><a href="#irq-domain：中断域「interrupt-domain」" class="headerlink" title="irq_domain：中断域「interrupt domain」"></a>irq_domain：中断域「interrupt domain」</h4><p>结构体struct irq_domain用于统一管理Linux内核采用的中断编号。在中断初始化过程中，Linux内核会从特定整数区间中选取一个整数作为一个中断源「interrupt source」的编号，并且使每个中断源都有一个独一无二且不重复的编号。如果系统仅存有一个中断控制器，那么能简单地给每个引脚对应的中断源分配一个编号。不过，如前所述，在有些情况下系统可能配置了多个中断控制器，所以中断源的编号方式将会有点复杂。因此内核需要一种机制去管理硬件中断编号「hwirq」与Linux中断编号「irq」之间的映射，以便使多个中断控制器之间不会出现重复相同的irq。正因如此，内核抽象出了中断域概念，由它实现处理中断号的分配和管理。</p>
<div align="center">表2 结构体struct irq_domain的主要字段描述
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">数据类型</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">字段名称</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">const char &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">name</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">中断域名称</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">const struct irq_domain_ops &#42;<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">ops<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">指向irq_domain对象的方法<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">void &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">host_data</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">私有数据指针，由irq_domain对象持有者使用，irq_domain核心代码不使用这个字段。</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">unsigned int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">flags</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">中断域标识</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">unsigned int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">mapcount</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">已映射的hwirq数量</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">irq_hw_number_t</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">hwirq_max</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">中断控制器的最大hwirq</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">unsigned int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">revmap_direct_max_irq</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">能为直接映射「direct mapping」的中断控制器设置的最大hwirq</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">unsigned int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">revmap_size</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">线性映射表（linear_revmap数组）的容量</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">struct radix_tree_root</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">revmap_tree</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">有些情况线性映射表不适合，通过基数树构建hwirq-&gt;irq的逆映射</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">unsigned int [ ]</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">linear_revmap</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">过数组构建hwirq-&gt;irq的逆映射</td></tr></table></div>

<h4 id="irq-desc：中断描述符「interrupt-descriptor」"><a href="#irq-desc：中断描述符「interrupt-descriptor」" class="headerlink" title="irq_desc：中断描述符「interrupt descriptor」"></a>irq_desc：中断描述符「interrupt descriptor」</h4><p>结构体struct irq_desc用于描述和管理中断，其大多数字段由中断处理核心部分「interrupt core」所使用。如果没有选用CONFIG_SPARSE_IRQ配置选项，中断描述符和irq之间的关联映射是通过数组，根据irq能够直接索引到对应的中断描述符。否则，通过基数数「radix tree」构建两者之间的关联映射，依据irq遍历搜索基数树才能寻找到对应的中断描述符。不管是否启用这个配置，两种情况都是通过irq_to_desc函数获取到对应的中断描述符。在ARM64的内核配置中，为了能够动态分配和管理中断描述符，默认启用了CONFIG_SPARSE_IRQ选项。</p>
<div align="center">表3 结构体struct irq_desc的主要字段描述
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">数据类型</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">字段名称</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">struct irq_common_data</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">irq_common_data</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">用于传递有关中断的信息给中断芯片「irqchip」相关函数，并且保存所有irqchip共享的数据<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">struct irq_data</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">irq_data<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">用于传递有关中断的信息给irqchip相关函数，并且保存各个irqchip独有的数据<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">unsigned int __precpu &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">kstat_irqs<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于记录每个CPU的中断统计信息<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">irq_flow_handler_t<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">handle_irq</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">为中断指定高级编程语言「C语言」实现的中断处理函数。当中断发生时，一开始会执行低级体系架构指令「汇编」实现的函数，然后才调用通用中断处理代码。<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">struct irqaction &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">action</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">提供中断处理所需的行动「action」。如果以线程形式处理中断，则要指定中断线程执行的中断处理函数「thread_fn」。对于共享中断，结构体irqaction的next字段指向下一个irqaction。</td></tr></table></div>

<h3 id="中断处理函数「interrupter-handler」"><a href="#中断处理函数「interrupter-handler」" class="headerlink" title="中断处理函数「interrupter handler」"></a>中断处理函数「interrupter handler」</h3><p>本小节首先介绍了内核代码在请求中断时如何完成中断处理函数的注册以及中断管脚的配置。然后分析了在CPU接收到物理中断信号后中断处理函数的调用流程。最后说明了各个中断容许和禁止函数、以及中断子系统初始化函数。</p>
<h4 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h4><p>所谓的中断请求其实就是启用中断号对应的中断管脚以及注册中断触发后执行的中断处理函数。一个中断管脚「interrupt line」就是一条传递中断电信号的媒介，其与中断控制器相连并且拥有一个硬件中断号「hwirq」作为标识。一旦启用的中断管脚上触发了中断，就会调用中断号对应的中断处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;include/linux/interrupt.h&gt;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>request_irq()用于注册给定的中断处理函数，它直接把给定参数全传递给request_threaded_irq()。但是除了这些参数，还为request_threaded_irq()的irq_handler_t thread_fn参数赋值NULL，因此request_irq()仅注册中断处理函数而不会创建中断线程「interrupt thread」。关于中断线程「thread_fn」的更多细节，请参考<a href="">中断延迟处理</a>。<br>在请求中断时传递给request_irq函数的参数如表4所示：</p>
<div align="center">表4 传递给request_irq()的参数
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">数据类型</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">参数名称</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">unsigned int<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">irq<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">指定的中断编号<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">irq_handler_t</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">handler<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">在中断发生时执行的中断处理函数<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">flags</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">中断属性标识<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">const char &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">name</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">中断名称，在读取/proc/interrupts时输出的名称<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">void &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">dev</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">中断处理函数在执行时使用的私有数据</td></tr></table></div>

<p>可以通过读取<code>/proc/interrupts</code>查看系统中已注册的所有中断，如图4所示。 </p>
<p><img data-src="/images/23/proc-interrupts.jpeg" alt="proc-interrupts.jpeg"></p>
<center>图4 当读取/proc/interrupts时输出画面</center>

<h5 id="request-threaded-irq函数：注册中断处理函数"><a href="#request-threaded-irq函数：注册中断处理函数" class="headerlink" title="request_threaded_irq函数：注册中断处理函数"></a>request_threaded_irq函数：注册中断处理函数</h5><p>在请求中断时调用的request_threaded_irq()函数不仅能够注册一个在中断上下文「interrupt context」执行的中断处理程序「intrrupt handler」，还可以注册一个在线程环境运行的中断处理函数「thread_fn」。除了thread_fn参数（中断线程调用执行的函数）外，其他参数都是与request_irq()的参数相同。下面代码将分析介绍该函数的具体细节。</p>
<p><strong>kernel&#x2F;irq&#x2F;manage.c的request_threaded_irq()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sanity-check: shared interrupts must pass in a real dev-ID,</span></span><br><span class="line"><span class="comment">	 * otherwise we&#x27;ll have trouble later trying to figure out</span></span><br><span class="line"><span class="comment">	 * which interrupt is which (messes up the interrupt freeing</span></span><br><span class="line"><span class="comment">	 * logic etc).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and</span></span><br><span class="line"><span class="comment">	 * it cannot be set along with IRQF_NO_SUSPEND.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	desc = irq_to_desc(irq);</span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;</span><br><span class="line">	action-&gt;thread_fn = thread_fn;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = __setup_irq(irq, desc, action);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">irq_default_primary_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>21～24行：对传递的中断标识「irqflags」进行合理性检查和验证。如果请求多个设备共享的中断并且没有指定设备标识符「device ID」，或不支持suspend的设备指定了IRQF_COND_SUSPEND标志，也就是说这两种情况都将导致请求中断失败。</li>
<li>26行：根据Linux中断号「irq」获取对应的中断描述符。</li>
<li>37行：如果没有指定在中断上下文执行的中断处理函数「参数handler」，将为其指定默认的中断处理函数。下面67～70行给出的默认中断处理函数「irq_default_primary_handler」总是返回IRQ_WAKE_THREAD。该数值表示中断处理程序「handler」需要唤醒中断处理线程去继续处理中断。注意，中断处理函数的返回值如下所示：<ul>
<li>IRQ_NONE：中断未能正确处理或者与设备不相关</li>
<li>IRQ_HANDLED：成功处理了设备产生的中断</li>
<li>IRQ_WAKE_THREAD：要求中断处理程序唤醒中断处理线程</li>
</ul>
</li>
<li>44行：根据传入的参数为中断设置struct irqaction实例</li>
<li>56行：将struct irqaction实例添入irq_desc对象的action链表</li>
</ul>
<h4 id="中断流处理函数「interrupt-flow-handler」的调用流程"><a href="#中断流处理函数「interrupt-flow-handler」的调用流程" class="headerlink" title="中断流处理函数「interrupt flow handler」的调用流程"></a>中断流处理函数「interrupt flow handler」的调用流程</h4><p>尽管中断控制器千差万别，但采用的中断流处理函数（比如handle_level_irq()、handle_percpu_irq()、handle_fasteoi_irq()、handle_edge_irq()等等）却大同小异。正如我们所知道的，基于ARMv8架构实现的AArch64核心在捕获到中断控制器触发的中断时会生成一个异步中断异常，该异常会使CPU暂停当前执行来响应处理中断。在中断异常发生后，CPU会执行函数指针handle_arch_irq所指向的一个回调函数，其是在中断控制器驱动初始化时调用set_handle_irq()设定的。<br>更具体地说，使用GIC的ARM64内核在初始化时会调用set_handle_irq()使函数指针handle_arch_irq指向gic_handle_irq()函数，因此在发生中断时就会调用执行gic_handle_irq()函数，然后其调用执行通用中断处理层的generic_handle_irq()函数，接着调用执行函数指针desc-&gt;handle_irq所指向的一个回调函数。而且desc-&gt;handle_irq指向的回调函数也是在由中断控制器驱动初始化时根据中断类型负责设定的。比如在ARM64内核中，对于单个CPU响应的中断，为desc-&gt;handle_irq所设定的回调函数都是handle_percpu_devid_irq()，对于多CPU响应的中断，为desc-&gt;handle_irq所设定的回调函数都是handle_fasteoi_irq()。</p>
<p><img data-src="/images/23/interrupt_irq_handle_process.svg" alt="irq handle process"></p>
<center>图5 中断处理函数的调用流程</center>

<p>接下来看一下handle_fasteoi_irq()函数，其处理常见设备触发的中断。</p>
<p><strong>kernel&#x2F;irq&#x2F;chip.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_fasteoi_irq</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> =</span> desc-&gt;irq_data.chip;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;desc-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!irq_may_run(desc))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	desc-&gt;istate &amp;= ~(IRQS_REPLAY | IRQS_WAITING);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If its disabled or no action available</span></span><br><span class="line"><span class="comment">	 * then mask it and get out of here:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!desc-&gt;action || irqd_irq_disabled(&amp;desc-&gt;irq_data))) &#123;</span><br><span class="line">		desc-&gt;istate |= IRQS_PENDING;</span><br><span class="line">		mask_irq(desc);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kstat_incr_irqs_this_cpu(desc);</span><br><span class="line">	<span class="keyword">if</span> (desc-&gt;istate &amp; IRQS_ONESHOT)</span><br><span class="line">		mask_irq(desc);</span><br><span class="line"></span><br><span class="line">	preflow_handler(desc);</span><br><span class="line">	handle_irq_event(desc);</span><br><span class="line"></span><br><span class="line">	cond_unmask_eoi_irq(desc, chip);</span><br><span class="line"></span><br><span class="line">	raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!(chip-&gt;flags &amp; IRQCHIP_EOI_IF_HANDLED))</span><br><span class="line">		chip-&gt;irq_eoi(&amp;desc-&gt;irq_data);</span><br><span class="line">	raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>kernel&#x2F;irq&#x2F;handle.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">handle_irq_event</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">irqreturn_t</span> ret;</span><br><span class="line"></span><br><span class="line">	desc-&gt;istate &amp;= ~IRQS_PENDING;</span><br><span class="line">	irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">	raw_spin_unlock(&amp;desc-&gt;lock);</span><br><span class="line"></span><br><span class="line">	ret = handle_irq_event_percpu(desc);</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;desc-&gt;lock);</span><br><span class="line">	irqd_clear(&amp;desc-&gt;irq_data, IRQD_IRQ_INPROGRESS);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="中断动作「irqaction」的处理"><a href="#中断动作「irqaction」的处理" class="headerlink" title="中断动作「irqaction」的处理"></a>中断动作「irqaction」的处理</h5><p>下面代码展示了__handle_irq_event_percpu()函数如何调用执行传递给request_irq()的中断处理函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> __handle_irq_event_percpu(<span class="keyword">struct</span> irq_desc *desc, <span class="type">unsigned</span> <span class="type">int</span> *flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">irqreturn_t</span> retval = IRQ_NONE;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> irq = desc-&gt;irq_data.irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">	record_irq_time(desc);</span><br><span class="line"></span><br><span class="line">	for_each_action_of_desc(desc, action) &#123;</span><br><span class="line">		<span class="type">irqreturn_t</span> res;</span><br><span class="line"></span><br><span class="line">		trace_irq_handler_entry(irq, action);</span><br><span class="line">		res = action-&gt;handler(irq, action-&gt;dev_id);</span><br><span class="line">		trace_irq_handler_exit(irq, action, res);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN_ONCE(!irqs_disabled(),<span class="string">&quot;irq %u handler %pF enabled interrupts\n&quot;</span>,</span><br><span class="line">			      irq, action-&gt;handler))</span><br><span class="line">			local_irq_disable();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (res) &#123;</span><br><span class="line">		<span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Catch drivers which return WAKE_THREAD but</span></span><br><span class="line"><span class="comment">			 * did not set up a thread function</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!action-&gt;thread_fn)) &#123;</span><br><span class="line">				warn_no_thread(irq, action);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			__irq_wake_thread(desc, action);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Fall through to add to randomness */</span></span><br><span class="line">		<span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">			*flags |= action-&gt;flags;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		retval |= res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>9行：遍历中断描述符「irq_desc」的中断动作「irqaction」链表，它们是由request_irq()创建的struct irqaction实例，一个实例描述了中断处理活动中的一个动作，主要为了封装注册的中断处理函数，隐藏handle_fn和thread_fn的差异，从而简化中断处理函数的调用执行逻辑，并使中断处理函数与通用中断处理层解耦。</li>
<li>13行：调用每个action绑定的中断处理函数，正如前面中断请求小节所述，中断处理函数一定会返回三个返回值中的一个。</li>
<li>21行：返回值IRQ_WAKE_THREAD表示需要唤醒中断处理线程去执行中断处理函数「thread_fn」。</li>
<li>34行：返回值IRQ_HANDLED表示中断处理函数已正常处理。在这种情况下，仅返回action的标识给调用者，利用它往熵池添加中断随机种子。</li>
</ul>
<h5 id="IPI「Inter-Processor-Interrupts」：处理器间的通信"><a href="#IPI「Inter-Processor-Interrupts」：处理器间的通信" class="headerlink" title="IPI「Inter Processor Interrupts」：处理器间的通信"></a>IPI「Inter Processor Interrupts」：处理器间的通信</h5><p>在SMP系统中，IPI用于传递核间事件「inter-core event」。为了使用硬件体系架构相关的特殊功能，要借助中断控制器提供的功能使IPI从一个核传递给另外其他核。因此，在中断控制器驱动初始化时将调用set_smp_cross_call()函数去设定触发IPI的回调函数。IPI不仅需要能够被一个核或多个核捕获，而且还需要能够被中断处理函数辨识出。例如，在使用GIC中断控制器的系统中，小于等于15的硬中断号「hwirq」都属于软件生成中断「SGI，Software Generated Interrupt」。如果gic_handle_irq()函数处理的中断属于SGI，那么它将调用handle_IPI()函数而不是handle_domain_irq()函数。</p>
<p>ARM64内核使用的IPI种类如下所示。内核调用smp_cross_call()函数向目标CPU发送特定IPI，该函数需要传入IPI编号和参数cpumask，其用于记录要接收IPI的CPU。</p>
<div align="center">表5 ARM64的IPI种类
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">IPI种类</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">功能</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">例子</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">IPI_RESCHEDULE<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">唤醒挂起的任务<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">使用前缀ttwu「try to wake up」的API去唤醒某个CPU上的任务<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">IPI_CALL_FUNC<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">让其他CPU执行特定的函数<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">drain_all_pages()函数将per-cpu页帧「由per-cpu分配器管理的物理内存页」交还给伙伴分配器「buddy allocator」<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">IPI_STOP_CPU<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">暂停其他CPU<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">为了系统重启暂停其他所有CPU<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">IPI_TIMER</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">调用tick时钟设备「tick-clock device」的事件处理程序<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">在广播「broadcast」tick事件时<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">IPI_IRQ_WORK<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">执行当前CPU的irq_work<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">在使用irq_work_queue()函数将irq_work入队列时<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">IPI_WAKEUP</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left">唤醒其他CPU</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">在使用APCI parking protocol唤醒CPU时</td></tr></table></div>

<h4 id="容许「enabling」与禁止「disabling」中断"><a href="#容许「enabling」与禁止「disabling」中断" class="headerlink" title="容许「enabling」与禁止「disabling」中断"></a>容许「enabling」与禁止「disabling」中断</h4><p>目前存在两种用于容许&#x2F;禁止中断的方法。第一种禁止中断的方法是禁止当前核心「core」上的所有中断，从而不可能再发生中断异常。另一种方法是屏蔽特定中断管脚「interrupt line」。同样地，容许中断的方法也是这种情况。</p>
<h5 id="容许和禁止当前核心的中断"><a href="#容许和禁止当前核心的中断" class="headerlink" title="容许和禁止当前核心的中断"></a>容许和禁止当前核心的中断</h5><p>如果禁止了核心的中断，则中断进入挂起状态以及中断处理程序不会执行。即使中断产生了也不会触发抢占「preemption 」。换句话说，禁止本地中断「local interrupt」也能保护当前核心上的执行环境「context」不受影响。但是在多核系统中，仅禁止本地中断并不能完全保护执行环境「context」不改变。由于其他核心仍然可以接收中断，如果在其他核心上执行的中断处理程序与当前核心上执行的代码共享数据，那么将可能破坏共享数据的同步。为此，在屏蔽本地中断时还需使用自旋锁「spinlock」。接下来看看如何禁止当前核心（本地）的中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;include/linux/irqflags.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_irq_enable()	do &#123; raw_local_irq_enable(); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_irq_disable()	do &#123; raw_local_irq_disable(); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_local_irq_disable()		arch_local_irq_disable()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_local_irq_enable()		arch_local_irq_enable()</span></span><br></pre></td></tr></table></figure>
<p>由于会使用处理器相关的汇编指令，所以每种体系架构的具体实现都不相同。在ARM64内核使用如下的代码。</p>
<p><strong>arch&#x2F;arm64&#x2F;include&#x2F;asm&#x2F;irqflags.h的arch_local_irq_disable()和arch_local_irq_enable()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_local_irq_enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="string">&quot;msr	daifclr, #2		// arch_local_irq_enable&quot;</span></span></span><br><span class="line"><span class="params">		:</span></span><br><span class="line"><span class="params">		:</span></span><br><span class="line"><span class="params">		: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">arch_local_irq_disable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="string">&quot;msr	daifset, #2		// arch_local_irq_disable&quot;</span></span></span><br><span class="line"><span class="params">		:</span></span><br><span class="line"><span class="params">		:</span></span><br><span class="line"><span class="params">		: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4行：将2写入DAIF清除寄存器「DAIF clear register」就能屏蔽「diable」本地中断。</li>
<li>13行：将2写入DAIF置位寄存器「DAIF set register」就能容许「enable」本地中断。<br>在ARMv8体系架构中，能够利用汇编指令仅操作PSTATE寄存器的DAIF字段。写入寄存器的值也仅根据DAIF计算得出，如果IRQ位被掩蔽「mask」，那么当前核心不再接收中断，从而使中断被挂起。反之，如果IRQ位被去除掩蔽「unmask」，那么当前核心能继续接收中断。如图6所示说明了PSTATE的DAIF位操作。</li>
</ul>
<p><img data-src="/images/23/interrupt_PSTATE_DAIF.svg" alt="DAIF field of PSTATE register"></p>
<center>图6 PSTATE寄存器的DAIF字段</center>

<h5 id="启用和屏蔽特定中断管脚「interrupt-line」"><a href="#启用和屏蔽特定中断管脚「interrupt-line」" class="headerlink" title="启用和屏蔽特定中断管脚「interrupt line」"></a>启用和屏蔽特定中断管脚「interrupt line」</h5><p>如果必要的话，驱动程序可以先屏蔽已激活的中断管脚，然后再启用那个中断管脚。然而如果中断管脚被多个设备共享，那么它就不可以被屏蔽。对中断禁止函数的调用本质上就是调用中断控制器驱动提供的回调函数。容许和屏蔽中断管脚函数都允许多次被调用，但它们只能被成对地调用。也就是说，只要调用了中断管脚屏蔽函数，就必须调用中断管脚容许函数，以致于实际的中断管脚任然是激活的。具体细节参考下面的代码。</p>
<h6 id="disable-irq-：屏蔽某个中断管脚"><a href="#disable-irq-：屏蔽某个中断管脚" class="headerlink" title="disable_irq()：屏蔽某个中断管脚"></a>disable_irq()：屏蔽某个中断管脚</h6><p>目前内核存在两种中断管脚屏蔽函数。第一种是disable_irq()函数，它屏蔽特定中断管脚，并一直等待相关的待处理中断处理程序执行完毕才返回。第二种是disable_irq_nosync()函数，它在屏蔽特定中断管脚后立马返回。</p>
<p><strong>kernel&#x2F;irq&#x2F;manage.c的disable_irq()和disable_irq_nosync()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__disable_irq_nosync(irq))</span><br><span class="line">		synchronize_irq(irq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __disable_irq(<span class="keyword">struct</span> irq_desc *desc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!desc-&gt;depth++)</span><br><span class="line">		irq_disable(desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __disable_irq_nosync(<span class="type">unsigned</span> <span class="type">int</span> irq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_get_desc_buslock(irq, &amp;flags, IRQ_GET_DESC_CHECK_GLOBAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	__disable_irq(desc);</span><br><span class="line">	irq_put_desc_busunlock(desc, flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">	__disable_irq_nosync(irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3行：__disable_irq_nosync()屏蔽特定的中断管脚，并检查它是否无错误地完成操作。</li>
<li>4行：一直等待对应中断处理程序执行结束，很可能它正在其他CPU上运行。如果直接调用disable_irq()的驱动程序与对应中断处理程序共享相同数据资源，那很有可能发生死锁。比如驱动在调用disable_irq()之前获得了资源的自旋锁，并一直等待中断处理程序执行完毕，但中断处理程序在执行过程中也需要获得该资源的自旋锁，因此这样导致死锁。</li>
<li>20行：通用中断处理函数实质上是对中断硬件相关函数的封装，__disable_irq()最终会调用中断控制器驱动初始化的irq_disable或irq_mask回调函数完成具体的中断管脚屏蔽操作。</li>
<li>9～10行：检查中断描述符对象的depth成员是否等于0，若是，irq_disable()将调用中断控制器驱动指定的中断屏蔽函数。depth是一个计数器，每调用一次__disable_irq()将它自增1。</li>
<li>27行：disable_irq_nosync()不会等待中断处理程序执行完成，它屏蔽中断管脚后直接返回。</li>
</ul>
<h6 id="enable-irq-：启用某个中断管脚"><a href="#enable-irq-：启用某个中断管脚" class="headerlink" title="enable_irq()：启用某个中断管脚"></a>enable_irq()：启用某个中断管脚</h6><p>目前内核仅有一种启用中断管脚的函数。</p>
<p><strong>kernel&#x2F;irq&#x2F;manage.c的enable_irq()和__enable_irq()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_get_desc_buslock(irq, &amp;flags, IRQ_GET_DESC_CHECK_GLOBAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (WARN(!desc-&gt;irq_data.chip,</span><br><span class="line">		 KERN_ERR <span class="string">&quot;enable_irq before setup/request_irq: irq %u\n&quot;</span>, irq))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	__enable_irq(desc);</span><br><span class="line">out:</span><br><span class="line">	irq_put_desc_busunlock(desc, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __enable_irq(<span class="keyword">struct</span> irq_desc *desc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (desc-&gt;depth) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> err_out:</span><br><span class="line">		WARN(<span class="number">1</span>, KERN_WARNING <span class="string">&quot;Unbalanced enable for IRQ %d\n&quot;</span>,</span><br><span class="line">		     irq_desc_get_irq(desc));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">		<span class="keyword">if</span> (desc-&gt;istate &amp; IRQS_SUSPENDED)</span><br><span class="line">			<span class="keyword">goto</span> err_out;</span><br><span class="line">		<span class="comment">/* Prevent probing on this irq: */</span></span><br><span class="line">		irq_settings_set_noprobe(desc);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Call irq_startup() not irq_enable() here because the</span></span><br><span class="line"><span class="comment">		 * interrupt might be marked NOAUTOEN. So irq_startup()</span></span><br><span class="line"><span class="comment">		 * needs to be invoked when it gets enabled the first</span></span><br><span class="line"><span class="comment">		 * time. If it was already started up, then irq_startup()</span></span><br><span class="line"><span class="comment">		 * will invoke irq_enable() under the hood.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		irq_startup(desc, IRQ_RESEND, IRQ_START_FORCE);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		desc-&gt;depth--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4行：在发出中断控制器操作命令之前，先要获得总线锁「bus lock」，在操作命令执行完后，还要释放总线锁，从而保证命令能在总线上同步执行「bus-level synchronization」。</li>
<li>12行：调用内部使用的中断容许函数__enable_irq()，其最终会使用中断硬件相关的回调函数去启用中断管脚。</li>
<li>19行：查看irq_desc对象的depth成员，从而选择不同的代码处理路径</li>
<li>20行：如果depth等于0，则不能启用中断管脚并输出警告消息</li>
<li>25行：如果depth等于1，则调用中断控制器驱动初始化的启用中断管脚的回调函数， 并将depth减1。</li>
<li>41行：除此之外，将记录disable_irq()调用次数的depth自减1，借助它能实现中断管脚的重复屏蔽或启用，从而追踪disable_irq()和enable_irq()两者是否成对调用。</li>
</ul>
<h4 id="中断子系统的初始化"><a href="#中断子系统的初始化" class="headerlink" title="中断子系统的初始化"></a>中断子系统的初始化</h4><p>中断子系统是内核的重要组成部分，在内核启动阶段必定会初始化中断子系统。这里将介绍的初始化函数会直接被start_kernel()调用。下面将分析代码具体完成了哪些初始化。</p>
<h5 id="early-irq-init-：初始化中断描述符"><a href="#early-irq-init-：初始化中断描述符" class="headerlink" title="early_irq_init()：初始化中断描述符"></a>early_irq_init()：初始化中断描述符</h5><p>在中断未初始化之前，首先为中断设置默认CPU亲和性「affinity 」，除此之外，还为中断硬件分配必要的中断描述符「irq_desc」实例。</p>
<p>kernel&#x2F;irq&#x2F;irqdesc.c的early_irq_init()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">early_irq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, initcnt, node = first_online_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">	init_irq_default_affinity();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Let arch update nr_irqs and return the nr of preallocated irqs */</span></span><br><span class="line">	initcnt = arch_probe_nr_irqs();</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;NR_IRQS: %d, nr_irqs: %d, preallocated irqs: %d\n&quot;</span>,</span><br><span class="line">	       NR_IRQS, nr_irqs, initcnt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(nr_irqs &gt; IRQ_BITMAP_BITS))</span><br><span class="line">		nr_irqs = IRQ_BITMAP_BITS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(initcnt &gt; IRQ_BITMAP_BITS))</span><br><span class="line">		initcnt = IRQ_BITMAP_BITS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initcnt &gt; nr_irqs)</span><br><span class="line">		nr_irqs = initcnt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; initcnt; i++) &#123;</span><br><span class="line">		desc = alloc_desc(i, node, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		set_bit(i, allocated_irqs);</span><br><span class="line">		irq_insert_desc(i, desc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arch_early_irq_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>6行：初始化struct cpumask类型的实例irq_default_affinity，其实就是分配它所用的内存空间并全部置位，结构体struct cpumask包含一个具有NR_CPUS位的位图。如果命令行参数irqaffinity指定了允许中断的CPU列表，那么irq_default_affinity位图内这些CPU对应位将被设置成1（置位）。不过，如果irq_default_affinity位图内任何位都没有被设置，也即所有位都是0（复位），则将所有CPU对应位都设置成1。</li>
<li>9行：获得NR_IRQS_LEGACY宏的值，该宏记录着每种体系架构「arch」必须提前预处理的中断数量，比如在ARM64内核中该宏的值等于0。</li>
<li>19～20行：如果initcnt大于Linux内核配置的中断数量「全局变量nr_irqs &#x3D; NR_IRQS宏」，将nr_irqs更新为预处理的中断数量。</li>
<li>23行：分配与initcnt个中断描述符「struct irq_desc」实例</li>
<li>24行：allocated_irqs位图内中断号对应位被设置成1</li>
<li>25行：如果启用了CONFIG_SPARSE_IRQ选项，则将分配的中断描述符「struct irq_desc」实例插入基数树「radix tree」。</li>
<li>27行：执行每种体系架构定义的早期中断初始化函数，比如在ARM64内核，该函数是一个不做任何事情的空函数。</li>
</ul>
<h5 id="init-IRQ-：初始化中断硬件"><a href="#init-IRQ-：初始化中断硬件" class="headerlink" title="init_IRQ()：初始化中断硬件"></a>init_IRQ()：初始化中断硬件</h5><p>该函数搜索寻找设备树「device tree」的中断控制器节点和初始化系统所用的中断控制器。</p>
<p>arch&#x2F;arm64&#x2F;kernel&#x2F;irq.c的init_IRQ()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">init_IRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	init_irq_stacks();</span><br><span class="line">	irqchip_init();</span><br><span class="line">	<span class="keyword">if</span> (!handle_arch_irq)</span><br><span class="line">		panic(<span class="string">&quot;No interrupt controller found.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4行：将设备树的所有节点与__irqchip_of_table表进行比对，从而找到匹配的中断控制器节点和对应的struct of_device_id实例。一旦发现了匹配的中断控制器节点，就会立马调用初始化函数设置中断控制器，这些都由of_irq_init()负责完成，同时它在执行初始化时还必须为handle_arch_irq指定回调函数。</p>
<h5 id="of-irq-init-：初始化中断控制器"><a href="#of-irq-init-：初始化中断控制器" class="headerlink" title="of_irq_init()：初始化中断控制器"></a>of_irq_init()：初始化中断控制器</h5><p>该函数搜索设备树的所有中断控制器节点，并根据中断控制器的层次关系依次执行中断控制器的初始化函数。__irqchip_of_table是由struct of_device_id实例组成的一个匹配比对表，这些实例是在设备驱动中声明定义的。一旦搜索发现与__irqchip_of_table的实例相匹配的中断控制器节点，就将它添入链表「intc_desc_list」的末尾。每个添入链表的中断控制器节点都设置了回调函数，因此后面能够调用它初始化中断硬件。接下来分析代码是如何执行回调函数的。</p>
<p><strong>drivers&#x2F;of&#x2F;irq.c的of_irq_init()[1&#x2F;2]</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">of_irq_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>, *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_intc_desc</span> *<span class="title">desc</span>, *<span class="title">temp_desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">intc_desc_list</span>, <span class="title">intc_parent_list</span>;</span></span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;intc_desc_list);</span><br><span class="line">	INIT_LIST_HEAD(&amp;intc_parent_list);</span><br><span class="line"></span><br><span class="line">	for_each_matching_node_and_match(np, matches, &amp;match) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!of_property_read_bool(np, <span class="string">&quot;interrupt-controller&quot;</span>) ||</span><br><span class="line">				!of_device_is_available(np))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN(!match-&gt;data, <span class="string">&quot;of_irq_init: no init function for %s\n&quot;</span>,</span><br><span class="line">			 match-&gt;compatible))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Here, we allocate and populate an of_intc_desc with the node</span></span><br><span class="line"><span class="comment">		 * pointer, interrupt-parent device_node etc.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		desc = kzalloc(<span class="keyword">sizeof</span>(*desc), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(!desc)) &#123;</span><br><span class="line">			of_node_put(np);</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		desc-&gt;irq_init_cb = match-&gt;data;</span><br><span class="line">		desc-&gt;dev = of_node_get(np);</span><br><span class="line">		desc-&gt;interrupt_parent = of_irq_find_parent(np);</span><br><span class="line">		<span class="keyword">if</span> (desc-&gt;interrupt_parent == np)</span><br><span class="line">			desc-&gt;interrupt_parent = <span class="literal">NULL</span>;</span><br><span class="line">		list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_desc_list);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	.......</span><br></pre></td></tr></table></figure>

<ul>
<li>8～9行：初始化管理中断控制器的两个链表，其中intc_desc_list用于连接struct of_intc_desc实例，每一个实例记录着一个中断控制器的信息，intc_parent_list用于连接已初始化的中断控制器对象「struct of_intc_desc实例」，那为什么这个链表的名字要包含parent，我估计原因是从上到下优先初始化父中断控制器。</li>
<li>11行：遍历设备树的每一个节点，并通过与matchs表比对获得匹配的节点和对应的struct of_device_id实例（也叫匹配对象）</li>
<li>12～14行：使用of_property_read_bool()在匹配的节点内搜寻给定属性，of_device_is_available()判断匹配的节点是否可用。如果未发现“interrupt-controller”属性或节点不可用，则跳过当前匹配的节点并继续搜寻下一个节点。</li>
<li>24行：分配一个struct of_intc_desc实例，用于保存中断控制器的初始化信息</li>
<li>30行：将匹配对象「struct of_device_id实例」的data成员用作回调函数，用于初始化匹配节点所描述的中断控制器。对于ARM64内核，若在设备树中创建了interrupt-controller节点，则在搜寻匹配后回调函数通常会设定为gic_of_init()。不管怎么样，后面的代码定会调用执行设定的回调函数。</li>
<li>31行：到目前为止，已经通过遍历设备树发现了匹配的GIC节点，因此让desc-&gt;dev指向这个中断控制器节点。</li>
<li>32～34行：行使desc-&gt;interrupt_parent指向当前节点的父节点，若指向的父节点与当前节点相同，则意味着当前节点没有父节点，因此重新设置desc-&gt;interrupt_parent为NULL。</li>
<li>35行：将一个中断控制器对象「struct of_intc_desc实例」添加到intc_desc_list链表的末尾。至此就完成了在intc_desc_list链表注册入中断控制器对象，接下来看看如何处理注册的对象。</li>
</ul>
<p><strong>drivers&#x2F;of&#x2F;irq.c的of_irq_init()[2&#x2F;2]</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (!list_empty(&amp;intc_desc_list)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Process all controllers with the current &#x27;parent&#x27;.</span></span><br><span class="line"><span class="comment">		 * First pass will be looking for NULL as the parent.</span></span><br><span class="line"><span class="comment">		 * The assumption is that NULL parent means a root controller.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (desc-&gt;interrupt_parent != parent)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">			of_node_set_flag(desc-&gt;dev, OF_POPULATED);</span><br><span class="line"></span><br><span class="line">			pr_debug(<span class="string">&quot;of_irq_init: init %pOF (%p), parent %p\n&quot;</span>,</span><br><span class="line">				 desc-&gt;dev,</span><br><span class="line">				 desc-&gt;dev, desc-&gt;interrupt_parent);</span><br><span class="line">			ret = desc-&gt;irq_init_cb(desc-&gt;dev,</span><br><span class="line">						desc-&gt;interrupt_parent);</span><br><span class="line">			<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">				of_node_clear_flag(desc-&gt;dev, OF_POPULATED);</span><br><span class="line">				kfree(desc);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * This one is now set up; add it to the parent list so</span></span><br><span class="line"><span class="comment">			 * its children can get processed in a subsequent pass.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_parent_list);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Get the next pending parent that might have children */</span></span><br><span class="line">		desc = list_first_entry_or_null(&amp;intc_parent_list,</span><br><span class="line">						typeof(*desc), <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;of_irq_init: children remain, but no parents\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">		parent = desc-&gt;dev;</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(desc, temp_desc, &amp;intc_parent_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line">err:</span><br><span class="line">	list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">		of_node_put(desc-&gt;dev);</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3行：检查intc_desc_list链表，直到所有的中断控制器对象都处理完才退出循环。被处理的对象将从链表中移除，若检查到链表为空，意味着所有注册的对象已经出来完。</li>
<li>9行：从intc_desc_list链表头开始遍历每个对象。除了遍历链表，该宏会提前保存指向下一个对象的指针以防数据结构的破坏，也就是说即使在遍历时删除了当前处理对象，也能安全地继续进行遍历。</li>
<li>12～13行：检查判断当前节点的父节点，如果它是父节点「parent」的孩子，将调用回调函数初始化对应的中断控制器，否则继续检查下一个节点。在第一轮外循环「while层循环」，parent为NULL，所以首先搜寻初始化的是根中断控制器。在第二轮外循环，parent变成上一轮发现的中断控制器，所以会搜寻初始化它的孩子。</li>
<li>15～22行：在执行初始化回调函数前将从intc_desc_list链表移除中断控制器对象「struct of_intc_desc实例」。对于ARM64内核，将执行的初始化回调函数是gic_of_init()，它既为__smp_cross_call设定gic_raise_softirq()回调函数，又为handle_arch_irq指定gic_handle_irq()回调函数。但是，具体的初始化回调函数依赖于使用的体系架构和设备树配置的中断硬件。</li>
<li>23行：如果初始化执行失败，则释放当前中断控制器对象并继续处理intc_desc_list链表中的下一个对象。</li>
<li>34行：将当前已经初始化的中断控制器对象添加到intc_parent_list链表的末尾，因此后面的代码能用它指向的中断控制器节点更新父节点「parent」，从而能够继续初始化作为它孩子的中断控制器对象。</li>
<li>38～39行：如果intc_parent_list链表非空，则该函数将返回第一个已初始化的中断控制器对象。若为空，就是说不存在已初始化的父中断控制器对象，因此该函数返回NULL，意味着中断子系统初始化出现致命错误。</li>
<li>44～45行：从intc_parent_list链表删除这个中断控制器对象，然后用它指向的节点更新父节点「parent」以便进行下一轮循环。</li>
<li>49～57行：释放intc_parent_list和intc_desc_list中所有的中断控制器对象。至此，该函数完成了中断控制器及相关中断的初始化。</li>
</ul>
]]></content>
      <categories>
        <category>interrupt management</category>
      </categories>
      <tags>
        <tag>interrupt</tag>
      </tags>
  </entry>
  <entry>
    <title>内核启动分析2「exception handling」</title>
    <url>/posts/9cf7e679/</url>
    <content><![CDATA[<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>armv8 arch</category>
      </categories>
      <tags>
        <tag>exception handling</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Qemu-4.0虚拟ARM64实验平台</title>
    <url>/posts/d9f20f58/</url>
    <content><![CDATA[<p>在无aarch64开发板的情况下，为了能够学习实验aarch64相关的代码，通过Qemu模拟器搭建aarch64运行环境，这样就能完全达到实验学习的目的，既节省了硬件成本又便于实验操作。本文记录一下环境的搭建过程和小坑，方便以后自己快速搭建调试环境。</p>
<span id="more"></span>

<h3 id="交叉编译工具"><a href="#交叉编译工具" class="headerlink" title="交叉编译工具"></a>交叉编译工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/aarch64-linux-gnu/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-linux-gnu.tar.xz</span><br><span class="line"><span class="built_in">mkdir</span> toolchains</span><br><span class="line">tar -xJf aarch64-linux-gnu/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-linux-gnu.tar.xz -C toolchains</span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改环境变量PATH，使工具方便使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>在文件末尾添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/path/to/toolchains/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-linux-gnu/bin</span><br></pre></td></tr></table></figure>
<p><strong>注意：根据实际情况，确保路径设置正确</strong></p>
</li>
<li><p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc -v</span><br></pre></td></tr></table></figure>
<p>在终端会输出aarch64-linux-gnu-gcc的配置及版本信息</p>
</li>
</ul>
<h3 id="构建QEMU"><a href="#构建QEMU" class="headerlink" title="构建QEMU"></a>构建QEMU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-4.0.0.tar.xz</span><br><span class="line">tar xvJf qemu-4.0.0.tar.xz</span><br><span class="line"><span class="built_in">cd</span> qemu-4.0.0</span><br><span class="line">./configure --target-list=x86_64-softmmu,x86_64-linux-user,arm-softmmu,arm-linux-user,aarch64-softmmu,aarch64-linux-user --enable-kvm</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="编译Kernel"><a href="#编译Kernel" class="headerlink" title="编译Kernel"></a>编译Kernel</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.27.tar.xz</span><br><span class="line"><span class="built_in">mkdir</span> build </span><br><span class="line">tar xJf linux-4.19.27.tar.xz </span><br><span class="line"><span class="built_in">cd</span> linux-4.19.27</span><br><span class="line">make ARCH=arm64 defconfig O=../build/ CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要调整配置选项，则使用menuconfig</span></span><br><span class="line">make ARCH=arm64 menuconfig O=../build/ CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line"></span><br><span class="line">make ARCH=arm64 Image -j8 O=../build/ CROSS_COMPILE=aarch64-linux-gnu-</span><br></pre></td></tr></table></figure>

<h3 id="模拟运行"><a href="#模拟运行" class="headerlink" title="模拟运行"></a>模拟运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -kernel build/arch/arm64/boot/Image -append <span class="string">&quot;console=ttyAMA0&quot;</span> -m 2048M -smp 4  -M virt -cpu cortex-a57 -nographic</span><br></pre></td></tr></table></figure>
<ul>
<li>-m 指定内存大小</li>
<li>-M 指定虚拟机器「machine」的类型</li>
<li>-cpu 指定虚拟CPU的型号</li>
<li>-smp 指定对称多处理的核心数</li>
<li>-append 指定内核启动时使用的命令行参数「cmdline」</li>
</ul>
<p><img data-src="/images/17/output.jpeg" alt="output"></p>
<center>图1 无根文件系统的情况下模拟运行的输出</center>

<p>由于缺少根文件系统，虚拟aarch64平台还未能正常启动。<br>按Ctrl+A+X组合键退出qemu模拟器<br>按Ctrl+A+C组合键进入qemu-monitor，输入help可以查看操作命令</p>
<h3 id="定制rootfs"><a href="#定制rootfs" class="headerlink" title="定制rootfs"></a>定制rootfs</h3><h4 id="ubuntu-base-18-04-1"><a href="#ubuntu-base-18-04-1" class="headerlink" title="ubuntu-base-18.04.1"></a>ubuntu-base-18.04.1</h4><ul>
<li><p>安装Qemu用户模拟器（静态编译版）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu-user-static binfmt-support</span><br></pre></td></tr></table></figure>
</li>
<li><p>检验</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update-binfmts --display</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/17/update-binfmt.jpeg" alt="update-binfmts"></p>
<center>图2 运行update-binfmts的输出</center></li>
</ul>
<p><strong>制作步骤</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://cdimage.ubuntu.com/ubuntu-base/releases/18.04.2/release/ubuntu-base-18.04.2-base-arm64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> rootfs</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=ubuntu-18.04-rootfs_ext4.img bs=1M count=1024 oflag=direct</span><br><span class="line">mkfs.ext4 ubuntu-18.04-rootfs_ext4.img</span><br><span class="line">sudo mount -t ext4 ubuntu-18.04-rootfs_ext4.img rootfs/</span><br><span class="line">sudo tar -xzf ubuntu-base-18.04.1-base-arm64.tar.gz -C rootfs/</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">cp</span> /usr/bin/qemu-aarch64-static rootfs/usr/bin/</span><br><span class="line">sudo <span class="built_in">cp</span> /etc/resolv.conf rootfs/etc/resolv.conf</span><br><span class="line">sudo mount -t proc /proc rootfs/proc</span><br><span class="line">sudo mount -t sysfs /sys rootfs/sys</span><br><span class="line">sudo mount -o <span class="built_in">bind</span> /dev rootfs/dev</span><br><span class="line">sudo mount -o <span class="built_in">bind</span> /dev/pts rootfs/dev/pts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装内核模块（可选）</span></span><br><span class="line"><span class="built_in">cd</span> linux-4.19.27</span><br><span class="line">make ARCH=arm64 modules -j8 O=../build/ CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="line">sudo make ARCH=arm64 modules_install O=../build/ CROSS_COMPILE=aarch64-linux-gnu- INSTALL_MOD_PATH=/path/to/rootfs</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">chroot</span> rootfs</span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install sudo vim bash-completion -y</span><br><span class="line">apt-get install net-tools ethtool ifupdown network-manager iputils-ping -y</span><br><span class="line">apt-get install rsyslog resolvconf udev -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果上面软件包没有安装，但至少要安装下面的包</span></span><br><span class="line">apt-get install systemd -y</span><br><span class="line"></span><br><span class="line">adduser arm64</span><br><span class="line">adduser arm64 sudo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;kernel-4_19&quot;</span> &gt;/etc/hostname</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;127.0.0.1 localhost&quot;</span> &gt;/etc/hosts</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;127.0.0.1 kernel-4_19&quot;</span>&gt;&gt;/etc/hosts</span><br><span class="line">dpkg-reconfigure resolvconf</span><br><span class="line">dpkg-reconfigure tzdata</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">sudo umount rootfs/proc</span><br><span class="line">sudo umount rootfs/sys</span><br><span class="line">sudo umount rootfs/dev/pts</span><br><span class="line">sudo umount rootfs/dev</span><br><span class="line">sudo umount rootfs</span><br></pre></td></tr></table></figure>

<p><strong>模拟运行验证</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -machine virt,gic_version=3 -machine virtualization=<span class="literal">true</span> -cpu cortex-a57 -machine <span class="built_in">type</span>=virt -nographic -smp 4 -m 4096 -kernel build/arch/arm64/boot/Image -append <span class="string">&quot;console=ttyAMA0 root=/dev/vda rw&quot;</span> -drive <span class="keyword">if</span>=none,file=ubuntu-18.04.1-rootfs_ext4.img,<span class="built_in">id</span>=hd0,format=raw -device virtio-blk-device,drive=hd0 -netdev tap,<span class="built_in">id</span>=net0,ifname=tap0,script=no,downscript=no -device virtio-net-device,netdev=net0,mac=52:55:00:d1:55:01</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/17/ubuntu-rootfs.jpeg" alt="ubuntu-rootfs.jpeg"></p>
<center>图3 使用ubuntu-rootfs模拟运行的输出</center>

<p><strong>问题</strong><br>在使用ubuntu-base启动虚拟aarch64平台时，等待dev-ttyAMA0.device超时而卡住，从而导致无法登录进入bash</p>
<p><img data-src="/images/17/hangdown.jpeg" alt="hang up on device-ttyAMA0 "></p>
<center>图4 在使用ubuntu-rootfs模拟运行时挂机问题</center>

<p><strong>解决方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mount ubuntu-18.04.1-rootfs_ext4.img rootfs/</span><br><span class="line">sudo chroot rootfs/</span><br><span class="line">cp lib/systemd/system/serial-getty\@.service lib/systemd/system/serial-getty\@ttyAMA0.service</span><br><span class="line">systemctl enable serial-getty\@ttyAMA0.service</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p><strong>修改内容</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim rootfs/lib/systemd/system/serial-getty@ttyAMA0.service </span><br></pre></td></tr></table></figure>

<p><img data-src="/images/17/modify.jpeg" alt="modify "></p>
<center>图5 修改的内容</center>

<p>将<code>BindsTo</code>和<code>After</code>开头的行注释掉<br>参考地址：<a href="http://0pointer.de/blog/projects/serial-console.html">systemd for Administrators, Part XVI</a> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo umount rootfs</span><br></pre></td></tr></table></figure>
<p>最后卸载挂载，完成根文件系统的制作</p>
<h4 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget  https://busybox.net/downloads/busybox-1.30.0.tar.bz2</span><br><span class="line">tar -xjf busybox-1.30.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.30.0</span><br><span class="line">make defconfig</span><br><span class="line">make menuconfig</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/17/menuconfig.jpeg" alt="menuconfig.jpeg"></p>
<center>图6 执行make menuconfig后修改的配置选项</center>

<p><strong>制作步骤</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=busybox-1.30.0-rootfs_ext4.img bs=1M count=100 oflag=direct</span><br><span class="line">mkfs.ext4 busybox-1.30.0-rootfs_ext4.img</span><br><span class="line"><span class="built_in">mkdir</span> rootfs</span><br><span class="line">sudo mount busybox-1.30.0-rootfs_ext4.img rootfs/</span><br><span class="line">sudo <span class="built_in">cp</span> -raf busybox-1.30.0/_install/* rootfs/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> rootfs</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p proc sys tmp root var mnt dev</span><br><span class="line">sudo <span class="built_in">mknod</span> dev/tty1 c 4 1</span><br><span class="line">sudo <span class="built_in">mknod</span> dev/tty2 c 4 2</span><br><span class="line">sudo <span class="built_in">mknod</span> dev/tty3 c 4 3</span><br><span class="line">sudo <span class="built_in">mknod</span> dev/tty4 c 4 4</span><br><span class="line">sudo <span class="built_in">mknod</span> dev/console c 5 1</span><br><span class="line">sudo <span class="built_in">mknod</span> dev/null c 1 3</span><br><span class="line">sudo <span class="built_in">cp</span> -r ../busybox-1.30.0/examples/bootfloppy/etc/ .</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">sudo umount rootfs</span><br></pre></td></tr></table></figure>
<p><strong>模拟运行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -kernel build/arch/arm64/boot/Image -append <span class="string">&quot;console=ttyAMA0 root=/dev/vda init=/linuxrc rw&quot;</span> -m 2048M -smp 4  -M virt -cpu cortex-a57 -nographic -hda busybox-1.30.0-rootfs_ext4.img</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/17/busybox-output.jpeg" alt="busybox-output.jpeg"></p>
<center>图7 使用busybox-rootfs模拟运行的输出</center>

<p>由于未作任何系统配置，比如&#x2F;etc&#x2F;passwd、&#x2F;etc&#x2F;group、&#x2F;etc&#x2F;shadow、&#x2F;etc&#x2F;hostname等文件，所以系统的操作和易用性还有待改进。</p>
<p><strong>制作initramfs</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> rootfs</span><br><span class="line">find . -print0 | cpio --null -ov --format=newc  | gzip -9  &gt; ../initramfs.cpio.gz</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="built_in">cd</span> build	<span class="comment">#因为gen_init_cpio在build/usr/目录</span></span><br><span class="line">sh linux-4.19.27/usr/gen_initramfs_list.sh -o /path/to/initramfs.cpio.gz /path/to/rootfs/</span><br></pre></td></tr></table></figure>
<p><strong>运行实验</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -kernel build/arch/arm64/boot/Image -initrd initramfs.cpio.gz -append <span class="string">&quot;console=ttyAMA0 rdinit=/linuxrc&quot;</span> -M virt -cpu cortex-a53 -nographic -m 2048M</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/17/initramfs.jpeg" alt="initramfs.jpeg"></p>
<center>图8 使用initramfs.cpio.gz模拟运行的输出</center>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>aarch64</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Exynos4412 SoC的启动分析</title>
    <url>/posts/e5da93df/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;通常所谓的U-Boot升级不过是在芯片原厂提供的BSP基础上增添部分外设适配代码，尽管这样做法能减少移植的难度，但芯片原厂提供的U-Boot版本一般较陈旧，极可能未实现新功能和新需求，比如设备树。通常，启动加载程序的移植是嵌入式Linux系统移植中首要面临的挑战。由于移植过程常涉及源代码的分析和修改，甚至添加新代码，因此需要在移植过程中逐渐提高三种基本能力：阅读芯片手册的能力、阅读规范文档的能力及阅读源代码的能力。</p>
<span id="more"></span>

<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul>
<li><strong>Host OS:</strong> ubuntu-16.04-desktop</li>
<li><strong>Target Development Board:</strong> Single Board Computer「SBC」 based on Exynos4412 SoC<ul>
<li>9tripod X4412「深圳九鼎创展有限公司」</li>
<li>TOPEET iTOP4412「讯为」</li>
</ul>
</li>
<li><strong>Cross Compiler Toolchain:</strong> arm-linux-gnueabihf-<ul>
<li>gcc version 6.4.1 20171012 (Linaro GCC 6.4-2017.11)</li>
</ul>
</li>
<li><strong>u-boot:</strong> u-boot-2019.07</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&ensp;&ensp;&ensp;&ensp;在移植之前，先从官方地址下载特定的U-Boot源代码，如本文使用的u-boot-2019.07。深入理解芯片的启动过程、地址空间映射「memory map」和映像布局对移植来说是至关重要的。本文重点分析了Exynos4412 SoC的启动，为后续的移植做好铺垫。Exynos4412 SoC支持以下启动设备：</p>
<ul>
<li>NAND flash</li>
<li>SD&#x2F;MMC</li>
<li>eMMC</li>
<li>USB</li>
</ul>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>&ensp;&ensp;&ensp;&ensp;Exynos4412 芯片内部包含一个64KiB ROM和一个256KiB SRAM，并且在ROM中固化了一份bootrom程序，也被称为iROM。内部SRAM用来存储iROM执行时的临时变量、数据及后续加载的fwbl.bin和u-boot-spl.bin代码。Exynos4412芯片的启动过程主要包含BL1、BL2和Kernel三个阶段，其中映像文件的加载执行顺序如图1所示。</p>
<p><img data-src="/images/12/exynos_boot_order.svg" alt="exynos_boot_order.svg"></p>
<center>图1 映像加载执行的顺序</center>

<ol>
<li>iROM被固化在内部ROM中，其主要完成功能包括：关闭看门狗、禁止中断及关闭MMU和数据缓存、打开指令缓存、刷新TLB和清除L2缓存。除此之外，使其他CPU核心进入idle模式，只保留CPU0继续执行后面的代码。接着获取reset状态、设置系统时钟分频系数和PLLs。最后根据读到的OM引脚配置来决定启动媒介设备「boot media device」，并从此启动设备将固件fwbl.bin加载到内部SRAM并跳转执行。</li>
<li>固件fwbl.bin初始化IRQ和SVC模式的栈位置，若是从LPA「low power 」状态唤醒，将直接跳转执行u-boot-spl.bin，否则从启动媒介设备中加载u-boot-spl.bin至内部SRAM中。接着判断是不是安全启动，若是就对u-boot-spl.bin映像进行签名校验，若不是就只对u-boot-spl.bin映像进行CRC校验，验证之后跳转执行u-boot-spl.bin代码，**更详细的过程参考[1]**。</li>
<li>u-boot-spl.bin也要初始化IRQ和SVC模式的栈位置，并且关闭MMU和D-Cache，不过其主要功能是配置系统时钟（clock）和初始化动态内存控制器（dynamic random-access memory controller，DRAMC）。如果需要早期的串口调试功能，那么也是由它实现。若是从LPA或睡眠状态唤醒，将直接执行内存中的u-boot.bin映像，否则从启动设备中加载u-boot.bin映像至内存中并直接跳转执行。由于不同开发板针对不同需求而采用不同的DDR SDRAM芯片，所以芯片的系统时钟和动态内存控制器的配置也要依据开发板或单板的不同做适当的调整，这也正是单独分离出这样一个映像文件的原因。</li>
<li>u-boot.bin设置MMC、UART、USB、LCD、Network等外设实现各种高级的启动引导功能，比如TFTP升级、启动显示等，然后进入命令菜单等待用户输入命令或执行bootcmd环境变量指定的命令实现自动加载Linux kernel及设备树文件到内存，之后移交控制权给kernel。</li>
<li>zImage、dtb等文件完成Linux操作系统的启动和设置，为应用程序提供一个执行环境。内核启动流程超出本文的讨论范围，故不做深入探讨。</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;综上所述，启动引导过程「BoardLoader」分为两个阶段：BL1和BL2，在启动第一阶段涉及fwbl.bin和u-boot-spl.bin两个映像文件，其中fwbl.bin是由三星半导体提供的，而且没有源代码，只能通过文档大致了解它完成了哪些事情。与之相反，u-boot-spl.bin是通过开源U-Boot工程生成的，我们能够掌控代码的执行内容，便于定制化。在启动第二阶段只涉及u-boot.bin映像文件，也是使用U-Boot工程创建的，根据需求能够灵活地修改扩展。</p>
<h4 id="为什么在启动的第一阶段（BL1）需要单独分离出fwbl-bin和u-boot-spl-bin两个文件？"><a href="#为什么在启动的第一阶段（BL1）需要单独分离出fwbl-bin和u-boot-spl-bin两个文件？" class="headerlink" title="为什么在启动的第一阶段（BL1）需要单独分离出fwbl.bin和u-boot-spl.bin两个文件？"></a>为什么在启动的第一阶段（BL1）需要单独分离出fwbl.bin和u-boot-spl.bin两个文件？</h4><p>&ensp;&ensp;&ensp;&ensp;这样设计的目的其实就是为了使芯片相关的配置过程与平台相关的配置过程完全解耦。无论芯片被使用在什么平台上，芯片配置固件都要具有将平台配置代码加载到内部SRAM并跳转执行的功能，fwbl.bin都由芯片制造商实现，但集成制造商通常都要求能够简单方便地修改平台配置以致于定制出差异化的产品，比如系统时钟的修改、内存芯片的改变等，这些设置都需要能在u-boot-spl.bin中实现。这样做的好处就使集成制造商能够根据具体需求灵活地使用自己定制的启动映像，从而不需要每次硬件选型变更后寻找芯片制造商的协助与授权。</p>
<h3 id="地址空间映射"><a href="#地址空间映射" class="headerlink" title="地址空间映射"></a>地址空间映射</h3><p><img data-src="/images/12/memory_map.jpg" alt="memory_map.jpg"></p>
<center>图2 Exynos4412 SoC的地址空间映射</center>
&ensp;&ensp;&ensp;&ensp;如图2所示，可看出芯片将物理地址空间划分成多个内存区间「region」，分别有不同的用途。比如该芯片最大只能支持3GiB的内存。

<p><img data-src="/images/12/exynos_internal_RAM.svg" alt="exynos_internal_RAM.svg"></p>
<center>图3 关于内部SRAM的内存映射</center>

<p>&ensp;&ensp;&ensp;&ensp;由图 3所示，可看出iROM、fwbl.bin与u-boot-spl.bin各自占用的地址空间。内部SRAM的地址空间是从0x02020000 开始到0x02060000结束。由于内部ROM是只读存储器，因此需要将 0x02020000 ~ 0x02021400的地址空间保留给iROM程序所使用，预留大小为5KiB，用于存放iROM的全局变量（ZI&#x2F;ZW即全局未初始化变量与全局已初始化变量）、局部变量（stack）等。接下来从0x02021400处开始到0x02025000结束属于fwbl.bin所占用的地址空间，由此可认为fwbl.bin的第一条指令在执行期间是存放在0x02021400地址处，这段地址空间的大小为15KiB。紧接着从0x02025000开始到0x02029000结束的这段空间属于u-boot-spl.bin所占用的地址空间，其大小为16KiB，因此可认为在运行过程中u-boot-spl.bin的第一条指令将存放在0x02025000地址处。<br>&ensp;&ensp;&ensp;&ensp;牵涉位置无关代码（Position-independent code，缩写PIC）的问题是移植U-Boot的难点，即运行地址与加载地址的区别。u-boot-spl.bin的运行地址在编译时是一个很重要的信息，决定得到的u-boot-spl.bin代码能否在芯片上正确运行。运行地址也叫链接地址，是程序指令定位所用的绝对地址，是在编译链接时必须指定的地址。加载地址指的是程序代码放置的位置，大多数情况下运行地址等于加载地址。通常用于生成u-boot-spl.bin的源代码包含非PIC的代码，并且在编译时指定的运行地址与存放映像用的加载地址不一致，当执行到u-boot-spl.bin的位置有关代码时其实际存放地址与依据运行地址计算的地址不吻合，此时u-boot-spl.bin代码将不能顺利执行下去。实际上，u-boot-spl.bin是由fwbl.bin加载到内部SRAM的0x02025000地址处，又由于fwbl.bin是芯片原厂提供的不开源的二进制程序，暂时无法修改fwbl.bin程序的执行行为，因此在编译生成u-boot-spl.bin时必须正确指定u-boot-spl.bin的链接地址为0x02025000，只有这样含有非PIC的u-boot-spl.bin代码才能顺利运行。<br>&ensp;&ensp;&ensp;&ensp;在配置编译生成u-boot映像时，若打开了SPL相关配置选项，则在编译完成后会在映像构建目录build下创建spl子目录，并在此子目录下创建与SPL相关的各种格式的映像文件和符号表，如表1所示。</p>
<div align="center">表1 编译生成的SPL相关文件
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">映像名称</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">u-boot-spl.map<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">映像符号表<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">u-boot-spl<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">ELF格式映像<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">u-boot-spl.lds<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">ld链接脚本<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">x4412-spl.bin<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left">特定芯片识别的二进制格式映像<br></td></tr></table></div>

<p>&ensp;&ensp;&ensp;&ensp;按理论说，得到的ELF格式u-boot-spl映像也可以被加载执行，但由于fwbl.bin代码的行为限制，fwbl.bin不能加载执行其他格式的映像，所以一般常用<board_name>-spl.bin，其中<board_name>使用开发板的特定名称代替，例如用x4412代替后即是x4412-spl.bin，<strong>注意：启动第一阶段涉及的u-boot-spl.bin可以指的是这里的x4412-spl.bin</strong>。</p>
<h3 id="映像布局"><a href="#映像布局" class="headerlink" title="映像布局"></a>映像布局</h3><p>&ensp;&ensp;&ensp;&ensp;在运行时，启动加载程序确切知道各种映像在存储设备SD或eMMC中的放置位置才能正确地从启动设备中获取启动映像并执行，并顺利将控制权转交给Linux内核。</p>
<p><img data-src="/images/12/exynos_sd_layout.svg" alt="exynos_sd_layout.svg"></p>
<center>图4 在SD卡上的映像布局</center>

<p>&ensp;&ensp;&ensp;&ensp;SD卡的扇区大小为512B，编号0扇区为保留扇区，用来存放分区表的数据（MBR）。接下来的15KiB的空间存放fwbl.bin，比如X4412的BSP所提供fwbl.bin是15KiB，但iTOP4412的BSP所提供的fwbl.bin为8KiB。fwbl.bin后面要紧跟着存放u-boot-spl.bin（或x4412-spl.bin），两者之间不能存在空隙，其实u-boot-spl.bin的实际大小只有14KiB，因此u-boot-spl.bin与u-boot.bin之间存在2KiB的间隙，建议将此存储空间置零，后面几个映像文件可以根据实际情况自己安排适当调整位置。如图4所示，显示了X4412开发板所用的映像布局。这些映像文件是直接使用dd命令烧录至裸金属的物理存储空间，并不是存放在SD卡上的基于文件系统的逻辑分区内，但后面的kernel和dtb文件任然需要放入文件系统vfat32格式化的分区内，根文件系统映像存放入ext4格式化的分区内。</p>
<p><img data-src="/images/12/exynos_emmc_layout.svg" alt="exynos_emmc_layout.svg"></p>
<center>图5 在eMMC上的映像布局</center>

<p>&ensp;&ensp;&ensp;&ensp;eMMC存储设备一般拥有多个独立的物理存储空间，每个硬件分区都是独立编址的。通常情况下，Boot Area Patitions存放启动加载程序，User Data Area存储内核映像、设备树和根文件系统等数据。从eMMC启动时，X4412开发板采用的映像布局如图5所示。<strong>更详细的关于eMMC的工作原理及分区，请参考[6]和[7]。</strong><br>&ensp;&ensp;&ensp;&ensp;不管选择从哪个启动设备启动，同样的映像只是在不同启动设备上的存放位置有变化。若设置启动设备为SD卡，则映像需要按照SD卡的存放布局放置。若eMMC被设置为启动设备，则映像就按照eMMC的空间布局存放。尽管图片中显示的内容都是与X4412相关的，但是原理和思想都是相似的，同样适用于iTOP4412开发板。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="/downloads/Android_Exynos4412_iROM_Secure_Booting_Guide_Ver.1.00.00.pdf">Exynos4212 iROM Booting Guide</a></li>
<li><a href="/downloads/SEC_Exynos4412_Users_Manual_Ver.1.00.00.pdf">Exynos 4412 RISC Microprocessor User’s Manual</a></li>
<li><a href="http://www.techbulo.com/1335.html">Exynos 4412的启动过程分析</a></li>
<li><a href="/downloads/ARM_DEN0028B_SMC_Calling_Convention.pdf">SMC CALLING CONVENTION System Software on ARM® Platforms</a></li>
<li><a href="http://www.cnblogs.com/pengdonglin137/p/5080309.html">基于tiny4412的u-boot移植（一）</a></li>
<li><a href="https://www.jedec.org/sites/default/files/docs/JESD84-A44.pdf">eMMC (Embedded MMC) Standard MMCA 4.4 (JESD84-A44)(March 2009)</a></li>
<li><a href="https://linux.codingbelief.com/zh/storage/flash_memory/emmc/">eMMC详解</a></li>
</ol>
]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>uboot</tag>
        <tag>arm-linux-gnueabihf-gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>内核启动分析3「device tree」</title>
    <url>/posts/48f0eed/</url>
    <content><![CDATA[<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>armv8 arch</category>
      </categories>
      <tags>
        <tag>device tree</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Qemu hobot-sigi-virt平台的bringup</title>
    <url>/posts/f7f39ab5/</url>
    <content><![CDATA[<p>在新增Qemu芯片平台之后，我们就可以基于这个平台进行最小系统的移植适配，从而加快系统软件的开发节奏。随着Qemu里面模拟的外设越来越多，我们BSP里面的很多驱动都可以先在这个芯片平台上完成function逻辑的验证，等验证到一定程度，我们再迁移到FPAG上集中验证一遍，从而大大节省验证的时间代价和成本，因为Qemu里面调试极其方便。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Qemu:</strong> v7.2.0</li>
<li><strong>U-Boot:</strong> v2022.04</li>
<li><strong>ATF:</strong> lts-v2.8.1</li>
<li><strong>Linux Kernel:</strong> linux-6.1.12</li>
<li><strong>aarch64-none-linux-gnu-gcc:</strong> 10.3.1 20210621</li>
</ul>
<hr>
<h3 id="启动介绍"><a href="#启动介绍" class="headerlink" title="启动介绍"></a>启动介绍</h3><p>在运行起来之前，我们先明确最小系统涉及的组件以及它们的启动顺序</p>
<ul>
<li>ATF：提供EL3 runtime service，具有整个硬件系统的全部权限</li>
<li>U-Boot：加载和启动不同OS的镜像</li>
<li>Xen: Hypervisor OS，支持多个虚拟机的运行</li>
<li>Kernel：Linux kernel OS，常用的OS</li>
<li>initramfs：最小的文件系统，用作临时跳转</li>
<li>Ubuntu Rootfs：根文件系统，存放在存储介质上，里面包含很多应用、库和工具</li>
</ul>
<h4 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h4><p><img data-src="/images/27/bootflow1.svg" alt="bootflow1"></p>
<center>图1 U-Boot从不同媒介的启动</center>

<br>

<p><img data-src="/images/27/bootflow2.svg" alt="bootflow2"></p>
<center>图2 Linux Kernel的启动</center>

<br>

<p><img data-src="/images/27/bootflow3.svg" alt="bootflow2"></p>
<center>图3 Xen的启动</center>

<br>

<p>该平台支持上面三种启动方式，每个人在开发早期根据自己的喜好和开发特点来选择一个启动方法，来加快软件的开发验证效率。</p>
<h3 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h3><h4 id="U-Boot构建"><a href="#U-Boot构建" class="headerlink" title="U-Boot构建"></a>U-Boot构建</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hobot-uboot https://github.com/chasinglulu/u-boot.git</span><br><span class="line"><span class="built_in">cd</span> u-boot</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- hobot-sigi-virt_defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- -j4</span><br></pre></td></tr></table></figure>

<h4 id="ATF构建"><a href="#ATF构建" class="headerlink" title="ATF构建"></a>ATF构建</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b sigi-atf https://github.com/chasinglulu/arm-trusted-firmware.git</span><br><span class="line"><span class="built_in">cd</span> arm-trusted-firmware</span><br><span class="line">make PLAT=sigi CROSS_COMPILE=aarch64-none-linux-gnu-</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">make PLAT=sigi CROSS_COMPILE=aarch64-none-linux-gnu- DEBUG=1 <span class="comment">#debug</span></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">make PLAT=sigi CROSS_COMPILE=aarch64-none-linux-gnu- DEBUG=1 LOG_LEVEL=50 <span class="comment">#verbose</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<code>arm-trusted-firmware/build/sigi/</code>目录下构造出<code>bl31.bin</code>镜像。</p>
<h4 id="Kernel构建"><a href="#Kernel构建" class="headerlink" title="Kernel构建"></a>Kernel构建</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b linux-v6.1-rt https://github.com/chasinglulu/linux.git</span><br><span class="line"><span class="built_in">cd</span> linux</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- hobot_sigi_tiny_defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- -j64</span><br></pre></td></tr></table></figure>

<h4 id="Initramfs构建"><a href="#Initramfs构建" class="headerlink" title="Initramfs构建"></a>Initramfs构建</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/chasinglulu/buildroot.git</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">make hobot_qemu_defconfig</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>在<code>buildroot/output/images</code>目录下产出<code>rootfs.cpio.lz4</code>镜像。</p>
<h3 id="启动验证"><a href="#启动验证" class="headerlink" title="启动验证"></a>启动验证</h3><h4 id="仅启动U-Boot"><a href="#仅启动U-Boot" class="headerlink" title="仅启动U-Boot"></a>仅启动U-Boot</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt -m 4G -display none -device loader,addr=0x3000200000,file=/path/to/u-boot/u-boot.bin,cpu-num=0 -serial stdio</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/27/uboot.svg" alt="uboot"></p>
<h4 id="启动U-Boot-Kernel"><a href="#启动U-Boot-Kernel" class="headerlink" title="启动U-Boot+Kernel"></a>启动U-Boot+Kernel</h4><p>将<code>Image</code>、<code>hobot-sigi-virt.dtb</code>和<code>rootfs.cpio.lz4</code>三个镜像先复制到执行qemu-system-aarch64的当前目录<code>$(PWD)</code>下，U-Boot将使用semihosting方式让qemu自动地将这三个镜像加载到hobot-sigi-virt平台模拟的内存中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt -m 4G -display none -device loader,addr=0x3000200000,file=/path/to/u-boot/u-boot.bin,cpu-num=0 -serial stdio -semihosting</span><br></pre></td></tr></table></figure>

<p>或者直接从eMMC上加载Kernel等镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt -m 4G -display none -device loader,addr=0x3000200000,file=/home/charleye/24-Xen/u-boot/u-boot.bin,cpu-num=0 -serial stdio -drive file=/path/to/emmc-aarch64.img,format=raw,<span class="keyword">if</span>=emmc</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/27/uboot_kernel.gif" alt="kernel"><br>启动日志附件：<a href="/images/27/uboot_kernel.txt">U-Boot -&gt; Kernel Booting</a></p>
<h4 id="启动ATF-U-Boot"><a href="#启动ATF-U-Boot" class="headerlink" title="启动ATF+U-Boot"></a>启动ATF+U-Boot</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt,virt=on,secure=on -m 4G -display none -device loader,addr=0x04001000,file=/path/to/arm-trusted-firmware/build/sigi/release/bl31.bin,cpu-num=0 -device loader,addr=0x3004000000,file=/path/to/u-boot/u-boot-dtb.bin -serial stdio</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/27/atf.svg" alt="atf"></p>
<h4 id="启动ATF-U-Boot-Kernel"><a href="#启动ATF-U-Boot-Kernel" class="headerlink" title="启动ATF+U-Boot+Kernel"></a>启动ATF+U-Boot+Kernel</h4><p>将<code>Image</code>、<code>hobot-sigi-virt.dtb</code>和<code>rootfs.cpio.lz4</code>三个镜像先复制到执行qemu-system-aarch64的当前目录<code>$(PWD)</code>下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt,virt=on,secure=on -m 4G -display none -device loader,addr=0x04001000,file=/path/to/arm-trusted-firmware/build/sigi/release/bl31.bin,cpu-num=0 -device loader,addr=0x3004000000,file=/path/to/u-boot/u-boot-dtb.bin -serial stdio -semihosting</span><br></pre></td></tr></table></figure>
<p>或者直接从eMMC上加载Kernel等镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt,virt=on,secure=on,emmc=on -m 4G -display none -device loader,addr=0x04001000,file=/path/to/arm-trusted-firmware/build/sigi/release/bl31.bin,cpu-num=0 -device loader,addr=0x3004000000,file=/path/to/u-boot/u-boot-dtb.bin -serial stdio -drive file=/path/to/emmc-aarch64.img,format=raw,<span class="keyword">if</span>=emmc</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/27/atf_uboot_kernel.gif" alt="atf_kernel"></p>
<p>启动日志附件：<a href="/images/27/atf_uboot_kernel.txt">ATF-&gt;U-Boot-&gt;kernel Booting</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>u-boot</tag>
        <tag>linux</tag>
        <tag>ATF</tag>
      </tags>
  </entry>
  <entry>
    <title>在AArch64平台上静态编译链接eBPF相关的工具</title>
    <url>/posts/f21e95a0/</url>
    <content><![CDATA[<p>在嵌入式的环境下经常使用的rootfs都是高度定制的，没有与发行版相似的包管理工具（比如apt-get、yum等），因此我们不能通过一条命令就把eBPF相关的工具安装好，通常我们都要先交叉编译依赖的所有库源代码，然后在交叉编译工具的源代码，整个过程耗时又容易出错。本文说明如何在ubuntu-base-aarch64-rootfs上静态编译链接eBPF相关的工具，这样就能方便地把eBPF工具集成到高度定制的嵌入式rootfs中。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>rootfs:</strong> Ubuntu-base-18.04.5-rootfs-aarch64</li>
</ul>
<hr>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li>参考<a href="https://chasinglulu.github.io/2019/07/27/%E5%88%A9%E7%94%A8Qemu-4-0%E8%99%9A%E6%8B%9FARM64%E5%AE%9E%E9%AA%8C%E5%B9%B3%E5%8F%B0/">利用Qemu-4.0虚拟ARM64实验平台</a>的第5节【定制rootfs】</li>
<li>Rock960C SBC更换成定制好的ubuntu-base–18.04.5-rootfs-aarch64，并重启引导login</li>
</ul>
<h3 id="clang的下载与编译"><a href="#clang的下载与编译" class="headerlink" title="clang的下载与编译"></a>clang的下载与编译</h3><p>参考<a href="https://github.com/iovisor/bpftrace/blob/master/INSTALL.md#ubuntu">Building bpftrace in Ubuntu</a>的说明，通过apt-get命令安装了部分依赖库，但是安装的libclang-7-dev并没有包含libclang.a，其是静态编译链接bpftrace的重要库文件。下面命令给出了llvm和clang的静态编译命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://releases.llvm.org/8.0.0/llvm-8.0.0.src.tar.xz</span><br><span class="line">wget https://releases.llvm.org/8.0.0/cfe-8.0.0.src.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/install/llvm</span><br><span class="line">sudo apt-get install zlib1g-dev libncurses5-dev bison cmake flex make libxml2-dev libelf-dev -y</span><br><span class="line"></span><br><span class="line">tar -xJf llvm-8.0.0.src.tar.xz</span><br><span class="line">tar -xJf cfe-8.0.0.src.tar.xz</span><br><span class="line"><span class="built_in">mv</span> cfe-8.0.0.src llvm-8.0.0.src/tools/clang</span><br><span class="line"><span class="built_in">cd</span> llvm-8.0.0.src</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DBUILD_SHARED_LIBS=OFF -DLLVM_BUILD_LLVM_DYLIB=ON -DLIBCLANG_BUILD_STATIC=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/install/llvm -DCLANG_BUILD_EXAMPLES=OFF -DCLANG_INCLUDE_DOCS=OFF -DCLANG_INCLUDE_TESTS=OFF -DLLVM_APPEND_VC_REV=OFF -DLLVM_BUILD_DOCS=OFF -DLLVM_BUILD_EXAMPLES=OFF -DLLVM_BUILD_TESTS=OFF -DLLVM_BUILD_TOOLS=ON -DLLVM_ENABLE_ASSERTIONS=OFF -DLLVM_ENABLE_CXX1Y=ON -DLLVM_ENABLE_EH=ON -DLLVM_ENABLE_LIBCXX=OFF -DLLVM_ENABLE_PIC=ON -DLLVM_ENABLE_RTTI=ON -DLLVM_ENABLE_SPHINX=OFF -DLLVM_ENABLE_TERMINFO=OFF -DLLVM_INCLUDE_DOCS=OFF -DLLVM_INCLUDE_EXAMPLES=OFF -DLLVM_INCLUDE_GO_TESTS=OFF -DLLVM_INCLUDE_TESTS=OFF -DLLVM_INCLUDE_TOOLS=ON -DLLVM_INCLUDE_UTILS=OFF -DLLVM_PARALLEL_LINK_JOBS=1 -DLLVM_TARGETS_TO_BUILD=<span class="string">&quot;host;BPF&quot;</span></span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">find . -name <span class="string">&#x27;libclang.a&#x27;</span> | xargs <span class="built_in">cp</span> -t <span class="variable">$HOME</span>/install/llvm/lib/</span><br></pre></td></tr></table></figure>

<h3 id="BCC的下载与编译"><a href="#BCC的下载与编译" class="headerlink" title="BCC的下载与编译"></a>BCC的下载与编译</h3><p>BCC(BPF Compiler Collection)是一个工具包，用于构建高效的内核追踪（tracing）和操控程序，同时它还包含多个比较有用的工具和用例。BCC利用了扩展的BPF（Berkeley Packet Filters）技术，也就是eBPF，它是在Linux-3.15合并窗口期间才被首次添加到内核中的一个新功能，要想使用BCC的更多功能需要内核版本至少是Linux-4.1以上。<br>Ingo Molnár如下解释了eBPF：</p>
<blockquote>
<p>One of the more interesting features in this cycle is the ability to attach eBPF programs (user-defined, sandboxed bytecode executed by the kernel) to kprobes. This allows user-defined instrumentation on a live kernel image that can never crash, hang or interfere with the kernel negatively.</p>
</blockquote>
<p>BCC使BPF程序更容于编写，使用C语言进行内核检测（包含一个基于LLVM的C封装），同时还具有针对Python和lua两种封装。它适用于许多任务，包括性能分析和网络流量控制。由于bpftrace依赖BCC相关的库，因此我们需要先静态编译链接BCC：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/iovisor/bcc/releases/download/v0.20.0/bcc-src-with-submodule.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzf bcc-src-with-submodule.tar.gz</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/install/bcc</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> bcc</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/install/bcc -DCMAKE_USE_LIBBPF_PACKAGE=OFF -DCMAKE_PREFIX_PATH=<span class="variable">$HOME</span>/install/llvm</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="libbpf的编译"><a href="#libbpf的编译" class="headerlink" title="libbpf的编译"></a>libbpf的编译</h3><p>从bcc-v0.10.0开始，开始单独分离出一个libbpf仓库，用于提供关于bpf系统调用的封装函数，以及 bpf.h&#x2F;btf.h等uapi头文件。要注意的是，如果编译构建bcc时，没有包含libbpf的源代码，其将导致构建失败问题。然而我们下载的bcc-src-with-submodule.tar.gz已经包含了libbpf的源代码，下面给出了libbpf的编译命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> bcc/src/cc/libbpf/src</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/install/libbpf</span><br><span class="line"></span><br><span class="line">OBJDIR=build DESTDIR=<span class="variable">$HOME</span>/install/libbpf/ make install</span><br></pre></td></tr></table></figure>

<h3 id="bpftrace的下载与编译"><a href="#bpftrace的下载与编译" class="headerlink" title="bpftrace的下载与编译"></a>bpftrace的下载与编译</h3><p>bpftrace是一个高级的追踪（tracing）语言，使最近的内核（从4.x开始）中eBPF技术更容易使用。bpftrace利用LLVM作为后端解释器先将脚本编译成BPF字节码（bytecode），然后利用BCC调用Linux BPF接口完成交互，同时其还能使用Linux现存的tracing技术：内核动态追踪（kprobes）、用户动态追踪（uprobes）以及静态tracepoint。bpftrace语言的设计理念借鉴了awk和C语言，同时还参考了以前的DTrace和System Tap等追踪器（tracers）。bpftrace 是由 Alastair Robertson发起创建的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://codeload.github.com/iovisor/bpftrace/tar.gz/refs/tags/v0.12.1 -o bpftrace-0.12.1.tar.gz</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/install/bpftrace</span><br><span class="line">sudo apt-get install libltdl-dev libpthread-stubs0-dev libiberty-dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$HOME</span>/install/libpbf/usr/lib:<span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$HOME</span>/install/libpbf/usr/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> CPATH=<span class="variable">$HOME</span>/install/libpbf/usr/include:<span class="variable">$CPATH</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$HOME</span>/install/libpbf/usr/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$HOME</span>/install/llvm/lib:<span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$HOME</span>/install/llvm/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> CPATH=<span class="variable">$HOME</span>/install/llvm/include:<span class="variable">$CPATH</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$HOME</span>/install/llvm/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LIBRARY_PATH=<span class="variable">$HOME</span>/install/bcc/lib:<span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$HOME</span>/install/bcc/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> CPATH=<span class="variable">$HOME</span>/install/bcc/include:<span class="variable">$CPATH</span></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=<span class="variable">$HOME</span>/install/bcc/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"></span><br><span class="line">tar -xzf bpftrace-0.12.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> bpftrace-0.12.1</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS:BOOL=OFF -DSTATIC_LIBC=ON -DSTATIC_LINKING=1 -DCMAKE_PREFIX_PATH=<span class="variable">$HOME</span>/install/llvm -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/install/bpftrace -DKERNEL_INCLUDE_DIRS=<span class="variable">$HOME</span>/install/bcc/include/bcc/compat</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>由于bpftrace-0.12.1在Ubuntu-18.04.5下编译会报错，需要打上<a href="/downloads/0001-fixup-compile-failure.patch">0001-fixup-compile-failure.patch</a>才可以解决编译问题。</p>
<p><img data-src="/images/02/bpftrace.png" alt="bpftrace"></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>aarch64</tag>
        <tag>bpftrace</tag>
        <tag>bcc</tag>
        <tag>clang</tag>
        <tag>llvm</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Exynos4412开发板的uboot-2019.07移植</title>
    <url>/posts/96d82d1e/</url>
    <content><![CDATA[<p>Exynos4412 芯片提供的 fwbl.bin只能加载 16KiB 大小的 u-boot-spl.bin到内部 SDRAM，通常编译得到的u-boot.bin远远超过这个限制，因此使用u-boot源代码支持的SPL功能来解决该问题 。不过，u-boot-spl.bin与u-boot.bin共用了很多基础代码。CONFIG_SPL_BUILD选项控制着SPL功能的开关，若在配置文件中启用了该选项，在编译时会在<code>spl</code>子目录下构建出SPL相关的代码文件树。同时它还会把整个启动引导过程分为两个阶段，u-boot-spl.bin完成第一阶段的初始化设置，主要是初始化 SoC时钟、外部内存DDR和早期串口调试功能，最后加载第二阶段涉及的u-boot.bin到外部内存并跳转执行。</p>
<span id="more"></span>

<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul>
<li><strong>Host OS:</strong> ubuntu-18.04-desktop</li>
<li><strong>Target Development Board:</strong> Single Board Computer「SBC」 based on Exynos4412 SoC<ul>
<li>9tripod X4412「深圳九鼎创展有限公司」<ul>
<li>SCP package「封装」</li>
<li>1G DDR3</li>
<li>4G eMMC</li>
</ul>
</li>
<li>TOPEET iTOP4412「讯为」<ul>
<li>SCP package</li>
<li>1G DDR3</li>
<li>8G eMMC</li>
</ul>
</li>
</ul>
</li>
<li><strong>Cross Compiler Toolchain:</strong> arm-linux-gnueabihf-<ul>
<li>gcc version 7.2.1 20171011 (Linaro GCC 7.2-2017.11)</li>
</ul>
</li>
<li><strong>u-boot:</strong> u-boot-2019.07</li>
</ul>
<h3 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h3><p>在实际的移植过程，u-boot源代码支持众多ARM体系架构的SoC和开发板，优先选择与目标开发板相似的开发板作为参考，比如本文参考的origen开发板，它使用的SoC是Exynos4210，与目标板采用的Exynos4412同属于ARMv7架构和Samsung Exynos4系列，并且开启了SPL功能。本小节以移植u-boot-2019.07到iTOP4412开发板为例阐述说明整个移植过程。</p>
<h4 id="创建board相关的目录和配置"><a href="#创建board相关的目录和配置" class="headerlink" title="创建board相关的目录和配置"></a>创建board相关的目录和配置</h4><p>下面先创建相关的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> board/samsung/</span><br><span class="line">$ <span class="built_in">mkdir</span> -p itop4412  itop4412/tools</span><br><span class="line"><span class="built_in">cd</span> itop4412</span><br></pre></td></tr></table></figure>
<h5 id="添加初始化iTOP4412-board的代码，以及LED初始化代码用于输出早期的调试信息"><a href="#添加初始化iTOP4412-board的代码，以及LED初始化代码用于输出早期的调试信息" class="headerlink" title="添加初始化iTOP4412 board的代码，以及LED初始化代码用于输出早期的调试信息"></a>添加初始化iTOP4412 board的代码，以及LED初始化代码用于输出早期的调试信息</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/board/samsung/itop4412/itop4412.c b/board/samsung/itop4412/itop4412.c</span><br><span class="line">new file mode <span class="number">100644</span></span><br><span class="line">index <span class="number">0000000.</span><span class="number">.3</span>b93220</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/board/samsung/itop4412/itop4412.c</span><br><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span>,<span class="number">59</span> @@</span><br><span class="line">+<span class="comment">// SPDX-License-Identifier: GPL-2.0+</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/gpio.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/cpu.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/mmc.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/periph.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/pinmux.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;usb.h&gt;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPL_BUILD</span></span><br><span class="line">+u32 get_board_rev(<span class="type">void</span>)</span><br><span class="line">+&#123;</span><br><span class="line">+	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="type">int</span> <span class="title function_">exynos_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">+&#123;</span><br><span class="line">+	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="type">int</span> <span class="title function_">board_usb_init</span><span class="params">(<span class="type">int</span> index, <span class="keyword">enum</span> usb_init_type init)</span></span><br><span class="line">+&#123;</span><br><span class="line">+	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_BOARD_EARLY_INIT_F</span></span><br><span class="line">+<span class="type">int</span> <span class="title function_">exynos_early_init_f</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">+&#123;</span><br><span class="line">+	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span> <span class="comment">/* !CONFIG_SPL_BUILD */</span></span></span><br><span class="line">+<span class="type">void</span> <span class="title function_">exynos_led_set_on_early</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> led_num)</span></span><br><span class="line">+&#123;</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> GPL2CON (0x11000100)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> GPL2DAT (0x11000104)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> GPK1CON (0x11000060)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> GPK1DAT (0x11000064)</span></span><br><span class="line">+</span><br><span class="line">+        <span class="type">uint8_t</span> val;</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">/* LED2 */</span></span><br><span class="line">+        val = led_num &amp; <span class="number">0x01</span>;</span><br><span class="line">+        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">+                clrsetbits_le32(GPL2CON, <span class="number">0xf</span> &lt;&lt; <span class="number">0</span>, <span class="number">0x01</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line">+                setbits_8(GPL2DAT, <span class="number">1</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">/* LED3 */</span></span><br><span class="line">+        val = led_num &amp; <span class="number">0x02</span>;</span><br><span class="line">+        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">+                clrsetbits_le32(GPK1CON, <span class="number">0xf</span> &lt;&lt; <span class="number">4</span>, <span class="number">0x01</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line">+                setbits_8(GPK1DAT, <span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line">+        &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h5 id="添加SPL相关的工具"><a href="#添加SPL相关的工具" class="headerlink" title="添加SPL相关的工具"></a>添加SPL相关的工具</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/board/samsung/itop4412/tools/mkitop4412spl.c b/board/samsung/itop4412/tools/mkitop4412spl.c</span><br><span class="line">new file mode <span class="number">100644</span></span><br><span class="line">index <span class="number">0000000.</span><span class="number">.8</span>d61809</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/board/samsung/itop4412/tools/mkitop4412spl.c</span><br><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span>,<span class="number">100</span> @@</span><br><span class="line">+<span class="comment">// SPDX-License-Identifier: GPL-2.0+</span></span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Based on board/samsung/origen/tool/mkorigenspl.c</span></span><br><span class="line"><span class="comment">+ *</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> BUFSIZE			(14*1024)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> IMG_SIZE		(14*1024)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> FILE_PERM		(S_IRUSR | S_IWUSR | S_IRGRP \</span></span><br><span class="line"><span class="meta">+				| S_IWGRP | S_IROTH | S_IWOTH)</span></span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+* Requirement:</span></span><br><span class="line"><span class="comment">+* fwbl.bin code reads first 14K bytes from boot device.</span></span><br><span class="line"><span class="comment">+* It then calculates the checksum of 14K-4 bytes and compare with data at</span></span><br><span class="line"><span class="comment">+* 14K-4 offset.</span></span><br><span class="line"><span class="comment">+*</span></span><br><span class="line"><span class="comment">+* This function takes two filenames:</span></span><br><span class="line"><span class="comment">+* IN  &quot;u-boot-spl.bin&quot; and</span></span><br><span class="line"><span class="comment">+* OUT &quot;$(BOARD)-spl.bin as filenames.</span></span><br><span class="line"><span class="comment">+* It reads the &quot;u-boot-spl.bin&quot; in 14K buffer.</span></span><br><span class="line"><span class="comment">+* It calculates checksum of 14K-4 Bytes and stores at 14K-4 offset in buffer.</span></span><br><span class="line"><span class="comment">+* It writes the buffer to &quot;$(BOARD)-spl.bin&quot; file.</span></span><br><span class="line"><span class="comment">+*/</span></span><br><span class="line">+</span><br><span class="line">+<span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span><br><span class="line">+&#123;</span><br><span class="line">+	<span class="type">int</span> i, len;</span><br><span class="line">+	<span class="type">unsigned</span> <span class="type">char</span> buffer[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">+	<span class="type">int</span> ifd, ofd;</span><br><span class="line">+	<span class="type">unsigned</span> <span class="type">int</span> checksum = <span class="number">0</span>, count;</span><br><span class="line">+</span><br><span class="line">+	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">+		<span class="built_in">printf</span>(<span class="string">&quot; %d Wrong number of arguments\n&quot;</span>, argc);</span><br><span class="line">+		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+	&#125;</span><br><span class="line">+</span><br><span class="line">+	ifd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">+	<span class="keyword">if</span> (ifd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">+		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: Can&#x27;t open %s: %s\n&quot;</span>,</span><br><span class="line">+			argv[<span class="number">0</span>], argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">+		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+	&#125;</span><br><span class="line">+</span><br><span class="line">+	ofd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT | O_TRUNC, FILE_PERM);</span><br><span class="line">+	<span class="keyword">if</span> (ofd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">+		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: Can&#x27;t open %s: %s\n&quot;</span>,</span><br><span class="line">+			argv[<span class="number">0</span>], argv[<span class="number">2</span>], strerror(errno));</span><br><span class="line">+		<span class="keyword">if</span> (ifd)</span><br><span class="line">+			close(ifd);</span><br><span class="line">+		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+	&#125;</span><br><span class="line">+</span><br><span class="line">+	len = lseek(ifd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">+	lseek(ifd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">+</span><br><span class="line">+	count = len &lt; IMG_SIZE ? len : IMG_SIZE;</span><br><span class="line">+</span><br><span class="line">+	<span class="keyword">if</span> (read(ifd, buffer, count) != count) &#123;</span><br><span class="line">+		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: Can&#x27;t read %s: %s\n&quot;</span>,</span><br><span class="line">+			argv[<span class="number">0</span>], argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">+</span><br><span class="line">+		<span class="keyword">if</span> (ifd)</span><br><span class="line">+			close(ifd);</span><br><span class="line">+		<span class="keyword">if</span> (ofd)</span><br><span class="line">+			close(ofd);</span><br><span class="line">+</span><br><span class="line">+		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+	&#125;</span><br><span class="line">+</span><br><span class="line">+	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IMG_SIZE - <span class="number">4</span>; i++)</span><br><span class="line">+		checksum += buffer[i];</span><br><span class="line">+	*(<span class="type">unsigned</span> <span class="type">int</span> *)(buffer+i) = checksum;</span><br><span class="line">+</span><br><span class="line">+	<span class="keyword">if</span> (write(ofd, buffer, BUFSIZE) != BUFSIZE) &#123;</span><br><span class="line">+		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s: Can&#x27;t write %s: %s\n&quot;</span>,</span><br><span class="line">+			argv[<span class="number">0</span>], argv[<span class="number">2</span>], strerror(errno));</span><br><span class="line">+</span><br><span class="line">+		<span class="keyword">if</span> (ifd)</span><br><span class="line">+			close(ifd);</span><br><span class="line">+		<span class="keyword">if</span> (ofd)</span><br><span class="line">+			close(ofd);</span><br><span class="line">+</span><br><span class="line">+		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+	&#125;</span><br><span class="line">+</span><br><span class="line">+	<span class="keyword">if</span> (ifd)</span><br><span class="line">+		close(ifd);</span><br><span class="line">+	<span class="keyword">if</span> (ofd)</span><br><span class="line">+		close(ofd);</span><br><span class="line">+</span><br><span class="line">+	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<h5 id="添加iTOP4412的设备树文件"><a href="#添加iTOP4412的设备树文件" class="headerlink" title="添加iTOP4412的设备树文件"></a>添加iTOP4412的设备树文件</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/dts/exynos4412-itop4412.dts b/arch/arm/dts/exynos4412-itop4412.dts</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..d0f463f</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/arch/arm/dts/exynos4412-itop4412.dts</span><br><span class="line">@@ -0,0 +1,50 @@</span><br><span class="line">+// SPDX-License-Identifier: GPL-2.0+</span><br><span class="line">+/*</span><br><span class="line">+ * Refer to exynos4210-origen.dts</span><br><span class="line">+ *</span><br><span class="line">+ * TOPEET iTOP4412 development board(based on Exynos4412 SoC) device tree</span><br><span class="line">+ * source</span><br><span class="line">+ *</span><br><span class="line">+ * Copyright (C) 2019   Wang Xinlu &lt;wangkartx@gmail.com&gt;</span><br><span class="line">+ *</span><br><span class="line">+ */</span><br><span class="line">+</span><br><span class="line">+/dts-v1/;</span><br><span class="line">+<span class="comment">#include &quot;exynos4412.dtsi&quot;</span></span><br><span class="line">+</span><br><span class="line">+/ &#123;</span><br><span class="line">+	model = <span class="string">&quot;TOPEET iTOP4412 development board based on Exynos4412&quot;</span>;</span><br><span class="line">+	compatible = <span class="string">&quot;TOPEET,itop4412&quot;</span>, <span class="string">&quot;samsung,exynos4412&quot;</span>;</span><br><span class="line">+</span><br><span class="line">+        chose &#123;</span><br><span class="line">+                stdout-path = <span class="string">&quot;/serial@13820000&quot;</span>;</span><br><span class="line">+        &#125;;</span><br><span class="line">+</span><br><span class="line">+	aliases &#123;</span><br><span class="line">+		serial2 = <span class="string">&quot;/serial@13820000&quot;</span>;</span><br><span class="line">+		console = <span class="string">&quot;/serial@13820000&quot;</span>;</span><br><span class="line">+	&#125;;</span><br><span class="line">+</span><br><span class="line">+        serial@13800000 &#123;</span><br><span class="line">+                status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">+        &#125;;</span><br><span class="line">+</span><br><span class="line">+        serial@13810000 &#123;</span><br><span class="line">+                status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">+        &#125;;</span><br><span class="line">+</span><br><span class="line">+        serial@13820000 &#123;</span><br><span class="line">+                status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">+        &#125;;</span><br><span class="line">+</span><br><span class="line">+        serial@13830000 &#123;</span><br><span class="line">+                status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">+        &#125;;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+&amp;sdhci2 &#123;</span><br><span class="line">+	samsung,bus-width = &lt;4&gt;;</span><br><span class="line">+	samsung,timing = &lt;1 2 3&gt;;</span><br><span class="line">+	cd-gpios = &lt;&amp;gpx0 7 0&gt;;</span><br><span class="line">+	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">+&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="添加board相关的编译构建文件"><a href="#添加board相关的编译构建文件" class="headerlink" title="添加board相关的编译构建文件"></a>添加board相关的编译构建文件</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">diff --git a/board/samsung/itop4412/Makefile b/board/samsung/itop4412/Makefile</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..65df3b8</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/board/samsung/itop4412/Makefile</span><br><span class="line">@@ -0,0 +1,17 @@</span><br><span class="line">+<span class="comment"># SPDX-License-Identifier: GPL-2.0+</span></span><br><span class="line">+</span><br><span class="line">+<span class="keyword">ifdef</span> CONFIG_SPL_BUILD</span><br><span class="line">+<span class="comment"># necessary to create built-in.o</span></span><br><span class="line">+obj- := __dummy__.o</span><br><span class="line">+</span><br><span class="line">+hostprogs-y := tools/mkitop4412spl</span><br><span class="line">+always := $(hostprogs-y)</span><br><span class="line">+</span><br><span class="line">+<span class="comment"># omit -O2 option to suppress</span></span><br><span class="line">+<span class="comment">#   warning: dereferencing type-punned pointer will break strict-aliasing rules</span></span><br><span class="line">+<span class="comment">#</span></span><br><span class="line">+<span class="comment"># <span class="doctag">TODO:</span></span></span><br><span class="line">+<span class="comment"># Fix the root cause in tools/mkitop4412spl.c and delete the following work-around</span></span><br><span class="line"><span class="section">+$(obj)/tools/mkitop4412spl: HOSTCFLAGS:=$(filter-out -O2,<span class="variable">$(HOSTCFLAGS)</span>)</span></span><br><span class="line">+<span class="keyword">endif</span></span><br><span class="line">+obj-y	+= itop4412.o</span><br></pre></td></tr></table></figure>

<h5 id="添加board相关的编译配置文件"><a href="#添加board相关的编译配置文件" class="headerlink" title="添加board相关的编译配置文件"></a>添加board相关的编译配置文件</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">diff --git a/board/samsung/itop4412/Kconfig b/board/samsung/itop4412/Kconfig</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..3ed2a25</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/board/samsung/itop4412/Kconfig</span><br><span class="line">@@ -0,0 +1,19 @@</span><br><span class="line">+if TARGET_ITOP4412</span><br><span class="line">+</span><br><span class="line">+config SYS_BOARD</span><br><span class="line">+	default <span class="string">&quot;itop4412&quot;</span></span><br><span class="line">+</span><br><span class="line">+config SYS_VENDOR</span><br><span class="line">+	default <span class="string">&quot;samsung&quot;</span></span><br><span class="line">+</span><br><span class="line">+config SYS_CONFIG_NAME</span><br><span class="line">+	default <span class="string">&quot;itop4412&quot;</span></span><br><span class="line">+</span><br><span class="line">+config ITOP4412</span><br><span class="line">+    bool <span class="string">&quot;TOPEET iTOP4412 development board&quot;</span></span><br><span class="line">+    default y</span><br><span class="line">+</span><br><span class="line">+config EXYNOS4412</span><br><span class="line">+    bool <span class="string">&quot;Samsung Exynos4412 SoC&quot;</span></span><br><span class="line">+    default y</span><br><span class="line">+<span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h5 id="添加board相关的维护信息，从代码角度看可能并不是很重要，但是还是有必要的"><a href="#添加board相关的维护信息，从代码角度看可能并不是很重要，但是还是有必要的" class="headerlink" title="添加board相关的维护信息，从代码角度看可能并不是很重要，但是还是有必要的"></a>添加board相关的维护信息，从代码角度看可能并不是很重要，但是还是有必要的</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">diff --git a/board/samsung/itop4412/MAINTAINERS b/board/samsung/itop4412/MAINTAINERS</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..77228c2</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/board/samsung/itop4412/MAINTAINERS</span><br><span class="line">@@ -0,0 +1,6 @@</span><br><span class="line">+iTOP4412 Development Board</span><br><span class="line"><span class="section">+M:	Wang Xinlu &lt;wangkartx@gmail.com&gt;</span></span><br><span class="line"><span class="section">+S:	Maintained</span></span><br><span class="line"><span class="section">+F:	board/samsung/itop4412/</span></span><br><span class="line"><span class="section">+F:	include/configs/itop4412.h</span></span><br><span class="line"><span class="section">+F:	configs/itop4412_defconfig</span></span><br></pre></td></tr></table></figure>

<h5 id="添加board相关的默认配置文件"><a href="#添加board相关的默认配置文件" class="headerlink" title="添加board相关的默认配置文件"></a>添加board相关的默认配置文件</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">diff --git a/configs/itop4412_defconfig b/configs/itop4412_defconfig</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..8489a56</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/configs/itop4412_defconfig</span><br><span class="line">@@ -0,0 +1,37 @@</span><br><span class="line">+CONFIG_ARM=y</span><br><span class="line">+CONFIG_ARCH_CPU_INIT=y</span><br><span class="line">+CONFIG_ARCH_EXYNOS=y</span><br><span class="line">+CONFIG_SYS_TEXT_BASE=0x43E00000</span><br><span class="line">+CONFIG_ARCH_EXYNOS4=y</span><br><span class="line">+CONFIG_TARGET_ITOP4412=y</span><br><span class="line">+CONFIG_SPL=y</span><br><span class="line">+CONFIG_SPL_TEXT_BASE=0x02023400</span><br><span class="line">+<span class="comment"># CONFIG_SPL_FRAMEWORK is not set</span></span><br><span class="line">+CONFIG_IDENT_STRING=<span class="string">&quot; for iTOP4412&quot;</span></span><br><span class="line">+CONFIG_DEFAULT_DEVICE_TREE=<span class="string">&quot;exynos4412-itop4412&quot;</span></span><br><span class="line">+CONFIG_SYS_PROMPT=<span class="string">&quot;iTOP4412 # &quot;</span></span><br><span class="line">+<span class="comment"># CONFIG_CMD_XIMG is not set</span></span><br><span class="line">+CONFIG_DISTRO_DEFAULTS=y</span><br><span class="line">+<span class="comment"># CONFIG_USE_BOOTCOMMAND is not set</span></span><br><span class="line">+<span class="comment"># CONFIG_CMD_IMLS is not set</span></span><br><span class="line">+<span class="comment"># CONFIG_CMD_FPGA is not set</span></span><br><span class="line">+<span class="comment"># CONFIG_CMD_NET is not set</span></span><br><span class="line">+<span class="comment"># CONFIG_CMD_NFS is not set</span></span><br><span class="line">+<span class="comment"># CONFIG_CMD_MISC is not set</span></span><br><span class="line">+CONFIG_DEBUG_UART=y</span><br><span class="line">+CONFIG_SPL_SERIAL_SUPPORT=y</span><br><span class="line">+CONFIG_SPL_GPIO_SUPPORT=y</span><br><span class="line">+CONFIG_DEBUG_UART_BASE=0x13820000</span><br><span class="line">+CONFIG_DEBUG_UART_CLOCK=100000000</span><br><span class="line">+CONFIG_S5P=y</span><br><span class="line">+CONFIG_DEBUG_UART_S5P=y</span><br><span class="line">+CONFIG_DEBUG_UART_ANNOUNCE=y</span><br><span class="line">+CONFIG_CMD_MMC=y</span><br><span class="line">+CONFIG_DM_MMC=y</span><br><span class="line">+CONFIG_MMC_DW=y</span><br><span class="line">+CONFIG_MMC_SDHCI=y</span><br><span class="line">+CONFIG_MMC_SDHCI_SDMA=y</span><br><span class="line">+CONFIG_MMC_SDHCI_S5P=y</span><br><span class="line">+CONFIG_MMC_BROKEN_CD=y</span><br><span class="line">+CONFIG_CMD_CACHE=y</span><br><span class="line">+CONFIG_CMD_EXT4_WRITE=y</span><br></pre></td></tr></table></figure>

<h5 id="添加board相关的全局设置文件"><a href="#添加board相关的全局设置文件" class="headerlink" title="添加board相关的全局设置文件"></a>添加board相关的全局设置文件</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/include/configs/itop4412.h b/include/configs/itop4412.h</span><br><span class="line">new file mode <span class="number">100644</span></span><br><span class="line">index <span class="number">0000000.</span><span class="number">.47</span>ae372</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/include/configs/itop4412.h</span><br><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span>,<span class="number">94</span> @@</span><br><span class="line">+<span class="comment">/* SPDX-License-Identifier: GPL-2.0+ */</span></span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Configuration and settings for the TOPEET iTOP4412 development board.</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">ifndef</span> __CONFIG_ITOP4412_H</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> __CONFIG_ITOP4412_H</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;configs/exynos4-common.h&gt;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* iTOP4412 has 4 bank of DRAM */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SYS_SDRAM_BASE		0x40000000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> PHYS_SDRAM_1			CONFIG_SYS_SDRAM_BASE</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> SDRAM_BANK_SIZE			(256 &lt;&lt; 20)	<span class="comment">/* 256 MiB */</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* memtest works on */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x6000000)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x3E00000)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SYS_INIT_SP_ADDR	        (CONFIG_SYS_LOAD_ADDR - 0x1000000)</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_MACH_TYPE		MACH_TYPE_ITOP4412</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* select serial console configuration */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_BAUDRATE 115200</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* Console configuration */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_DEFAULT_CONSOLE		<span class="string">&quot;ttySAC2,115200n8&quot;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SYS_MEM_TOP_HIDE	(1 &lt;&lt; 20)	<span class="comment">/* ram console */</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SYS_MONITOR_BASE	0x00000000</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* Power Down Modes */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> S5P_CHECK_SLEEP			0x00000BAD</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> S5P_CHECK_DIDLE			0xBAD00000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> S5P_CHECK_LPA			0xABAD0000</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* SPL configuration */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SPL_MAX_FOOTPRINT        (14 &lt;&lt; 10)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SPL_STACK                0x02060000</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_EXTRA_ENV_SETTINGS \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;loadaddr=0x40007000\0&quot;</span> \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;rdaddr=0x48000000\0&quot;</span> \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;kerneladdr=0x40007000\0&quot;</span> \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;ramdiskaddr=0x48000000\0&quot;</span> \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;console=&quot;</span> CONFIG_DEFAULT_CONSOLE <span class="string">&quot;\0&quot;</span>\</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;mmcdev=0\0&quot;</span> \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;bootenv=uEnv.txt\0&quot;</span> \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;loadbootenv=load mmc $&#123;mmcdev&#125; $&#123;loadaddr&#125; $&#123;bootenv&#125;\0&quot;</span> \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;importbootenv=echo Importing environment from mmc ...; &quot;</span> \</span></span><br><span class="line"><span class="meta">+		<span class="string">&quot;env import -t $loadaddr $filesize\0&quot;</span> \</span></span><br><span class="line"><span class="meta">+        <span class="string">&quot;loadbootscript=load mmc $&#123;mmcdev&#125; $&#123;loadaddr&#125; boot.scr\0&quot;</span> \</span></span><br><span class="line"><span class="meta">+        <span class="string">&quot;bootscript=echo Running bootscript from mmc$&#123;mmcdev&#125; ...; &quot;</span> \</span></span><br><span class="line"><span class="meta">+                <span class="string">&quot;source $&#123;loadaddr&#125;\0&quot;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;if mmc rescan; then &quot;</span> \</span></span><br><span class="line"><span class="meta">+		<span class="string">&quot;echo SD/MMC found on device $&#123;mmcdev&#125;;&quot;</span> \</span></span><br><span class="line"><span class="meta">+		<span class="string">&quot;if run loadbootenv; then &quot;</span> \</span></span><br><span class="line"><span class="meta">+			<span class="string">&quot;echo Loaded environment from $&#123;bootenv&#125;;&quot;</span> \</span></span><br><span class="line"><span class="meta">+			<span class="string">&quot;run importbootenv;&quot;</span> \</span></span><br><span class="line"><span class="meta">+		<span class="string">&quot;fi;&quot;</span> \</span></span><br><span class="line"><span class="meta">+		<span class="string">&quot;if test -n $uenvcmd; then &quot;</span> \</span></span><br><span class="line"><span class="meta">+			<span class="string">&quot;echo Running uenvcmd ...;&quot;</span> \</span></span><br><span class="line"><span class="meta">+			<span class="string">&quot;run uenvcmd;&quot;</span> \</span></span><br><span class="line"><span class="meta">+		<span class="string">&quot;fi;&quot;</span> \</span></span><br><span class="line"><span class="meta">+		<span class="string">&quot;if run loadbootscript; then &quot;</span> \</span></span><br><span class="line"><span class="meta">+			<span class="string">&quot;run bootscript; &quot;</span> \</span></span><br><span class="line"><span class="meta">+		<span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;fi;&quot;</span> \</span></span><br><span class="line"><span class="meta">+	<span class="string">&quot;load mmc $&#123;mmcdev&#125; $&#123;loadaddr&#125; uImage; bootm $&#123;loadaddr&#125; &quot;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_CLK_1000_400_200</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_SYS_MMC_ENV_DEV	0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_ENV_SIZE		(16 &lt;&lt; 10)	<span class="comment">/* 16 KB */</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> RESERVE_BLOCK_SIZE	(512)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> FWBL_SIZE       (8 &lt;&lt; 10)  <span class="comment">/* 8 KiB reserved for fwbl.bin*/</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> SPL_SZIE        (16 &lt;&lt; 10)  <span class="comment">/* 16KiB reserved for u-boot-spl.bin */</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UBOOT_SIZE      (0x80000)   <span class="comment">/* 512 KiB reserved for u-boot.bin*/</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TZSW_SIZE       (0x27000)   <span class="comment">/* 156 KiB */</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> BL2_START_OFFSET      ((RESERVE_BLOCK_SIZE + FWBL_SIZE \</span></span><br><span class="line"><span class="meta">+                                        + SPL_SZIE)/512)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> BL2_SIZE_BLOC_COUNT   (UBOOT_SIZE/512)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TZSW_START_OFFSET       (BL2_START_OFFSET \</span></span><br><span class="line"><span class="meta">+                                        + BL2_SIZE_BLOC_COUNT)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TZSW_SIZE_BLOC_COUNT    (TZSW_SIZE/512)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONFIG_ENV_OFFSET	(RESERVE_BLOCK_SIZE + FWBL_SIZE \</span></span><br><span class="line"><span class="meta">+                                        + SPL_SZIE + UBOOT_SIZE \</span></span><br><span class="line"><span class="meta">+                                        + TZSW_SIZE)</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __CONFIG_H */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="修改相关的代码和配置"><a href="#修改相关的代码和配置" class="headerlink" title="修改相关的代码和配置"></a>修改相关的代码和配置</h4><h5 id="修改SoC相关的编译配置文件，使iTOP4412相关的配置在menuconfig中出现"><a href="#修改SoC相关的编译配置文件，使iTOP4412相关的配置在menuconfig中出现" class="headerlink" title="修改SoC相关的编译配置文件，使iTOP4412相关的配置在menuconfig中出现"></a>修改SoC相关的编译配置文件，使iTOP4412相关的配置在menuconfig中出现</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-exynos/Kconfig b/arch/arm/mach-exynos/Kconfig</span><br><span class="line">index 14347e7..bf622c2 100644</span><br><span class="line">--- a/arch/arm/mach-exynos/Kconfig</span><br><span class="line">+++ b/arch/arm/mach-exynos/Kconfig</span><br><span class="line">@@ -73,6 +73,11 @@ config TARGET_TRATS2</span><br><span class="line"> config TARGET_ODROID</span><br><span class="line"> 	bool <span class="string">&quot;Exynos4412 Odroid board&quot;</span></span><br><span class="line"> </span><br><span class="line">+config TARGET_ITOP4412</span><br><span class="line">+        bool <span class="string">&quot;Exynos4412 iTOP4412 board&quot;</span></span><br><span class="line">+        select OF_CONTROL</span><br><span class="line">+        select SUPPORT_SPL</span><br><span class="line">+</span><br><span class="line"> endchoice</span><br><span class="line"> <span class="keyword">endif</span></span><br><span class="line"> </span><br><span class="line">@@ -167,6 +172,7 @@ source <span class="string">&quot;board/samsung/arndale/Kconfig&quot;</span></span><br><span class="line"> source <span class="string">&quot;board/samsung/smdk5250/Kconfig&quot;</span></span><br><span class="line"> source <span class="string">&quot;board/samsung/smdk5420/Kconfig&quot;</span></span><br><span class="line"> source <span class="string">&quot;board/samsung/espresso7420/Kconfig&quot;</span></span><br><span class="line">+source <span class="string">&quot;board/samsung/itop4412/Kconfig&quot;</span></span><br><span class="line"> </span><br><span class="line"> config SPL_LDSCRIPT</span><br><span class="line"> 	default <span class="string">&quot;board/samsung/common/exynos-uboot-spl.lds&quot;</span> if ARCH_EXYNOS5 || ARCH_EXYNOS4</span><br></pre></td></tr></table></figure>

<h5 id="修改SoC相关的编译构建文件，用于编译iTOP4412启动时需要的初始化代码"><a href="#修改SoC相关的编译构建文件，用于编译iTOP4412启动时需要的初始化代码" class="headerlink" title="修改SoC相关的编译构建文件，用于编译iTOP4412启动时需要的初始化代码"></a>修改SoC相关的编译构建文件，用于编译iTOP4412启动时需要的初始化代码</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-exynos/Makefile b/arch/arm/mach-exynos/Makefile</span><br><span class="line">index e895c13..58749aa 100644</span><br><span class="line">--- a/arch/arm/mach-exynos/Makefile</span><br><span class="line">+++ b/arch/arm/mach-exynos/Makefile</span><br><span class="line">@@ -12,7 +12,9 @@ obj-<span class="variable">$(CONFIG_EXYNOS5420)</span>	+= sec_boot.o</span><br><span class="line"> <span class="keyword">ifdef</span> CONFIG_SPL_BUILD</span><br><span class="line"> obj-<span class="variable">$(CONFIG_EXYNOS5)</span>	+= clock_init_exynos5.o</span><br><span class="line"> obj-<span class="variable">$(CONFIG_EXYNOS5)</span>	+= dmc_common.o dmc_init_ddr3.o</span><br><span class="line">-obj-<span class="variable">$(CONFIG_EXYNOS4210)</span>+= dmc_init_exynos4.o clock_init_exynos4.o</span><br><span class="line">+<span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">filter</span> y,<span class="variable">$(CONFIG_EXYNOS4210)</span><span class="variable">$(CONFIG_EXYNOS4412)</span>)</span>,)</span><br><span class="line">+obj-y	+= dmc_init_exynos4.o clock_init_exynos4.o</span><br><span class="line">+<span class="keyword">endif</span></span><br><span class="line"> obj-y	+= spl_boot.o tzpc.o</span><br><span class="line"> obj-y	+= lowlevel_init.o</span><br><span class="line"> <span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h5 id="修改SoC相关的初始化代码"><a href="#修改SoC相关的初始化代码" class="headerlink" title="修改SoC相关的初始化代码"></a>修改SoC相关的初始化代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-exynos/lowlevel_init.c b/arch/arm/mach-exynos/lowlevel_init.c</span><br><span class="line">index <span class="number">1e090</span>fd.<span class="number">.55</span>f16db <span class="number">100644</span></span><br><span class="line">--- a/arch/arm/mach-exynos/lowlevel_init.c</span><br><span class="line">+++ b/arch/arm/mach-exynos/lowlevel_init.c</span><br><span class="line">@@ <span class="number">-218</span>,<span class="number">12</span> +<span class="number">218</span>,<span class="number">18</span> @@ <span class="type">int</span> <span class="title function_">do_lowlevel_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_UART</span></span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> (defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_SERIAL_SUPPORT)) || \</span></span><br><span class="line"><span class="meta">     !defined(CONFIG_SPL_BUILD)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITOP4412</span></span><br><span class="line">+                <span class="title function_">exynos_pinmux_config</span><span class="params">(PERIPH_ID_UART2, PINMUX_FLAG_NONE)</span>;</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 		exynos_pinmux_config(PERIPH_ID_UART3, PINMUX_FLAG_NONE);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 		debug_uart_init();</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 		mem_ctrl_init(actions &amp; DO_MEM_RESET);</span><br><span class="line">+<span class="meta">#<span class="keyword">ifndef</span> CONFIG_ITOP4412</span></span><br><span class="line"> 		tzpc_init();</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	&#125;</span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">return</span> actions &amp; DO_WAKEUP;</span><br></pre></td></tr></table></figure>

<h5 id="修改SoC相关的power设置代码"><a href="#修改SoC相关的power设置代码" class="headerlink" title="修改SoC相关的power设置代码"></a>修改SoC相关的power设置代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-exynos/include/mach/power.h b/arch/arm/mach-exynos/include/mach/power.h</span><br><span class="line">index a3d8974.<span class="number">.7</span>b5dcf4 <span class="number">100644</span></span><br><span class="line">--- a/arch/arm/mach-exynos/include/mach/power.h</span><br><span class="line">+++ b/arch/arm/mach-exynos/include/mach/power.h</span><br><span class="line">@@ <span class="number">-214</span>,<span class="number">6</span> +<span class="number">214</span>,<span class="number">8</span> @@ <span class="class"><span class="keyword">struct</span> <span class="title">exynos4412_power</span> &#123;</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span>	usbhost_phy_control;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span>	hsic1_phy_control;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span>	hsic2_phy_control;</span><br><span class="line">+        <span class="type">unsigned</span> <span class="type">char</span>   res2[<span class="number">0x2bfc</span>];</span><br><span class="line">+        <span class="type">unsigned</span> <span class="type">int</span>    ps_hold_control;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">exynos5_power</span> &#123;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-exynos/power.c b/arch/arm/mach-exynos/power.c</span><br><span class="line">index f2a6c00.<span class="number">.8</span>feab8f <span class="number">100644</span></span><br><span class="line">--- a/arch/arm/mach-exynos/power.c</span><br><span class="line">+++ b/arch/arm/mach-exynos/power.c</span><br><span class="line">@@ <span class="number">-162</span>,<span class="number">6</span> +<span class="number">162</span>,<span class="number">32</span> @@ <span class="type">static</span> <span class="type">void</span> <span class="title function_">exynos5_set_ps_hold_ctrl</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> 			EXYNOS_PS_HOLD_CONTROL_DATA_HIGH);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">+<span class="type">static</span> <span class="type">void</span> <span class="title function_">exynos4412_set_ps_hold_ctrl</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">+&#123;</span><br><span class="line">+        <span class="class"><span class="keyword">struct</span> <span class="title">exynos4412_power</span> *<span class="title">power</span> =</span></span><br><span class="line">+                (<span class="keyword">struct</span> exynos4412_power *)samsung_get_base_power();</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">/* Set PS-Hold high */</span></span><br><span class="line">+        setbits_le32(&amp;power-&gt;ps_hold_control,</span><br><span class="line">+                EXYNOS_PS_HOLD_CONTROL_DATA_HIGH);</span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITOP4412</span></span><br><span class="line">+        <span class="comment">/*</span></span><br><span class="line"><span class="comment">+         * 0x0 = Disables Pull-up/Pull-down</span></span><br><span class="line"><span class="comment">+         * 0x1 = Enables Pull-down</span></span><br><span class="line"><span class="comment">+         * 0x2 = Reserved</span></span><br><span class="line"><span class="comment">+         * 0x3 = Enables Pull-up</span></span><br><span class="line"><span class="comment">+         *</span></span><br><span class="line"><span class="comment">+         * Due to GPX0_2 attached to PMIC&#x27;s ONO pin,</span></span><br><span class="line"><span class="comment">+         * make GPX0_2 pin PU for high level,</span></span><br><span class="line"><span class="comment">+         * but all other pin default state for low level</span></span><br><span class="line"><span class="comment">+         * otherwise, keep restarting</span></span><br><span class="line"><span class="comment">+         *</span></span><br><span class="line"><span class="comment">+         */</span></span><br><span class="line">+        writel(<span class="number">0x5575</span>, (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0x11000C08</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Set ps_hold data driving value high</span></span><br><span class="line"><span class="comment">  * This enables the machine to stay powered on</span></span><br><span class="line"><span class="comment">@@ -172,6 +198,13 @@ void set_ps_hold_ctrl(void)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> 	if (cpu_is_exynos5())</span></span><br><span class="line"><span class="comment"> 		exynos5_set_ps_hold_ctrl();</span></span><br><span class="line"><span class="comment">+</span></span><br><span class="line"><span class="comment">+#ifdef CONFIG_EXYNOS4412</span></span><br><span class="line"><span class="comment">+        if (cpu_is_exynos4()) &#123;</span></span><br><span class="line"><span class="comment">+                if (proid_is_exynos4412())</span></span><br><span class="line"><span class="comment">+                        exynos4412_set_ps_hold_ctrl();</span></span><br><span class="line"><span class="comment">+        &#125;</span></span><br><span class="line"><span class="comment">+#endif</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br></pre></td></tr></table></figure>

<h5 id="修改平台的标识符，为itop4412赋予一个独一无二的ID"><a href="#修改平台的标识符，为itop4412赋予一个独一无二的ID" class="headerlink" title="修改平台的标识符，为itop4412赋予一个独一无二的ID"></a>修改平台的标识符，为itop4412赋予一个独一无二的ID</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/include/<span class="keyword">asm</span>/mach-types.h b/arch/arm/include/<span class="keyword">asm</span>/mach-types.h</span><br><span class="line">index <span class="number">32532b</span>3..ec82f02 <span class="number">100644</span></span><br><span class="line">--- a/arch/arm/include/<span class="keyword">asm</span>/mach-types.h</span><br><span class="line">+++ b/arch/arm/include/<span class="keyword">asm</span>/mach-types.h</span><br><span class="line">@@ <span class="number">-5051</span>,<span class="number">4</span> +<span class="number">5051</span>,<span class="number">5</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> MACH_TYPE_NASM25               5112</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> MACH_TYPE_TOMATO               5113</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> MACH_TYPE_OMAP3_MRC3D          5114</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MACH_TYPE_ITOP4412             5115</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h5 id="增添itop4412设备树的编译规则"><a href="#增添itop4412设备树的编译规则" class="headerlink" title="增添itop4412设备树的编译规则"></a>增添itop4412设备树的编译规则</h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile</span><br><span class="line">index 62da168..802afaf 100644</span><br><span class="line">--- a/arch/arm/dts/Makefile</span><br><span class="line">+++ b/arch/arm/dts/Makefile</span><br><span class="line">@@ -12,7 +12,8 @@ dtb-<span class="variable">$(CONFIG_EXYNOS4)</span> += exynos4210-origen.dtb \</span><br><span class="line"> 	exynos4210-universal_c210.dtb \</span><br><span class="line"> 	exynos4210-trats.dtb \</span><br><span class="line"> 	exynos4412-trats2.dtb \</span><br><span class="line">-	exynos4412-odroid.dtb</span><br><span class="line">+	exynos4412-odroid.dtb \</span><br><span class="line">+	exynos4412-itop4412.dtb</span><br><span class="line"> </span><br><span class="line"> dtb-<span class="variable">$(CONFIG_TARGET_HIKEY)</span> += hi6220-hikey.dtb</span><br><span class="line"> dtb-<span class="variable">$(CONFIG_TARGET_HIKEY960)</span> += hi3660-hikey960.dtb</span><br></pre></td></tr></table></figure>

<h4 id="适配时钟和内存控制器"><a href="#适配时钟和内存控制器" class="headerlink" title="适配时钟和内存控制器"></a>适配时钟和内存控制器</h4><h5 id="添加时钟和内存控制器初始化所使用的设置"><a href="#添加时钟和内存控制器初始化所使用的设置" class="headerlink" title="添加时钟和内存控制器初始化所使用的设置"></a>添加时钟和内存控制器初始化所使用的设置</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-exynos/exynos4412_setup.h b/arch/arm/mach-exynos/exynos4412_setup.h</span><br><span class="line">new file mode <span class="number">100644</span></span><br><span class="line">index <span class="number">0000000.</span>.fc8633b</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/arch/arm/mach-exynos/exynos4412_setup.h</span><br><span class="line">@@ <span class="number">-0</span>,<span class="number">0</span> +<span class="number">1</span>,<span class="number">528</span> @@</span><br><span class="line">+<span class="comment">/* SPDX-License-Identifier: GPL-2.0+ */</span></span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * refer to exynox4_setup.h</span></span><br><span class="line"><span class="comment">+ * Machine Specific settings for Exynos4412 board</span></span><br><span class="line"><span class="comment">+ *</span></span><br><span class="line"><span class="comment">+ * Copyright (C) 2018 Wang Xinlu &lt;wangkartx@gmail.com&gt;</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">ifndef</span> _EXYNOX4412_SETUP_H</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> _EXYNOX4412_SETUP_H</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Refer to the datasheet</span></span><br><span class="line"><span class="comment">+ * The value for high-performance</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_CLK_800_400_200</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ARM_CLK_800</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DRAM_CLK_400</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_CLK_1000_400_200</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ARM_CLK_1000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DRAM_CLK_400</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* Bus Configuration Register Address */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ASYNC_CONFIG        0x10010350</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_SRC_CPU */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_USER_SEL_C_FINPLL		0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_USER_SEL_C_FOUTMPLL	0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_HPM_SEL_MOUTAPLL		    0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_HPM_SEL_SCLKMPLL		    0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_CORE_SEL_MOUTAPLL		    0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_CORE_SEL_SCLKMPLL		    0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_APLL_SEL_FILPLL		        0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_APLL_SEL_FOUTAPLL	        0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_CPU_RESET   ((MUX_MPLL_USER_SEL_C_FINPLL &lt;&lt; 24) \</span></span><br><span class="line"><span class="meta">+                    | (MUX_HPM_SEL_MOUTAPLL &lt;&lt; 20) \</span></span><br><span class="line"><span class="meta">+                    | (MUX_CORE_SEL_MOUTAPLL &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (MUX_APLL_SEL_FILPLL &lt;&lt; 0))</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_CPU_VAL     ((MUX_MPLL_USER_SEL_C_FOUTMPLL &lt;&lt; 24) \</span></span><br><span class="line"><span class="meta">+                    | (MUX_HPM_SEL_MOUTAPLL &lt;&lt; 20) \</span></span><br><span class="line"><span class="meta">+                    | (MUX_CORE_SEL_MOUTAPLL &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (MUX_APLL_SEL_FOUTAPLL &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_MUX_STAT_CPU */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_MUX_STAT_CPU_RESET  0x01110001</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_MUX_STAT_CPU_VAL    0x02110002</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_CPU0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_RATIO      0x01</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CORE_RATIO      0x00</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CORE2_RATIO     0x00</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> PCLK_DBG_RATIO  0x01</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ATB_RATIO       0x03</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> COREM0_RATIO    0x03</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> COREM1_RATIO    0x07</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> PERIPH_RATIO    0x03</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_CPU1 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> COPY_RATIO      0x02</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> HPM_RATIO       0x00</span></span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_CPU0_VAL    ((CORE2_RATIO &lt;&lt; 28) \</span></span><br><span class="line"><span class="meta">+                    | (APLL_RATIO &lt;&lt; 24) \</span></span><br><span class="line"><span class="meta">+                    | (PCLK_DBG_RATIO &lt;&lt; 20) \</span></span><br><span class="line"><span class="meta">+                    | (ATB_RATIO &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (PERIPH_RATIO &lt;&lt; 12) \</span></span><br><span class="line"><span class="meta">+                    | (COREM1_RATIO &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                    | (COREM0_RATIO &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                    | (CORE_RATIO &lt;&lt; 0))</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_CPU1_VAL    ((HPM_RATIO &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                    | (COPY_RATIO &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_SRC_DMC */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_G2D_ACP_SEL_MOUTG2D_ACP_0   0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_G2D_ACP_SEL_MOUTG2D_ACP_1   0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_G2D_ACP_1_SEL_SCLKEPLL      0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_G2D_ACP_1_SEL_SCLKAPLL      0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_PWI_SEL_XXTI		        0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_PWI_SEL_XUSBXTI		        0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_PWI_SEL_SCLK_HDMI24M	    0x2</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_PWI_SEL_SCLK_USBPHY0	    0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_PWI_SEL_SCLK_USBPHY1	    0x4</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_PWI_SEL_SCLK_HDMIPHY	    0x5</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_PWI_SEL_SCLKMPLL		    0x6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_PWI_SEL_SCLKEPLL		    0x7</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_PWI_SEL_SCLKVPLL		    0x8</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_SEL_FILPLL             0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_SEL_MOUTMPLLFOUT       0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_DPHY_SEL_SCLKMPLL		    0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_DPHY_SEL_SCLKAPLL		    0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_DMC_BUS_SEL_SCLKMPLL	    0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_DMC_BUS_SEL_SCLKAPLL	    0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_DMC_VAL		((MUX_PWI_SEL_XUSBXTI &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (MUX_MPLL_SEL_MOUTMPLLFOUT &lt;&lt; 12))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_MUX_STAT_DMC */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_MUX_STAT_DMC_VAL    0x11102111</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_DMC0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DMCP_RATIO		0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DMCD_RATIO		0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DMC_RATIO		0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DPHY_RATIO		0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ACP_PCLK_RATIO	0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ACP_RATIO		0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_DMC0_VAL    ((DMCP_RATIO &lt;&lt; 20) \</span></span><br><span class="line"><span class="meta">+                    | (DMCD_RATIO &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (DMC_RATIO &lt;&lt; 12) \</span></span><br><span class="line"><span class="meta">+                    | (DPHY_RATIO &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                    | (ACP_PCLK_RATIO &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                    | (ACP_RATIO &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_DMC1 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DPM_RATIO		0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DVSEM_RATIO		0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> C2C_ACLK_RATIO  0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> PWI_RATIO		0xF</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> C2C_RATIO       0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> G2D_ACP_RATIO   0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_DMC1_VAL	((DPM_RATIO &lt;&lt; 24) \</span></span><br><span class="line"><span class="meta">+				| (DVSEM_RATIO &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                | (C2C_ACLK_RATIO &lt;&lt; 12) \</span></span><br><span class="line"><span class="meta">+				| (PWI_RATIO &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                | (C2C_RATIO &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                | (G2D_ACP_RATIO &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_SRC_TOP0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_VPLL_SEL_FINPLL     0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_VPLL_SEL_FOUTVPLL   0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_EPLL_SEL_FINPLL     0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_EPLL_SEL_FOUTEPLL   0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_TOP0_RESET      0x00000000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_TOP0_VAL    ((MUX_VPLL_SEL_FOUTVPLL &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                    | (MUX_EPLL_SEL_FOUTEPLL &lt;&lt; 4))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_MUX_STAT_TOP0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_MUX_STAT_TOP0_RESET 0x11111111</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_MUX_STAT_TOP0_VAL   0x11111221</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_SRC_TOP1 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_ACLK_266_GPS_SUB_SEL_FINPLL 0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_ACLK_266_GPS_SUB_SEL_DIVOUT_ACLK_266_GPS    0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_USER_SEL_T_FINPLL      0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_USER_SEL_T_SCLKMPLL    0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_ACLK_400_MCUISP_SEL_SCLKMPLL_USER_T 0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_ACLK_400_MCUISP_SEL_SCLKAPLL        0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_TOP1_RESET      0x00000000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_TOP1_VAL    ((MUX_ACLK_266_GPS_SUB_SEL_DIVOUT_ACLK_266_GPS &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (MUX_MPLL_USER_SEL_T_SCLKMPLL &lt;&lt; 12))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_MUX_STAT_TOP1 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_MUX_STAT_TOP1_RESET 0x01111110</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_MUX_STAT_TOP1_VAL   0x01122110</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_TOP */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ACLK_400_MCUISP_RATIO   0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ACLK_266_GPS_RATIO      0x2</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ONENAND_RATIO           0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ACLK_133_RATIO          0x5</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ACLK_160_RATIO          0x4</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ACLK_100_RATIO          0x7</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ACLK_200_RATIO          0x4</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_TOP_VAL     ((ACLK_400_MCUISP_RATIO &lt;&lt; 24) \</span></span><br><span class="line"><span class="meta">+                    | (ACLK_266_GPS_RATIO &lt;&lt; 20) \</span></span><br><span class="line"><span class="meta">+                    | (ONENAND_RATIO &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (ACLK_133_RATIO &lt;&lt; 12) \</span></span><br><span class="line"><span class="meta">+                    | (ACLK_160_RATIO &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                    | (ACLK_100_RATIO &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                    | (ACLK_200_RATIO &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_SRC_LEFTBUS */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_USER_SEL_L_FILPLL      0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_USER_SEL_L_FOUTMPLL    0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_GDL_SEL_SCLKMPLL            0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_GDL_SEL_SCLKAPLL            0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_LEFTBUS_VAL     ((MUX_MPLL_USER_SEL_L_FOUTMPLL &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                        | (MUX_GDL_SEL_SCLKMPLL &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_MUX_STAT_LEFTBUS */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_MUX_STAT_LEFTBUS_VAL    0x00000021</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_LEFTBUS */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> GPL_RATIO   0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> GDL_RATIO   0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_LEFTBUS_VAL     ((GPL_RATIO &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                        | (GDL_RATIO &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_SRC_RIGHTBUS */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_USER_SEL_R_FINPLL      0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_MPLL_USER_SEL_R_FOUTMPLL    0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_GDR_SEL_SCLKMPLL            0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MUX_GDR_SEL_SCLKAPLL            0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_RIGHTBUS_VAL    ((MUX_MPLL_USER_SEL_R_FOUTMPLL &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                        | (MUX_GDR_SEL_SCLKMPLL &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_MUX_STAT_LEFTBUS */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_MUX_STAT_RIGHTBUS_VAL    0x00000021</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_RIGHTBUS */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> GPR_RATIO   0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> GDR_RATIO   0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_RIGHTBUS_VAL    ((GPR_RATIO &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                        | (GDR_RATIO &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DISABLE 0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ENABLE  1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> SET_PLL(mdiv, pdiv, sdiv)     ((ENABLE &lt;&lt; 31) \</span></span><br><span class="line"><span class="meta">+                        | (mdiv &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                        | (pdiv &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                        | (sdiv &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* APLL_CON0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span>  ARM_CLK_800</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_MDIV  0x64</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_PDIV  0x03</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_SDIV  0x00</span></span><br><span class="line">+<span class="meta">#<span class="keyword">elif</span> defined ARM_CLK_1000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_MDIV  0x7D</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_PDIV  0x03</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_SDIV  0x00</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_CON0_VAL   SET_PLL(APLL_MDIV, APLL_PDIV, APLL_SDIV)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* APLL_LOCK */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_LOCK_VAL   (APLL_PDIV * 270)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* APLL_CON1 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_DCC_ENB    0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_AFC_ENB    0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_LOCK_CON_IN     0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_LOCK_CON_DLY    0x8</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APLL_CON1_VAL   ((APLL_DCC_ENB &lt;&lt; 21) \</span></span><br><span class="line"><span class="meta">+                    | (APLL_AFC_ENB &lt;&lt; 20) \</span></span><br><span class="line"><span class="meta">+                    | (APLL_LOCK_CON_IN &lt;&lt; 12) \</span></span><br><span class="line"><span class="meta">+                    | (APLL_LOCK_CON_DLY &lt;&lt; 8))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* MPLL_CON0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_MDIV   0x64</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_PDIV   0x03</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_SDIV   0x00</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_CON0_VAL   SET_PLL(MPLL_MDIV, MPLL_PDIV, MPLL_SDIV)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* MPLL_LOCK */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_LOCK_VAL   (MPLL_PDIV * 2700)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* MPLL_CON1 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_DCC_ENB 0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_AFC_ENB 0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_LOCK_CON_IN     0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_LOCK_CON_DLY    0x8</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MPLL_CON1_VAL   ((MPLL_DCC_ENB &lt;&lt; 21) \</span></span><br><span class="line"><span class="meta">+                    | (MPLL_AFC_ENB &lt;&lt; 20) \</span></span><br><span class="line"><span class="meta">+                    | (MPLL_LOCK_CON_IN &lt;&lt; 12) \</span></span><br><span class="line"><span class="meta">+                    | (MPLL_LOCK_CON_DLY &lt;&lt; 8))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* EPLL_CON0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_MDIV   0x40</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_PDIV   0x02</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_SDIV   0x02</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_CON0_VAL   SET_PLL(EPLL_MDIV, EPLL_PDIV, EPLL_SDIV)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* EPLL_LOCK */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_LOCK_VAL   (EPLL_PDIV * 3000)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* EPLL_CON1 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_SEL_PF  0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_MRR     0x6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_MFR     0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_CON1_VAL   ((EPLL_SEL_PF &lt;&lt; 29) \</span></span><br><span class="line"><span class="meta">+                    | (EPLL_MRR &lt;&lt; 24) \</span></span><br><span class="line"><span class="meta">+                    | (EPLL_MFR &lt;&lt; 16))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* EPLL_CON2 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_DCC_ENB 0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_AFC_ENB 0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_FVCO_EN 0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_LOCK_CON_IN     0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_LOCK_OUT_DLY    0x8</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> EPLL_CON2_VAL   (EPLL_DCC_ENB &lt;&lt; 7)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* VPLL_CON0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_MDIV   0xAF</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_PDIV   0x03</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_SDIV   0x02</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_CON0_VAL   SET_PLL(VPLL_MDIV, VPLL_PDIV, VPLL_SDIV)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* VPLL_LOCK */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_LOCK_VAL   (VPLL_PDIV * 3000)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* VPLL_CON1 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_SEL_PF  0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_MRR     0x6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_MFR     0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_CON1_VAL   ((VPLL_SEL_PF &lt;&lt; 29) \</span></span><br><span class="line"><span class="meta">+                    | (VPLL_MRR &lt;&lt; 24) \</span></span><br><span class="line"><span class="meta">+                    | (VPLL_MFR &lt;&lt; 16))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* VPLL_CON2 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_DCC_ENB 0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_AFC_ENB 0x0</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_FVCO_EN 0x1</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_LOCK_CON_IN     0x3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_LOCK_OUT_DLY    0x8</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> VPLL_CON2_VAL   (VPLL_DCC_ENB &lt;&lt; 7)</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_SRC_PERIL0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART4_SEL_SCLKMPLL_USER_T   6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART3_SEL_SCLKMPLL_USER_T   6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART2_SEL_SCLKMPLL_USER_T   6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART1_SEL_SCLKMPLL_USER_T   6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART0_SEL_SCLKMPLL_USER_T   6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_PERIL0_VAL  ((UART4_SEL_SCLKMPLL_USER_T &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (UART3_SEL_SCLKMPLL_USER_T &lt;&lt; 12) \</span></span><br><span class="line"><span class="meta">+                    | (UART2_SEL_SCLKMPLL_USER_T &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                    | (UART1_SEL_SCLKMPLL_USER_T &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                    | (UART0_SEL_SCLKMPLL_USER_T &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_PERIL0 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART4_RATIO     7</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART3_RATIO     7</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART2_RATIO     7</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART1_RATIO     7</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> UART0_RATIO     7</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_PERIL0_VAL  ((UART4_RATIO &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (UART3_RATIO &lt;&lt; 12) \</span></span><br><span class="line"><span class="meta">+                    | (UART2_RATIO &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                    | (UART1_RATIO &lt;&lt; 4) \</span></span><br><span class="line"><span class="meta">+                    | (UART0_RATIO &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_SRC_FSYS */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MMC4_SEL        6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MMC2_SEL        6</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_SRC_FSYS_VAL    ((MMC4_SEL &lt;&lt; 16) \</span></span><br><span class="line"><span class="meta">+                    | (MMC2_SEL &lt;&lt; 8))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_FSYS2 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MMC2_RATIO      0x7</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MMC2_PRE_RATIO  0x4</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_FSYS2_VAL   ((MMC2_PRE_RATIO &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                        | (MMC2_RATIO &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* CLK_DIV_FSYS3 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MMC4_RATIO      0x7</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MMC4_PRE_RATIO  0x4</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_DIV_FSYS3_VAL   ((MMC4_PRE_RATIO &lt;&lt; 8) \</span></span><br><span class="line"><span class="meta">+                        | (MMC4_RATIO &lt;&lt; 0))</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* DMC */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DIRECT_CMD_NOP	0x07000000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DIRECT_CMD_ZQ	0x0a000000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DIRECT_CMD_CHIP1_SHIFT	(1 &lt;&lt; 20)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MEM_TIMINGS_MSR_COUNT	4</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_START	(1 &lt;&lt; 0)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_DLL_ON	(1 &lt;&lt; 1)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> AREF_EN		(1 &lt;&lt; 5)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DRV_TYPE	(1 &lt;&lt; 6)</span></span><br><span class="line">+</span><br><span class="line">+<span class="keyword">struct</span> mem_timings &#123;</span><br><span class="line">+	<span class="type">unsigned</span> direct_cmd_msr[MEM_TIMINGS_MSR_COUNT];</span><br><span class="line">+	<span class="type">unsigned</span> timingref;</span><br><span class="line">+	<span class="type">unsigned</span> timingrow;</span><br><span class="line">+	<span class="type">unsigned</span> timingdata;</span><br><span class="line">+	<span class="type">unsigned</span> timingpower;</span><br><span class="line">+	<span class="type">unsigned</span> zqcontrol;</span><br><span class="line">+	<span class="type">unsigned</span> control0;</span><br><span class="line">+	<span class="type">unsigned</span> control1;</span><br><span class="line">+	<span class="type">unsigned</span> control2;</span><br><span class="line">+	<span class="type">unsigned</span> concontrol;</span><br><span class="line">+	<span class="type">unsigned</span> prechconfig;</span><br><span class="line">+	<span class="type">unsigned</span> memcontrol;</span><br><span class="line">+	<span class="type">unsigned</span> memconfig0;</span><br><span class="line">+	<span class="type">unsigned</span> memconfig1;</span><br><span class="line">+	<span class="type">unsigned</span> dll_resync;</span><br><span class="line">+	<span class="type">unsigned</span> dll_on;</span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* MIU */</span></span><br><span class="line">+<span class="comment">/* MIU Config Register Offsets*/</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APB_SFR_INTERLEAVE_CONF_OFFSET	0x400</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APB_SFR_ARBRITATION_CONF_OFFSET 0xC00</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">/* Interleave: 2Bit, Interleave_bit1: 0x15, Interleave_bit0: 0x7 */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APB_SFR_INTERLEAVE_CONF_VAL	0x20001507</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> APB_SFR_ARBRITATION_CONF_VAL	0x00000001</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> FORCE_DLL_RESYNC	3</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DLL_CONTROL_ON		1</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DIRECT_CMD1	0x00020000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DIRECT_CMD2	0x00030000</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DIRECT_CMD3	0x00010002</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DIRECT_CMD4	0x00000328</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_MODE_NOTERM	(0x1 &lt;&lt; 0)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_START		(0x1 &lt;&lt; 1)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_DIV		(0 &lt;&lt; 4)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_X4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_MODE_DDS	(0x5 &lt;&lt; 8)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_MODE_TERM	(0x2 &lt;&lt; 11)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_FORCE_IMPN	(0x5 &lt;&lt; 14)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_FORCE_IMPP	(0x2 &lt;&lt; 17)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITOP4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_MODE_DDS     (0x7 &lt;&lt; 8)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_MODE_TERM	(0x2 &lt;&lt; 11)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_FORCE_IMPN	(0x5 &lt;&lt; 14)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_ZQ_FORCE_IMPP	(0x6 &lt;&lt; 17)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_DCC		(0xE38 &lt;&lt; 20)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ZQ_CONTROL_VAL		(CTRL_ZQ_MODE_NOTERM | CTRL_ZQ_START\</span></span><br><span class="line"><span class="meta">+				| CTRL_ZQ_DIV | CTRL_ZQ_MODE_DDS\</span></span><br><span class="line"><span class="meta">+				| CTRL_ZQ_MODE_TERM | CTRL_ZQ_FORCE_IMPN\</span></span><br><span class="line"><span class="meta">+				| CTRL_ZQ_FORCE_IMPP | CTRL_DCC)</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_RATIO		(1 &lt;&lt; 1)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DIV_PIPE		(1 &lt;&lt; 3)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> AWR_ON			(1 &lt;&lt; 4)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> AREF_DISABLE		(0 &lt;&lt; 5)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_X4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DRV_TYPE_DISABLE	(3 &lt;&lt; 6)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITOP4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DRV_TYPE_DISABLE	(0 &lt;&lt; 6)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP0_NOT_EMPTY		(0 &lt;&lt; 8)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP1_NOT_EMPTY		(0 &lt;&lt; 9)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DQ_SWAP_DISABLE		(0 &lt;&lt; 10)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> QOS_FAST_DISABLE	(0 &lt;&lt; 11)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> RD_FETCH		(0x3 &lt;&lt; 12)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TIMEOUT_LEVEL0		(0xFFF &lt;&lt; 16)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONCONTROL_VAL		(CLK_RATIO | DIV_PIPE | AWR_ON\</span></span><br><span class="line"><span class="meta">+				| AREF_DISABLE | DRV_TYPE_DISABLE\</span></span><br><span class="line"><span class="meta">+				| CHIP0_NOT_EMPTY | CHIP1_NOT_EMPTY\</span></span><br><span class="line"><span class="meta">+				| DQ_SWAP_DISABLE | QOS_FAST_DISABLE\</span></span><br><span class="line"><span class="meta">+				| RD_FETCH | TIMEOUT_LEVEL0)</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CLK_STOP_DISABLE	(0 &lt;&lt; 0)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DPWRDN_DISABLE		(0 &lt;&lt; 1)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DPWRDN_TYPE		(0 &lt;&lt; 2)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TP_DISABLE		(0 &lt;&lt; 4)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DSREF_DIABLE		(0 &lt;&lt; 5)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_X4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ADD_LAT_PALL		(0 &lt;&lt; 6)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITOP4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> ADD_LAT_PALL		(1 &lt;&lt; 6)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MEM_TYPE_DDR3		(0x6 &lt;&lt; 8)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MEM_WIDTH_32		(0x2 &lt;&lt; 12)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> NUM_CHIP_2		(0 &lt;&lt; 16)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> BL_8			(0x3 &lt;&lt; 20)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MEMCONTROL_VAL		(CLK_STOP_DISABLE | DPWRDN_DISABLE\</span></span><br><span class="line"><span class="meta">+				| DPWRDN_TYPE | TP_DISABLE | DSREF_DIABLE\</span></span><br><span class="line"><span class="meta">+				| ADD_LAT_PALL | MEM_TYPE_DDR3 | MEM_WIDTH_32\</span></span><br><span class="line"><span class="meta">+				| NUM_CHIP_2 | BL_8)</span></span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP_BANK_8		(0x3 &lt;&lt; 0)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_X4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP_ROW    	(0x2 &lt;&lt; 4)  <span class="comment">/* 14 bits */</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITOP4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP_ROW        (0x3 &lt;&lt; 4) <span class="comment">/* 15 bits */</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP_COL_10		(0x3 &lt;&lt; 8)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP_MAP_INTERLEAVED	(1 &lt;&lt; 12)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP_MASK		(0xC0 &lt;&lt; 16)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP0_BASE		(0x40 &lt;&lt; 24)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CHIP1_BASE		(0x60 &lt;&lt; 24)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MEMCONFIG0_VAL		(CHIP_BANK_8 | CHIP_ROW | CHIP_COL_10\</span></span><br><span class="line"><span class="meta">+				| CHIP_MAP_INTERLEAVED | CHIP_MASK | CHIP0_BASE)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MEMCONFIG1_VAL		(CHIP_BANK_8 | CHIP_ROW | CHIP_COL_10\</span></span><br><span class="line"><span class="meta">+				| CHIP_MAP_INTERLEAVED | CHIP_MASK | CHIP1_BASE)</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_X4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TP_CNT          (0x64 &lt;&lt; 24)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITOP4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TP_CNT			(0xff &lt;&lt; 24)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> PRECHCONFIG		TP_CNT</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_OFF		(0 &lt;&lt; 0)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_DLL_OFF		(0 &lt;&lt; 1)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_HALF		(0 &lt;&lt; 2)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_DFDQS		(1 &lt;&lt; 3)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> DQS_DELAY		(0 &lt;&lt; 4)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_START_POINT	(0x10 &lt;&lt; 8)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_INC		(0x10 &lt;&lt; 16)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_FORCE		(0x71 &lt;&lt; 24)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONTROL0_VAL		(CTRL_OFF | CTRL_DLL_OFF | CTRL_HALF\</span></span><br><span class="line"><span class="meta">+				| CTRL_DFDQS | DQS_DELAY | CTRL_START_POINT\</span></span><br><span class="line"><span class="meta">+				| CTRL_INC | CTRL_FORCE)</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_SHIFTC		(0x6 &lt;&lt; 0)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_REF		(8 &lt;&lt; 4)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CTRL_SHGATE		(1 &lt;&lt; 29)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_X4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TERM_READ_EN		(0 &lt;&lt; 30)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TERM_WRITE_EN		(0 &lt;&lt; 31)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITOP4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TERM_READ_EN		(1 &lt;&lt; 30)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TERM_WRITE_EN		(1 &lt;&lt; 31)</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONTROL1_VAL		(CTRL_SHIFTC | CTRL_REF | CTRL_SHGATE\</span></span><br><span class="line"><span class="meta">+				| TERM_READ_EN | TERM_WRITE_EN)</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> CONTROL2_VAL		0x00000000</span></span><br><span class="line">+</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TIMINGREF_VAL		0x000000BB</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span>	TIMINGDATA_VAL		0x46400506</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span>	TIMINGPOWER_VAL		0x52000A3C</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_X4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TIMINGROW_VAL		0x7846654f</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ITOP4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> TIMINGROW_VAL		0x4046654f</span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EXYNOS4412 */</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h5 id="修改SoC时钟初始化相关的代码"><a href="#修改SoC时钟初始化相关的代码" class="headerlink" title="修改SoC时钟初始化相关的代码"></a>修改SoC时钟初始化相关的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-exynos/clock_init_exynos4.c b/arch/arm/mach-exynos/clock_init_exynos4.c</span><br><span class="line">index <span class="number">584e4</span>ba.<span class="number">.4</span>cb05fa <span class="number">100644</span></span><br><span class="line">--- a/arch/arm/mach-exynos/clock_init_exynos4.c</span><br><span class="line">+++ b/arch/arm/mach-exynos/clock_init_exynos4.c</span><br><span class="line">@@ <span class="number">-30</span>,<span class="number">12</span> +<span class="number">30</span>,<span class="number">17</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/clk.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/clock.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_setup.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exynos4412_setup.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exynos4_setup.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * system_clock_init: Initialize core clock and bus clock.</span></span><br><span class="line"><span class="comment">  * void system_clock_init(void)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifndef</span> CONFIG_EXYNOS4412</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">system_clock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">exynos4_clock</span> *<span class="title">clk</span> =</span></span><br><span class="line">@@ <span class="number">-92</span>,<span class="number">3</span> +<span class="number">97</span>,<span class="number">189</span> @@ <span class="type">void</span> <span class="title function_">system_clock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> </span><br><span class="line"> 	<span class="title function_">sdelay</span><span class="params">(<span class="number">0x30000</span>)</span>;</span><br><span class="line"> &#125;</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span> <span class="comment">/* !CONFIG_EXYNOS4412 */</span></span></span><br><span class="line">+<span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wait_mux_state</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> status, <span class="type">void</span> *addr)</span></span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="type">unsigned</span> <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">do</span> &#123;</span><br><span class="line">+        res = readl(addr);</span><br><span class="line">+    &#125;<span class="keyword">while</span>(status != res);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wait_pll_lock</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="type">unsigned</span> <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">do</span> &#123;</span><br><span class="line">+        res = readl(addr);</span><br><span class="line">+        res &gt;&gt;= <span class="number">29</span>;</span><br><span class="line">+    &#125;<span class="keyword">while</span>(!(res &amp; <span class="number">0x1</span>));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="type">void</span> <span class="title function_">system_clock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="class"><span class="keyword">struct</span> <span class="title">exynos4x12_clock</span> *<span class="title">clk</span> =</span></span><br><span class="line">+        (<span class="keyword">struct</span> exynos4x12_clock *)samsung_get_base_clock();</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * bypass PLLs and reset clock source of cpu</span></span><br><span class="line"><span class="comment">+     * MUX_MPLL_CTRL_USER_C:    select FINPLL:0</span></span><br><span class="line"><span class="comment">+     * MUX_HPM:                 select MOUTAPLL:0</span></span><br><span class="line"><span class="comment">+     * MUX_CORE:                select MOUTAPLL:0</span></span><br><span class="line"><span class="comment">+     * MUX_APLL:                select FINPLL:0</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(CLK_SRC_CPU_RESET, &amp;clk-&gt;src_cpu);</span><br><span class="line">+    wait_mux_state(CLK_MUX_STAT_CPU_RESET, &amp;clk-&gt;mux_stat_cpu);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * setup divisor of DMC clocks</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     * DIV_DMC0:</span></span><br><span class="line"><span class="comment">+     * DOUTDMC(SCLK_DMC) = MOUTDMC_BUS / (DMC_RATIO + 1) : DMC_RATIO:1</span></span><br><span class="line"><span class="comment">+     * DOUTDMCD(ACLK_DMCD) = DOUTDMC / (DMCD_RATIO + 1) : DMCD_RATIO:1</span></span><br><span class="line"><span class="comment">+     * DOUTDMCP(ACLK_DMCP) = DOUTDMCD/ (DMCP_RATIO + 1) : DMCP_RATIO:1</span></span><br><span class="line"><span class="comment">+     * DOUTACP(ACLK_ACP) = MOUTDMC_BUS / (ACP_RATIO + 1) : ACP_RATIO:3</span></span><br><span class="line"><span class="comment">+     * DOUTACP_PCLK(PCLK_ACP) = DOUTACP / (ACP_PCLK_RATIO + 1) : ACP_PCLK_RATIO:1</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     * For example:</span></span><br><span class="line"><span class="comment">+     * if MOUTDMC_BUS = 800MHz, then</span></span><br><span class="line"><span class="comment">+     *      SCLK_DMC = 400MHz</span></span><br><span class="line"><span class="comment">+     *      ACLK_DMCD = 200MHz</span></span><br><span class="line"><span class="comment">+     *      ACLK_DMCP = 100MHz</span></span><br><span class="line"><span class="comment">+     *      ACLK_ACP = 200MHz</span></span><br><span class="line"><span class="comment">+     *      PCLK_ACP = 100MHz</span></span><br><span class="line"><span class="comment">+     * fi</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(CLK_DIV_DMC0_VAL, &amp;clk-&gt;div_dmc0);</span><br><span class="line">+    writel(CLK_DIV_DMC1_VAL, &amp;clk-&gt;div_dmc1);</span><br><span class="line">+</span><br><span class="line">+	writel(CLK_SRC_TOP0_RESET, &amp;clk-&gt;src_top0);</span><br><span class="line">+    wait_mux_state(CLK_MUX_STAT_TOP0_RESET, &amp;clk-&gt;mux_stat_top0);</span><br><span class="line">+	writel(CLK_SRC_TOP1_RESET, &amp;clk-&gt;src_top1);</span><br><span class="line">+    wait_mux_state(CLK_MUX_STAT_TOP1_RESET, &amp;clk-&gt;mux_stat_top1);</span><br><span class="line">+    writel(CLK_DIV_TOP_VAL, &amp;clk-&gt;div_top);</span><br><span class="line">+</span><br><span class="line">+    writel(CLK_SRC_LEFTBUS_VAL, &amp;clk-&gt;src_leftbus);</span><br><span class="line">+    wait_mux_state(CLK_MUX_STAT_LEFTBUS_VAL, &amp;clk-&gt;mux_stat_leftbus);</span><br><span class="line">+    writel(CLK_DIV_LEFTBUS_VAL, &amp;clk-&gt;div_leftbus);</span><br><span class="line">+</span><br><span class="line">+    writel(CLK_SRC_RIGHTBUS_VAL, &amp;clk-&gt;src_rightbus);</span><br><span class="line">+    wait_mux_state(CLK_MUX_STAT_RIGHTBUS_VAL, &amp;clk-&gt;mux_stat_rightbus);</span><br><span class="line">+    writel(CLK_DIV_RIGHTBUS_VAL, &amp;clk-&gt;div_rightbus);</span><br><span class="line">+</span><br><span class="line">+    writel(APLL_LOCK_VAL, &amp;clk-&gt;apll_lock);</span><br><span class="line">+    writel(MPLL_LOCK_VAL, &amp;clk-&gt;mpll_lock);</span><br><span class="line">+    writel(EPLL_LOCK_VAL, &amp;clk-&gt;epll_lock);</span><br><span class="line">+    writel(VPLL_LOCK_VAL, &amp;clk-&gt;vpll_lock);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * DIV_CPU0:</span></span><br><span class="line"><span class="comment">+     * DOUTCORE = MOUTCORE/(CORE_RATIO + 1)</span></span><br><span class="line"><span class="comment">+     * DOUTCORE2 = DOUTCORE/(CORE2_RATE + 1)</span></span><br><span class="line"><span class="comment">+     * DOUTCOREM0 = DOUTCORE2/(COREM0_RATIO + 1)</span></span><br><span class="line"><span class="comment">+     * DOUTCOREM1 = DOUTCORE2/(COREM1_RATIO + 1)</span></span><br><span class="line"><span class="comment">+     * DOUTPERIPH = DOUTCORE2/(PERIPH_RATIO + 1)</span></span><br><span class="line"><span class="comment">+     * SCLK_APLL = MOUTAPLL/(APLL_RATIO + 1)</span></span><br><span class="line"><span class="comment">+     * DOUTATB = MOUTCORE/(ATB_RATIO + 1)</span></span><br><span class="line"><span class="comment">+     * DOUTPCLK_DBG = DOUTATB/PCLK_DBG_RATIO + 1)</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     * ---------------------------------------</span></span><br><span class="line"><span class="comment">+     *  MOUTAPLL        1000MHz     800MHz</span></span><br><span class="line"><span class="comment">+     * ---------------------------------------</span></span><br><span class="line"><span class="comment">+     *  ARMCLK          1000        8000</span></span><br><span class="line"><span class="comment">+     *  ACLK_COREM0     250         200</span></span><br><span class="line"><span class="comment">+     *  ACLK_CORES      250         200</span></span><br><span class="line"><span class="comment">+     *  ACLK_COREM1     125         100</span></span><br><span class="line"><span class="comment">+     *  PERIPHCLK       250         200</span></span><br><span class="line"><span class="comment">+     *  ATCLK           250         200</span></span><br><span class="line"><span class="comment">+     *  PCLK_DBG        125         100</span></span><br><span class="line"><span class="comment">+     * --------------------------------------</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(CLK_DIV_CPU0_VAL, &amp;clk-&gt;div_cpu0);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * DIV_CPU1:</span></span><br><span class="line"><span class="comment">+     * DOUTCOPY = MOUTHPM/(COPY_RATIO + 1)</span></span><br><span class="line"><span class="comment">+     * DOUTHPM = DOUTCOPY/(HPM_RATIO + 1)</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     * -------------------------------------</span></span><br><span class="line"><span class="comment">+     *  MOUTHPM         1000MHz     800MHz</span></span><br><span class="line"><span class="comment">+     * -------------------------------------</span></span><br><span class="line"><span class="comment">+     *  DOUTCOPY        333         266</span></span><br><span class="line"><span class="comment">+     *  SCLK_HPM        165         133</span></span><br><span class="line"><span class="comment">+     * -------------------------------------</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(CLK_DIV_CPU1_VAL, &amp;clk-&gt;div_cpu1);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * set APLL to 1000MHz or 800MHz</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(APLL_CON1_VAL, &amp;clk-&gt;apll_con1);</span><br><span class="line">+    writel(APLL_CON0_VAL, &amp;clk-&gt;apll_con0);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * always set MPLL to 800MHZ</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(MPLL_CON1_VAL, &amp;clk-&gt;mpll_con1);</span><br><span class="line">+    writel(MPLL_CON0_VAL, &amp;clk-&gt;mpll_con0);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * always set EPLL to 192MHz</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(EPLL_CON2_VAL, &amp;clk-&gt;epll_con2);</span><br><span class="line">+    writel(EPLL_CON1_VAL, &amp;clk-&gt;epll_con1);</span><br><span class="line">+    writel(EPLL_CON0_VAL, &amp;clk-&gt;epll_con0);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * always set VPLL to 350MHz</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(VPLL_CON2_VAL, &amp;clk-&gt;vpll_con2);</span><br><span class="line">+    writel(VPLL_CON1_VAL, &amp;clk-&gt;vpll_con1);</span><br><span class="line">+    writel(VPLL_CON0_VAL, &amp;clk-&gt;vpll_con0);</span><br><span class="line">+</span><br><span class="line">+    wait_pll_lock(&amp;clk-&gt;apll_con0);</span><br><span class="line">+    wait_pll_lock(&amp;clk-&gt;mpll_con0);</span><br><span class="line">+    wait_pll_lock(&amp;clk-&gt;epll_con0);</span><br><span class="line">+    wait_pll_lock(&amp;clk-&gt;vpll_con0);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * select clock source for CPU_BLK</span></span><br><span class="line"><span class="comment">+     * MUX_MPLL_CTRL_USER_C:    select SCLK_MPLL:1</span></span><br><span class="line"><span class="comment">+     * MUX_HPM:                 select MOUTAPLL:0</span></span><br><span class="line"><span class="comment">+     * MUX_CORE:                select MOUTAPLL:0</span></span><br><span class="line"><span class="comment">+     * MUX_APLL:                select FOUTAPLL:1</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(CLK_SRC_CPU_VAL, &amp;clk-&gt;src_cpu);</span><br><span class="line">+    wait_mux_state(CLK_MUX_STAT_CPU_VAL, &amp;clk-&gt;mux_stat_cpu);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">+     * select clock source for DMC_BLK</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(CLK_SRC_DMC_VAL, &amp;clk-&gt;src_dmc);</span><br><span class="line">+    wait_mux_state(CLK_MUX_STAT_DMC_VAL, &amp;clk-&gt;mux_stat_dmc);</span><br><span class="line">+    writel(CLK_SRC_TOP0_VAL, &amp;clk-&gt;src_top0);</span><br><span class="line">+    wait_mux_state(CLK_MUX_STAT_TOP0_VAL, &amp;clk-&gt;mux_stat_top0);</span><br><span class="line">+    writel(CLK_SRC_TOP1_VAL, &amp;clk-&gt;src_top1);</span><br><span class="line">+    wait_mux_state(CLK_MUX_STAT_TOP1_VAL, &amp;clk-&gt;mux_stat_top1);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* set UART clock for early debug</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     * UART0-3 = 100MHz</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(CLK_SRC_PERIL0_VAL, &amp;clk-&gt;src_peril0);</span><br><span class="line">+    writel(CLK_DIV_PERIL0_VAL, &amp;clk-&gt;div_peril0);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* MMC clock</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     * MMC2, MMC4 = 20MHz</span></span><br><span class="line"><span class="comment">+     *</span></span><br><span class="line"><span class="comment">+     */</span></span><br><span class="line">+    writel(CLK_SRC_FSYS_VAL, &amp;clk-&gt;src_fsys);</span><br><span class="line">+    writel(CLK_DIV_FSYS2_VAL, &amp;clk-&gt;div_fsys2);</span><br><span class="line">+    writel(CLK_DIV_FSYS3_VAL, &amp;clk-&gt;div_fsys3);</span><br><span class="line">+&#125;</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h5 id="修改外设控制器的时钟设置代码"><a href="#修改外设控制器的时钟设置代码" class="headerlink" title="修改外设控制器的时钟设置代码"></a>修改外设控制器的时钟设置代码</h5><p>结构体struct exynos4x12_clock与Exynos4412 SoC的时钟寄存器才是一致的，而结构体struct exynos4_clock是不一致的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-exynos/clock.c b/arch/arm/mach-exynos/clock.c</span><br><span class="line">index <span class="number">73</span>aa4cd..ae455ce <span class="number">100644</span></span><br><span class="line">--- a/arch/arm/mach-exynos/clock.c</span><br><span class="line">+++ b/arch/arm/mach-exynos/clock.c</span><br><span class="line">@@ <span class="number">-782</span>,<span class="number">8</span> +<span class="number">782</span>,<span class="number">13</span> @@ <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">exynos4x12_get_uart_clk</span><span class="params">(<span class="type">int</span> dev_index)</span></span><br><span class="line"> </span><br><span class="line"> <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">exynos4_get_mmc_clk</span><span class="params">(<span class="type">int</span> dev_index)</span></span><br><span class="line"> &#123;</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        <span class="class"><span class="keyword">struct</span> <span class="title">exynos4x12_clock</span> *<span class="title">clk</span> =</span></span><br><span class="line">+                (<span class="keyword">struct</span> exynos4x12_clock *)samsung_get_base_clock();</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">exynos4_clock</span> *<span class="title">clk</span> =</span></span><br><span class="line"> 		(<span class="keyword">struct</span> exynos4_clock *)samsung_get_base_clock();</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">long</span> uclk, sclk;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span> sel, ratio, pre_ratio;</span><br><span class="line"> 	<span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line">@@ <span class="number">-832</span>,<span class="number">8</span> +<span class="number">837</span>,<span class="number">13</span> @@ <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">exynos4_get_mmc_clk</span><span class="params">(<span class="type">int</span> dev_index)</span></span><br><span class="line"> <span class="comment">/* exynos4: set the mmc clock */</span></span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> <span class="title function_">exynos4_set_mmc_clk</span><span class="params">(<span class="type">int</span> dev_index, <span class="type">unsigned</span> <span class="type">int</span> div)</span></span><br><span class="line"> &#123;</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        <span class="class"><span class="keyword">struct</span> <span class="title">exynos4x12_clock</span> *<span class="title">clk</span> =</span></span><br><span class="line">+                (<span class="keyword">struct</span> exynos4x12_clock *)samsung_get_base_clock();</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">exynos4_clock</span> *<span class="title">clk</span> =</span></span><br><span class="line"> 		(<span class="keyword">struct</span> exynos4_clock *)samsung_get_base_clock();</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">int</span> addr, clear_bit, set_bit;</span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<h5 id="修改内存控制器初始化相关的代码"><a href="#修改内存控制器初始化相关的代码" class="headerlink" title="修改内存控制器初始化相关的代码"></a>修改内存控制器初始化相关的代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-exynos/dmc_init_exynos4.c b/arch/arm/mach-exynos/dmc_init_exynos4.c</span><br><span class="line">index ecddc72.<span class="number">.977e46</span>e <span class="number">100644</span></span><br><span class="line">--- a/arch/arm/mach-exynos/dmc_init_exynos4.c</span><br><span class="line">+++ b/arch/arm/mach-exynos/dmc_init_exynos4.c</span><br><span class="line">@@ <span class="number">-26</span>,<span class="number">7</span> +<span class="number">26</span>,<span class="number">11</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/dmc.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_setup.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exynos4412_setup.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exynos4_setup.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">mem_timings</span> <span class="title">mem</span> =</span> &#123;</span><br><span class="line"> 	.direct_cmd_msr = &#123;</span><br><span class="line">@@ <span class="number">-92</span>,<span class="number">7</span> +<span class="number">96</span>,<span class="number">11</span> @@ <span class="type">static</span> <span class="type">void</span> dmc_init(<span class="keyword">struct</span> exynos4_dmc *dmc)</span><br><span class="line"> 	 * Auto Calibration Start: Enable</span><br><span class="line"> 	 */</span><br><span class="line"> 	writel(mem.zqcontrol, &amp;dmc-&gt;phyzqcontrol);</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        sdelay(<span class="number">0x100</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	sdelay(<span class="number">0x100000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	 * Update DLL Information:</span></span><br><span class="line"><span class="comment">@@ -137,29 +145,57 @@ static void dmc_init(struct exynos4_dmc *dmc)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 	/* Chip0: NOP Command: Assert and Hold CKE to high level */</span></span><br><span class="line"> 	writel(DIRECT_CMD_NOP, &amp;dmc-&gt;directcmd);</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        sdelay(<span class="number">0x20000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	sdelay(<span class="number">0x100000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">/* Chip0: EMRS2, EMRS3, EMRS, MRS Commands Using Direct Command */</span></span><br><span class="line"> 	dmc_config_mrs(dmc, <span class="number">0</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        sdelay(<span class="number">0x200</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	sdelay(<span class="number">0x100000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">/* Chip0: ZQINIT */</span></span><br><span class="line"> 	writel(DIRECT_CMD_ZQ, &amp;dmc-&gt;directcmd);</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        sdelay(<span class="number">0x200</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	sdelay(<span class="number">0x100000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> 	writel((DIRECT_CMD_NOP | DIRECT_CMD_CHIP1_SHIFT), &amp;dmc-&gt;directcmd);</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        sdelay(<span class="number">0x20000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	sdelay(<span class="number">0x100000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">/* Chip1: EMRS2, EMRS3, EMRS, MRS Commands Using Direct Command */</span></span><br><span class="line"> 	dmc_config_mrs(dmc, <span class="number">1</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        sdelay(<span class="number">0x200</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	sdelay(<span class="number">0x100000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">/* Chip1: ZQINIT */</span></span><br><span class="line"> 	writel((DIRECT_CMD_ZQ | DIRECT_CMD_CHIP1_SHIFT), &amp;dmc-&gt;directcmd);</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        sdelay(<span class="number">0x200</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	sdelay(<span class="number">0x100000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> 	phy_control_reset(<span class="number">1</span>, dmc);</span><br><span class="line">+<span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS4412</span></span><br><span class="line">+        sdelay(<span class="number">0x200</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> 	sdelay(<span class="number">0x100000</span>);</span><br><span class="line">+<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">/* turn on DREX0, DREX1 */</span></span><br><span class="line"> 	writel((mem.concontrol | AREF_EN), &amp;dmc-&gt;concontrol);</span><br><span class="line">@@ <span class="number">-175</span>,<span class="number">7</span> +<span class="number">211</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="title function_">mem_ctrl_init</span><span class="params">(<span class="type">int</span> reset)</span></span><br><span class="line"> 	 * 0: full_sync</span><br><span class="line"> 	 */</span><br><span class="line"> 	<span class="title function_">writel</span><span class="params">(<span class="number">1</span>, ASYNC_CONFIG)</span>;</span><br><span class="line">-<span class="meta">#<span class="keyword">ifdef</span> CONFIG_ORIGEN</span></span><br><span class="line">+<span class="meta">#<span class="keyword">if</span> defined (CONFIG_ORIGEN) || defined (CONFIG_EXYNOS4412)</span></span><br><span class="line"> 	<span class="comment">/* Interleave: 2Bit, Interleave_bit1: 0x15, Interleave_bit0: 0x7 */</span></span><br><span class="line"> 	writel(APB_SFR_INTERLEAVE_CONF_VAL, EXYNOS4_MIU_BASE +</span><br><span class="line"> 		APB_SFR_INTERLEAVE_CONF_OFFSET);</span><br></pre></td></tr></table></figure>

<h3 id="编译烧写与调试验证"><a href="#编译烧写与调试验证" class="headerlink" title="编译烧写与调试验证"></a>编译烧写与调试验证</h3><p>至此，整个移植过程涉及的代码及配置文件已经全部给出了，你只要将上面patch应用到自己的源代码上或者是使用<code>git clone https://github.com/chasinglulu/u-boot.git</code>拷贝我已经移植好代码，就完成了基本的移植过程。下面通过验证调试来检验我们在移植过程中有没有出错或者出现其他异常，通过调试并发现解决问题才是我们升级打怪（bug）和提升能力的最佳时刻。</p>
<h4 id="编译烧写"><a href="#编译烧写" class="headerlink" title="编译烧写"></a>编译烧写</h4><p>编译命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make O=../build/ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- itop4412_defconfig</span><br><span class="line">make O=../build/ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4</span><br></pre></td></tr></table></figure>

<p>烧写脚本<code>fusing-sd.sh</code>的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">CUR_DIR=$(<span class="built_in">cd</span> $(<span class="built_in">dirname</span> <span class="string">&quot;<span class="variable">$0</span>&quot;</span>); <span class="built_in">pwd</span>)</span><br><span class="line">IMAGE_DIR=<span class="string">&quot;&quot;</span></span><br><span class="line">DEVICE=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># images name</span></span><br><span class="line">BL1_FWBL_IMG=<span class="string">&quot;itop4412-fwbl.bin&quot;</span></span><br><span class="line">BL1_SPL_IMG=<span class="string">&quot;itop4412-spl.bin&quot;</span></span><br><span class="line">BL2_UBOOT_IMG=<span class="string">&quot;itop4412-u-boot.bin&quot;</span></span><br><span class="line">TZSW_IMG=<span class="string">&quot;itop4412-tzsw.bin&quot;</span></span><br><span class="line">ENV_IMG=<span class="string">&quot;itop4412-env.bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># itop4412 images position</span></span><br><span class="line">BL1_FWBL_POS=1</span><br><span class="line">BL1_SPL_POS=17</span><br><span class="line">BL2_UBOOT_POS=49</span><br><span class="line">TZSW_POS=1073</span><br><span class="line">ENV_POS=1385</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Usage:&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;    <span class="subst">$(basename $0)</span> [/dev/sdX] [image-dir]&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;    /dev/sdX    device file for sd card&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;    image-dir   image direction, optional&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bl1_fwbl_fusing</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;BL1_FWBL fusing ...&quot;</span></span><br><span class="line">	<span class="built_in">dd</span> iflag=dsync oflag=dsync <span class="keyword">if</span>=<span class="variable">$IMAGE_DIR</span>/<span class="variable">$BL1_FWBL_IMG</span> of=<span class="variable">$DEVICE</span> seek=<span class="variable">$BL1_FWBL_POS</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Finish fusing BL1_FWBL image.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bl1_spl_fusing</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;BL1_SPL fusing ...&quot;</span></span><br><span class="line">	<span class="built_in">dd</span> iflag=dsync oflag=dsync <span class="keyword">if</span>=<span class="variable">$IMAGE_DIR</span>/<span class="variable">$BL1_SPL_IMG</span> of=<span class="variable">$DEVICE</span> seek=<span class="variable">$BL1_SPL_POS</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Finish fusing BL1_SPL image.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bl2_uboot_fusing</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;BL2_UBOOT fusing ...&quot;</span></span><br><span class="line">	<span class="built_in">dd</span> iflag=dsync oflag=dsync <span class="keyword">if</span>=<span class="variable">$IMAGE_DIR</span>/<span class="variable">$BL2_UBOOT_IMG</span> of=<span class="variable">$DEVICE</span> seek=<span class="variable">$BL2_UBOOT_POS</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Finish fusing BL2_UBOOT image.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">tzsw_fusing</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;TZSW fusing ...&quot;</span></span><br><span class="line">	<span class="built_in">dd</span> iflag=dsync oflag=dsync <span class="keyword">if</span>=<span class="variable">$IMAGE_DIR</span>/<span class="variable">$TZSW_IMG</span> of=<span class="variable">$DEVICE</span> seek=<span class="variable">$TZSW_POS</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Finish fusing TZSW image.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">env_fusing</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;ENV fusing ...&quot;</span></span><br><span class="line">	<span class="built_in">dd</span> iflag=dsync oflag=dsync <span class="keyword">if</span>=<span class="variable">$IMAGE_DIR</span>/<span class="variable">$ENV_IMG</span> of=<span class="variable">$DEVICE</span> seek=<span class="variable">$ENV_POS</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Finish fusing ENV image.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;--------------------------[Begin]--------------------------&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;May take a few minutes, wait ...&quot;</span></span><br><span class="line">	bl1_fwbl_fusing</span><br><span class="line">	bl1_spl_fusing</span><br><span class="line">	bl2_uboot_fusing</span><br><span class="line">	tzsw_fusing</span><br><span class="line">	env_fusing</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;--------------------------[End]----------------------------&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :h opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">		h)</span><br><span class="line">			usage <span class="variable">$0</span></span><br><span class="line">			<span class="built_in">exit</span> 0</span><br><span class="line">			;;</span><br><span class="line">		?)</span><br><span class="line">			<span class="built_in">echo</span> <span class="string">&quot;unknown option&quot;</span></span><br><span class="line">			;;</span><br><span class="line">	<span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -le 0 ] || [ <span class="variable">$#</span> -ge 3 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;arguments too few or many.&quot;</span></span><br><span class="line">	usage <span class="variable">$0</span></span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	DEVICE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="variable">$#</span> -eq 2 ]</span><br><span class="line">	<span class="keyword">then</span></span><br><span class="line">		IMAGE_DIR=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		IMAGE_DIR=<span class="string">&quot;<span class="variable">$CUR_DIR</span>&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -b <span class="string">&quot;<span class="variable">$DEVICE</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$DEVICE</span> is identified.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$DEVICE</span> is NOT device file.&quot;</span></span><br><span class="line">    <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=<span class="variable">$DEVICE</span> bs=512 count=2048</span><br><span class="line">    BL1_FWBL_POS=0</span><br><span class="line">    BL1_SPL_POS=16</span><br><span class="line">    BL2_UBOOT_POS=48</span><br><span class="line">    TZSW_POS=1072</span><br><span class="line">    ENV_POS=1384</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">main</span><br><span class="line"></span><br><span class="line"><span class="built_in">sync</span>;<span class="built_in">sync</span>;<span class="built_in">sync</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>烧写命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh fusing-sd.sh /dev/sdX</span><br><span class="line">or</span><br><span class="line">sh fusing-sd.sh /dev/sdX ~/exynos4412/images/</span><br></pre></td></tr></table></figure>
<p><code>/dev/sdX</code>指的是SD卡在Ubuntu 18.04系统内的设备描述符，具体的说，用sda、sdb、sdc等替代sdX。</p>
<h4 id="调试与验证"><a href="#调试与验证" class="headerlink" title="调试与验证"></a>调试与验证</h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      <categories>
        <category>u-boot</category>
      </categories>
      <tags>
        <tag>uboot</tag>
        <tag>arm-linux-gnueabihf-gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Qemu搭建Xen on ARM开发环境</title>
    <url>/posts/8ef16649/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>u-boot</tag>
        <tag>linux</tag>
        <tag>ATF</tag>
        <tag>eMMC</tag>
        <tag>Xen</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Qemu LMT虚拟平台的bringup</title>
    <url>/posts/61970ccf/</url>
    <content><![CDATA[<p>在芯片开发的前期，RTL代码还在开发中，FPGA原型验证平台也没有可用的环境。这时候我们可以根据SoC spec在Qemu中开发一个新的Virtual Platform，那么BSP软件团队就可以提前完成一些软件环境的准备，比如最小系统。这样当RTL0.1释放后，我们可以直接复用这些软件在FPGA验证，从而减小搭建软件环境的压力和缩小验证时间。随着Qemu里面模拟的外设越来越多，我们可以把更多的软件function在Qemu里面完成开发和验证，然后再迁移到FPGA原型平台上进行验证，从而完善软件的时序方面的逻辑。通过这样的验证手段，让我们软件准备提前，缩短FPGA的占用时间，减少验证成本。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Qemu:</strong> v7.2.0</li>
<li><strong>U-Boot:</strong> v2022.10</li>
<li><strong>ATF:</strong> v2.10</li>
<li><strong>OPTEE:</strong> v4.0.0</li>
<li><strong>Linux Kernel:</strong> linux-6.1.12</li>
<li><strong>aarch64-none-linux-gnu-gcc:</strong> 10.3.1 20210621</li>
<li><strong>riscv32-unknown-linux-gnu-gcc:</strong> 12.2.0</li>
</ul>
<hr>
<h3 id="芯片介绍"><a href="#芯片介绍" class="headerlink" title="芯片介绍"></a>芯片介绍</h3><p><img data-src="/images/29/lmt-arch.png" alt="lmt-arch"></p>
<center>图1 lmt芯片的架构</center>
如上图所示，展示了芯片产品的框图，左边是基于ARM的主域，右边是基于RISC-V的从域。这样的芯片架构是目前很多自动驾驶ADAS芯片的解决方案，通过MCU Domain来实现芯片的故障诊断、甚至承接一部分车规相关的规控功能。


<p>芯片是异构系统架构的，包含两种指令集CPU（ARM和RISC-V），因此我们在Qemu里面添加了两个machine：lmt-virt和lmt-safety-virt，前者用于模拟ARM系统部分，后面用于模拟RISC-V系统部分，最后通过Qemu里面的共享内存和chardev socket实现两个machine的联动（multi-process Qemu的交互）。</p>
<p><img data-src="/images/29/mult-process-qemu.png" alt="mult-process-qemu"></p>
<center>图2 multi-process QEMU的架构</center>


<h3 id="启动介绍"><a href="#启动介绍" class="headerlink" title="启动介绍"></a>启动介绍</h3><p>在运行起来之前，我们先明确最小系统涉及的组件以及它们的启动顺序</p>
<ul>
<li>ATF：提供EL3 runtime service，具有整个硬件系统的全部权限</li>
<li>OPTEE：提供可信执行环境</li>
<li>SPL：完成Bootloader镜像的加载，以及DDR、Clock等初始化</li>
<li>U-Boot：加载和启动不同OS的镜像</li>
<li>Kernel：Linux kernel OS，常用的OS</li>
<li>initramfs：最小的文件系统，用作临时跳转</li>
<li>Ubuntu Rootfs：根文件系统，存放在存储介质上，里面包含很多应用、库和工具</li>
</ul>
<h4 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h4><p><img data-src="/images/29/lmt-bootflow.png" alt="lmt-bootflow"></p>
<center>图3 启动流程</center>

<ul>
<li>SPL将BL31 ATF、BL32 OPTEE和BL33 U-Boot三个镜像加载到DDR，将RISC-V Firmware加载到Safety SRAM中，然后跳转到BL31 ATF执行</li>
<li>ATF完成基本的初始化，然后跳转到BL32 OPTEE执行</li>
<li>OPTEE完成基本的初始化，然后返回到ATF的执行环境中，最后ATF直接跳转到U-Boot执行</li>
<li>U-Boot完成初始化，外设的初始化，从eMMC&#x2F;Nor Flash等媒介中加载Kernel、initramfs和dtb等镜像文件，然后跳转到Kernel开始执行</li>
<li>Kernel完成启动初始化，拉起应用程序</li>
</ul>
<h3 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h3><h4 id="ATF"><a href="#ATF" class="headerlink" title="ATF"></a>ATF</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b atf-v2.10 https://github.com/chasinglulu/arm-trusted-firmware.git</span><br><span class="line">cd arm-trusted-firmware</span><br><span class="line">make PLAT=lmt CROSS_COMPILE=aarch64-none-linux-gnu-</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">make PLAT=lmt CROSS_COMPILE=aarch64-none-linux-gnu- DEBUG=1 #debug</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">make PLAT=lmt CROSS_COMPILE=aarch64-none-linux-gnu- DEBUG=1 LOG_LEVEL=50 #verbose mode</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">make PLAT=lmt CROSS_COMPILE=aarch64-none-linux-gnu- SPD=opteed #with BL32 optee</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="OPTEE"><a href="#OPTEE" class="headerlink" title="OPTEE"></a>OPTEE</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b optee_os-4.0.0 https://github.com/chasinglulu/optee_os.git</span><br><span class="line">cd optee_os</span><br><span class="line">export ARCH=arm</span><br><span class="line"></span><br><span class="line">make CROSS_COMPILE64=aarch64-none-linux-gnu- CROSS_COMPILE_ta_arm64=aarch64-none-linux-gnu- CROSS_COMPILE_ta_arm32=arm-linux-gnueabi- PLATFORM=ax-lmt</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">make CROSS_COMPILE64=aarch64-none-linux-gnu- CROSS_COMPILE_ta_arm64=aarch64-none-linux-gnu- CROSS_COMPILE_ta_arm32=arm-linux-gnueabi- PLATFORM=ax-lmt DEBUG=1  #debug</span><br></pre></td></tr></table></figure>

<h4 id="U-Boot"><a href="#U-Boot" class="headerlink" title="U-Boot"></a>U-Boot</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b uboot-2022.10 https://github.com/chasinglulu/u-boot.git</span><br><span class="line">cd u-boot</span><br><span class="line">make CROSS_COMPILE=aarch64-none-linux-gnu- ARCH=arm64 lmt-qemu-virt_defconfig</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<h4 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b linux-v6.1-rt https://github.com/chasinglulu/linux.git</span><br><span class="line">cd linux</span><br><span class="line">make CROSS_COMPILE=aarch64-none-linux-gnu- ARCH=arm64 lmt-tiny_defconfig</span><br><span class="line">make -j64</span><br></pre></td></tr></table></figure>


<h3 id="lmt-virt运行验证"><a href="#lmt-virt运行验证" class="headerlink" title="lmt-virt运行验证"></a>lmt-virt运行验证</h3><h4 id="启动U-Boot-Kernel"><a href="#启动U-Boot-Kernel" class="headerlink" title="启动U-Boot+Kernel"></a>启动U-Boot+Kernel</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M lmt-virt,virt=on,emmc=on -m 4G -display none -device loader,addr=0x400200000,file=/path/to/u-boot/u-boot.bin,cpu-num=0 -drive file=/path/to/emmc.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>

<p><code>virt=on</code>：使能CPU的EL2<br><code>secure=off</code>：关闭CPU的EL3<br><code>emmc=on</code>：使能eMMC模拟支持</p>
<p>U-Boot既可以运行在EL2也可以运行在EL3上，但是打开EL3的时候，需要运行ATF，不然Kernel发起PSCI访问会触发panic。</p>
<p><img data-src="/images/29/uboot_kernel.gif" alt="uboot_kernel"></p>
<p>启动日志附件：<a href="/images/29/uboot_kernel.txt">U-Boot-&gt;kernel Booting</a></p>
<h4 id="启动SPL-U-Boot-Kernel"><a href="#启动SPL-U-Boot-Kernel" class="headerlink" title="启动SPL+U-Boot+Kernel"></a>启动SPL+U-Boot+Kernel</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M lmt-virt,virt=on,secure=on,emmc=on -m 4G -display none -device loader,addr=0x00,file=/path/to/u-boot/spl/u-boot-spl.bin,cpu-num=0 -device loader,addr=0x400200000,file=/path/to/u-boot/u-boot.img -drive file=/path/to/emmc.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>
<p><code>virt=on</code>：使能CPU的EL2<br><code>secure=on</code>：使能CPU的EL3<br><code>emmc=on</code>：使能eMMC模拟支持</p>
<p>因为SPL和U-Boot既可以运行在EL2也可以运行在EL3，因此<code>virt=</code>和<code>secure=</code>两个选项既可以<code>on</code>也可以<code>off</code>，两个选项可以随意组合，用于验证不同的使用场景。</p>
<p><code>secure=off</code>：关闭CPU的EL3，Kernel下的PSCI访问请求都由Qemu捕获进行处理。如果使能EL3，必须运行ATF软件，不然Kernel发出PSCI请求会触发panic。</p>
<p><img data-src="/images/29/spl_uboot_kernel.gif" alt="spl_uboot_kernel"></p>
<p>启动日志附件：<a href="/images/29/spl_uboot_kernel.txt">ATF-&gt;U-Boot-&gt;kernel Booting</a></p>
<h4 id="启动ATF-U-Boot-Kernel"><a href="#启动ATF-U-Boot-Kernel" class="headerlink" title="启动ATF+U-Boot+Kernel"></a>启动ATF+U-Boot+Kernel</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M lmt-virt,virt=on,secure=on,emmc=on -m 4G -display none -device loader,addr=0x400104000,file=/path/to/arm-trusted-firmware/build/lmt/release/bl31.bin,cpu-num=0 -device loader,addr=0x400200000,file=/path/to/u-boot/u-boot.bin -drive file=/path/to/emmc.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>
<p><code>virt=on</code>：使能CPU的EL2<br><code>secure=on</code>：使能CPU的EL3<br><code>emmc=on</code>：使能eMMC模拟支持</p>
<p><img data-src="/images/29/atf_uboot_kernel.gif" alt="atf_uboot_kernel"></p>
<p>启动日志附件：<a href="/images/29/atf_uboot_kernel.txt">ATF-&gt;U-Boot-&gt;kernel Booting</a></p>
<h4 id="启动SPL-ATF-U-Boot-Kernel"><a href="#启动SPL-ATF-U-Boot-Kernel" class="headerlink" title="启动SPL+ATF+U-Boot+Kernel"></a>启动SPL+ATF+U-Boot+Kernel</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M lmt-virt,virt=on,secure=on,emmc=on -m 4G -display none -device loader,addr=0x0,file=/path/to/u-boot/spl/u-boot-spl.bin,cpu-num=0 -device loader,addr=0x400104000,file=/path/to/arm-trusted-firmware/build/lmt/release/bl31.bin -device loader,addr=0x400200000,file=/path/to/u-boot/u-boot.bin -drive file=/path/to/emmc.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>

<p><code>virt=on</code>：使能CPU的EL2<br><code>secure=on</code>：使能CPU的EL3<br><code>emmc=on</code>：使能eMMC模拟支持</p>
<p><img data-src="/images/29/spl_atf_uboot_kernel.gif" alt="spl_atf_uboot_kernel"></p>
<p>启动日志附件：<a href="/images/29/spl_atf_uboot_kernel.txt">SPL-&gt;ATF-&gt;U-Boot-&gt;kernel Booting</a></p>
<h4 id="启动ATF-OPTEE-U-Boot-Kernel"><a href="#启动ATF-OPTEE-U-Boot-Kernel" class="headerlink" title="启动ATF+OPTEE+U-Boot+Kernel"></a>启动ATF+OPTEE+U-Boot+Kernel</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M lmt-virt,virt=on,secure=on,emmc=on -m 4G -display none -device loader,addr=0x400104000,file=/path/to/arm-trusted-firmware/build/lmt/release/bl31.bin,cpu-num=0 -device loader,addr=0x400200000,file=/path/to/u-boot/u-boot.bin -device loader,addr=0x404000000,file=/path/to/optee_os/out/arm-plat-ax/core/tee-pager_v2.bin -drive file=/path/to/emmc.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>
<p><code>virt=on</code>：使能CPU的EL2<br><code>secure=on</code>：使能CPU的EL3<br><code>emmc=on</code>：使能eMMC模拟支持</p>
<p><img data-src="/images/29/atf_optee_uboot_kernel.gif" alt="atf_optee_uboot_kernel"></p>
<p>启动日志附件：<a href="/images/29/atf_optee_uboot_kernel.txt">ATF-&gt;OPTEE-&gt;U-Boot-&gt;kernel Booting</a></p>
<h4 id="启动SPL-ATF-OPTEE-U-Boot-Kernel"><a href="#启动SPL-ATF-OPTEE-U-Boot-Kernel" class="headerlink" title="启动SPL+ATF+OPTEE+U-Boot+Kernel"></a>启动SPL+ATF+OPTEE+U-Boot+Kernel</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M lmt-virt,virt=on,secure=on,emmc=on -m 4G -display none -device loader,addr=0x0,file=/path/to/u-boot/spl/u-boot-spl.bin,cpu-num=0 -device loader,addr=0x400104000,file=/path/to/arm-trusted-firmware/build/lmt/release/bl31.bin -device loader,addr=0x400200000,file=/path/to/u-boot/u-boot.bin -device loader,addr=0x404000000,file=/path/to/optee_os/out/arm-plat-ax/core/tee-pager_v2.bin -drive file=/path/to/emmc.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>

<p><code>virt=on</code>：使能CPU的EL2<br><code>secure=on</code>：使能CPU的EL3<br><code>emmc=on</code>：使能eMMC模拟支持</p>
<p><img data-src="/images/29/spl_atf_optee_uboot_kernel.gif" alt="spl_atf_optee_uboot_kernel"></p>
<p>启动日志附件：<a href="/images/29/spl_atf_optee_uboot_kernel.txt">SPL-&gt;ATF-&gt;OPTEE-&gt;U-Boot-&gt;kernel Booting</a></p>
<h3 id="lmt-safety-virt运行验证"><a href="#lmt-safety-virt运行验证" class="headerlink" title="lmt-safety-virt运行验证"></a>lmt-safety-virt运行验证</h3><p>lmt-safety-virt虚拟平台是基于RISC-V 32-bit架构开发的，在U-Boot里面添加了lmt-safety-virt平台的支持。下面是U-Boot编译构建命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> u-boot</span><br><span class="line">make ARCH=riscv CROSS_COMPILE=riscv32-unknown-linux-gnu- lmt-qemu-riscv-without-dram_defconfig</span><br><span class="line">make ARCH=riscv CROSS_COMPILE=riscv32-unknown-linux-gnu- -j4</span><br></pre></td></tr></table></figure>

<p>下面是运行验证命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-riscv32 -M lmt-safety-virt -m 1M -display none -device loader,file=/path/to/u-boot/u-boot-with-spl.bin,addr=0x60c00000,cpu-num=0 -serial stdio</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/29/safety-virt.png" alt="lmt-safety-virt"></p>
<h3 id="lmt-virt和lmt-safety-virt联合运行"><a href="#lmt-virt和lmt-safety-virt联合运行" class="headerlink" title="lmt-virt和lmt-safety-virt联合运行"></a>lmt-virt和lmt-safety-virt联合运行</h3><p>SoC是异构的，里面即集成了ARM Cortex-A系列的CPU，也集成了RISC-V系列的CPU。因此一种架构的CPU开发一个对应的虚拟平台，两个及以上的虚拟平台对应多个Qemu进程，就涉及到多个Qemu之间的联动，用于仿真异构核之间的交互和控制逻辑。</p>
<p>下面是启动lmt-virt的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M lmt-virt,riscv-memdev=iram-safety -m 4G -display none -device loader,addr=0x400200000,file=/path/to/u-boot/u-boot.bin,cpu-num=0 -object memory-backend-file,size=512K,id=iram-safety,share=on,mem-path=/path/to/qemu-shm,discard-data=on -rp-path /tmp/coemu -serial stdio -semihosting</span><br></pre></td></tr></table></figure>

<p><code>/tmp/coemu</code>：如果目录不存在，<em>mkdir</em>创建<br><code>riscv-memdev</code>：指定IRAM的内存后端ID，由machine使用</p>
<p>下面是启动lmt-safety-virt的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-riscv32 -M lmt-safety-virt,standalone=off,memdev=iram-safety -m 2M -display none -chardev socket,id=coemu,path=/tmp/coemu/qemu_rport_machine_lmt_soc_cosim_rp -object memory-backend-file,size=512K,id=iram-safety,share=on,mem-path=/path/to/qemu-shm,discard-data=on -serial stdio</span><br></pre></td></tr></table></figure>

<p><code>standalone=</code>：指定machine的运行模式（单独或者联动）<br><code>memdev=</code>：指定machine所使用内存后端的ID</p>
<p><img data-src="/images/29/both-virt.gif" alt="both-virt"></p>
<p>AArch64侧的启动日志附件：<a href="/images/29/aarch64_booting.txt">AArch64 Booting</a></p>
<p>RISC-V侧的启动日志附件：<a href="/images/29/riscv_booting.txt">RISC-V Booting</a></p>
<p>目前只是做到了AArch64侧能够控制RISC-V侧的启动，两侧的通信交互还没有开发，比如在Linux内核下AArch64与RISC-V进行交互访问等。</p>
]]></content>
  </entry>
  <entry>
    <title>排序算法学习总结</title>
    <url>/posts/fc2b9b27/</url>
    <content><![CDATA[<blockquote>
<p>逃避是没有用的，困难不会因为你的逃避就迎刃而解。只有改变，才能迎来新的机遇。改变不了过去，就改变未来。改变不了别人，就改变自己。—-人民日报《[夜读] 生气不如争气，抱怨不如改变》</p>
</blockquote>
<p>最近参加多场笔试及面试，察觉到自己的算法实现能力很弱，随决定翻看算法方面的书籍来加强这方面的学习及编码实现。因此，本文尽量总结所学，以备所需。温故而知新，坚持记录！</p>
<span id="more"></span>


<h3 id="bubble-sort-冒泡排序"><a href="#bubble-sort-冒泡排序" class="headerlink" title="bubble-sort [冒泡排序]"></a>bubble-sort [冒泡排序]</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>反复地交换顺序颠倒的相邻元素，第一轮迭代会将最小或最大元素交换到序列末端，以此类推，至多经过n-1轮迭代后会将含有n个元素的待排序列按升序或降序排好序。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @array: specify a pending array</span></span><br><span class="line"><span class="comment"> * @len: the size of the @array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = len - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">array</span>[j] ^= <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">array</span>[j - <span class="number">1</span>] ^= <span class="built_in">array</span>[j];</span><br><span class="line">                <span class="built_in">array</span>[j] ^= <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到一组序列可能不需要n-1轮迭代就能排好序，使用标志变量来优化掉不必要的元素比较，只要在下一轮迭代中没有发生相邻元素交换，其意味该序列已经排好序，再后来的迭代就是没必要的。</p>
<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p><img data-src="/images/19/bubble_sort.jpg" alt="bubble_sort" title="bubble_sort.jpg"></p>
<center>图1 冒泡排序图解</center>
**带箭头虚线表示向上移动元素的轨迹，比如沿着箭头的反方向，在第一轮中就可以确定元素1是从低端一直移动到顶端；在第二轮中有两个元素向上移动。**

<h3 id="insert-sort-插入排序"><a href="#insert-sort-插入排序" class="headerlink" title="insert-sort [插入排序]"></a>insert-sort [插入排序]</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>每一轮迭代都将一个待排序元素插入到前面的有序序列中，直到把所有元素都插入到有序序列为止。这一过程分两步：</p>
<ul>
<li>在有序序列中寻找待排序元素的位置，将该位置后的所有有序元素向后移动为这个待排序元素腾挪空间</li>
<li>将这个待排序元素放入这个空间</li>
</ul>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        key = <span class="built_in">array</span>[j];</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * array[i] &gt; key statement, ascending sorting.</span></span><br><span class="line"><span class="comment">         * array[i] &lt; key statement, descending sorting.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[i] &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">array</span>[i + <span class="number">1</span>] = <span class="built_in">array</span>[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[i + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是先读取所有待排序元素，然后排序这个序列。其实也可以一边读取待排序元素一边排序，最终使这个序列排好序。</p>
<h4 id="图例-1"><a href="#图例-1" class="headerlink" title="图例"></a>图例</h4><p><img data-src="/images/19/insert-sort.jpg" alt="insert_sort"></p>
<center>图2 插入排序图解</center>
**注意：i， j表示数组的索引位置，比如j=1意味着原数组的第二个元素将被插入有序序列中， i=-1意味着有序序列的第一个位置用来存放待排序元素**
### select-sort [选择排序]
#### 基本思想
每一轮迭代从待排序序列中找出最小元素，然后与待排序序列的第一个元素交换，直到执行n-1轮迭代使所以元素排好序。因为到第n-1轮时，就剩余两个待排序元素了，本轮迭代不管有没有发生交换都会将输入序列排好序。
#### 示例代码
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">select_sort</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> least, i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        least = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[least]) &#123;</span><br><span class="line">                least = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (least != i) &#123;</span><br><span class="line">            <span class="built_in">array</span>[i] ^= <span class="built_in">array</span>[least];</span><br><span class="line">            <span class="built_in">array</span>[least] ^= <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i] ^= <span class="built_in">array</span>[least];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
#### 图例
![select_sort](/images/19/select-sort.jpg)
<center>图3 选择排序图解</center>
**注意： 图中粉红色元素属于有序序列，其后面就是待排序序列**
### 小结
### merge-sort [合并排序]
基本思想：
### quicksort [快速排序]
### heapsort [堆排序]

<h3 id="性能对比与分析总结"><a href="#性能对比与分析总结" class="headerlink" title="性能对比与分析总结"></a>性能对比与分析总结</h3><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><h4 id="两变量交换"><a href="#两变量交换" class="headerlink" title="两变量交换"></a>两变量交换</h4><p><strong>1. 三变量法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure>
<p>此方法适用范围广，推荐使用</p>
<p><strong>2. 变量加减法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br></pre></td></tr></table></figure>
<p>这个方法看起来很好，少用一个中间变量，但是实际上很少使用，因为其适用范围很窄：只有定义了加减运算的数据类型才能使用这种方法。<br><strong>3. 变量异或运算法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a ^= b ^= a ^= b</span><br></pre></td></tr></table></figure>
<p>不建议使用这个方法，一般只能适用整数类型的变量。</p>
]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>insert-sort</tag>
        <tag>merge-sort</tag>
        <tag>quick-sort</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Qemu的RISC-V实验平台</title>
    <url>/posts/d4e29484/</url>
    <content><![CDATA[<p>现在越来越多的公司开始关注和使用RISC-V，或者已经有一些公司开始把RISC-V集成到自己的芯片中，但是市面上还是缺乏一款优秀的RISC-V开发板，既能满足软件开发验证使用，又能提供丰富的学习例程。</p>
<p>在无RISC-V开发板的情况下，为了能够学习验证RISC-V相关的代码，通过Qemu模拟器搭建RISC-V运行环境，这样也能完全达到实验学习的目的。</p>
<span id="more"></span>

<h3 id="下载编译工具"><a href="#下载编译工具" class="headerlink" title="下载编译工具"></a>下载编译工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/riscv-collab/riscv-gnu-toolchain/releases/download/2023.10.18/riscv32-glibc-ubuntu-20.04-gcc-nightly-2023.10.18-nightly.tar.gz</span><br><span class="line">wget https://github.com/riscv-collab/riscv-gnu-toolchain/releases/download/2023.10.18/riscv64-glibc-ubuntu-20.04-gcc-nightly-2023.10.18-nightly.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzf riscv32-glibc-ubuntu-20.04-gcc-nightly-2023.10.18-nightly.tar.gz -C /path/to/directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开<code>~/.bashrc</code>后在文件末尾添加如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/path/to/riscv32/bin</span><br></pre></td></tr></table></figure>
<p>保存之后，同步修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">riscv32-unknown-linux-gnu-gcc --version</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/26/carbon0.svg" alt="carbon"></p>
<h3 id="Qemu构建"><a href="#Qemu构建" class="headerlink" title="Qemu构建"></a>Qemu构建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b qemu-v7.2.0 https://github.com/chasinglulu/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">./configure --target-list=aarch64-softmmu,riscv64-softmmu,riscv32-softmmu --enable-fdt --disable-kvm --disable-xen --enable-gcrypt</span><br><span class="line">make -j64</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">./qemu-system-riscv32 --version</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/26/qemu.svg" alt="qemu-system-riscv32-version"></p>
<h3 id="OpenSBI构建"><a href="#OpenSBI构建" class="headerlink" title="OpenSBI构建"></a>OpenSBI构建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/chasinglulu/opensbi.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=riscv32-unknown-linux-gnu-</span><br><span class="line">make PLATFORM=generic</span><br></pre></td></tr></table></figure>
<p>更多关于OpenSBI的构建说明，参考<a href="https://github.com/riscv-software-src/opensbi">OpenSBI README</a></p>
<h3 id="U-Boot构建"><a href="#U-Boot构建" class="headerlink" title="U-Boot构建"></a>U-Boot构建</h3><p>首先要将<code>/path/to/opensbi/build/platform/generic/firmware</code>目录下<code>fw_dynamic.bin</code>文件复制到u-boot源代码目录下，在编译时binman会使用这个bin文件打包出一个u-boot.itb。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hobot-uboot https://github.com/chasinglulu/u-boot.git</span><br><span class="line"><span class="built_in">cd</span> u-boot</span><br><span class="line">make ARCH=riscv CROSS_COMPILE=riscv32-unknown-linux-gnu- qemu-riscv32_spl_defconfig</span><br><span class="line">make ARCH=riscv CROSS_COMPILE=riscv32-unknown-linux-gnu- -j4</span><br></pre></td></tr></table></figure>

<h3 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h3><h4 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h4><p><img data-src="/images/26/opensbi-introduction.jpg" alt="What is SBI"></p>
<center>图1 SBI介绍</center>

<p><img data-src="/images/26/riscv-bootflow.jpg" alt="riscv bootflow"></p>
<center>图2 RISC-V启动流</center>

<h4 id="启动案例"><a href="#启动案例" class="headerlink" title="启动案例"></a>启动案例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-riscv32 -M virt -smp 4 -m 2G -display none -serial stdio -bios /path/to/u-boot/spl/u-boot-spl.bin -device loader,file=/path/to/u-boot/u-boot.itb,addr=0x80200000</span><br></pre></td></tr></table></figure>

<p>运行输出日志如下：<br><img data-src="/images/26/carbon.svg" alt="carbon"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf">RISC-V BootFlow</a></li>
</ol>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>risc-v</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Qemu eMMC模拟设备的启动</title>
    <url>/posts/7cba3cf4/</url>
    <content><![CDATA[<p>从eMMC中加载镜像并启动是我们常见开发板的启动方式，通过Qemu模拟eMMC设备，这样我们可以在Qemu上直接验证我们很多相关的逻辑功能，比如eMMC的启动、文件系统的mount、文件读写等。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Qemu:</strong> v7.2.0</li>
<li><strong>U-Boot:</strong> v2022.04</li>
<li><strong>Linux Kernel:</strong> linux-6.1.12</li>
</ul>
<hr>
<h3 id="U-Boot-eMMC架构"><a href="#U-Boot-eMMC架构" class="headerlink" title="U-Boot eMMC架构"></a>U-Boot eMMC架构</h3><p><img data-src="/images/28/uboot-sdhci-framework.jpg" alt="framework"></p>
<h3 id="eMMC镜像制作"><a href="#eMMC镜像制作" class="headerlink" title="eMMC镜像制作"></a>eMMC镜像制作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=emmc.img bs=1M count=2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># GPT partition table</span></span><br><span class="line">sudo parted emmc.img mktable gpt</span><br><span class="line"><span class="comment"># msic part 512KiB</span></span><br><span class="line">sudo parted emmc.img mkpart misc 2048KiB 2559KiB</span><br><span class="line"><span class="comment"># ubootenv part 512KiB</span></span><br><span class="line">sudo parted -s -a none emmc.img mkpart ubootenv 2560KiB 3071KiB</span><br><span class="line"><span class="comment"># vbmeta_a part 512KiB</span></span><br><span class="line">sudo parted -s -a none emmc.img mkpart vbmeta_a 3072KiB 3583KiB</span><br><span class="line"><span class="comment"># vbmeta_b part 512KiB</span></span><br><span class="line">sudo parted -s -a none emmc.img mkpart vbmeta_b 3584KiB 4095KiB</span><br><span class="line"><span class="comment"># boot_a partition 150MiB</span></span><br><span class="line">sudo parted -s -a none emmc.img mkpart boot_a 4MiB 154MiB</span><br><span class="line"><span class="comment"># boot_b partition 150MiB</span></span><br><span class="line">sudo parted -s -a none emmc.img mkpart boot_b 154MiB 304MiB</span><br><span class="line">sudo parted emmc.img <span class="built_in">set</span> 5 boot on</span><br><span class="line">sudo parted emmc.img <span class="built_in">set</span> 6 boot on</span><br><span class="line"><span class="comment"># buildroot partition 512MiB</span></span><br><span class="line">sudo parted -s -a none emmc.img mkpart buildroot 304MiB 816MiB</span><br><span class="line"><span class="comment"># ubuntu partition 1024MiB</span></span><br><span class="line">sudo parted -s -a none emmc.img mkpart buildroot 816MiB 2046MiB</span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line"></span><br><span class="line">sudo kpartx -av emmc.img</span><br><span class="line">sudo mkfs.vfat /dev/mapper/loopXp5</span><br><span class="line">sudo mkfs.vfat /dev/mapper/loopXp6</span><br><span class="line">sudo mkfs.ext4 /dev/mapper/loopXp7</span><br><span class="line">sudo mkfs.ext4 /dev/mapper/loopXp8</span><br><span class="line"></span><br><span class="line">sudo tune2fs -f -O ^metadata_csum /dev/mapper/loopXp7</span><br><span class="line">sudo tune2fs -f -O ^metadata_csum /dev/mapper/loopXp8</span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line"></span><br><span class="line">sudo kpartx -dv emmc.img</span><br></pre></td></tr></table></figure>

<p><strong>注意：loopX是kpartx自动生成的，X根据实际情况替换成数字</strong></p>
<h3 id="eMMC验证"><a href="#eMMC验证" class="headerlink" title="eMMC验证"></a>eMMC验证</h3><h4 id="U-Boot配置选项"><a href="#U-Boot配置选项" class="headerlink" title="U-Boot配置选项"></a>U-Boot配置选项</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_MMC=y</span><br><span class="line">CONFIG_MMC_WRITE=y</span><br><span class="line">CONFIG_DM_MMC=y</span><br><span class="line">CONFIG_MMC_SDHCI_ADMA_HELPERS=y</span><br><span class="line">CONFIG_MMC_HW_PARTITIONING=y</span><br><span class="line">CONFIG_SUPPORT_EMMC_RPMB=y</span><br><span class="line">CONFIG_SUPPORT_EMMC_BOOT=y</span><br><span class="line">CONFIG_CMD_MMC=y</span><br><span class="line">CONFIG_MMC_VERBOSE=y</span><br><span class="line">CONFIG_MMC_SDHCI=y</span><br><span class="line">CONFIG_MMC_SDHCI_SDMA=y</span><br><span class="line">CONFIG_MMC_SDHCI_ADMA=y</span><br><span class="line"># CONFIG_SPL_MMC_SDHCI_ADMA is not <span class="built_in">set</span></span><br><span class="line"># CONFIG_MMC_SDHCI_BCMSTB is not <span class="built_in">set</span></span><br><span class="line">CONFIG_MMC_SDHCI_CADENCE=y</span><br></pre></td></tr></table></figure>
<h4 id="运行验证"><a href="#运行验证" class="headerlink" title="运行验证"></a>运行验证</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt,emmc=on,virt=on -m 4G -display none -device loader,addr=0x3000200000,file=/path/to/u-boot/u-boot-dtb.bin,cpu-num=0 -drive file=/path/to/emmc.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/28/eMMC.svg" alt="eMMC"></p>
<h3 id="U-Boot-distro配置"><a href="#U-Boot-distro配置" class="headerlink" title="U-Boot distro配置"></a>U-Boot distro配置</h3><p>将<code>U-Boot distro</code>运行需要的文件复制到<code>emmc.img</code>的分区<code>part 5</code>或者<code>part 6</code>，这样U-Boot后面将自动地从eMMC媒介中加载内核等镜像，完成启动引导。</p>
<p>extlinux.cfg配置文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## /boot/extlinux/extlinux.conf</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">menu title U-Boot menu</span><br><span class="line">prompt 0</span><br><span class="line">timeout 50</span><br><span class="line"></span><br><span class="line">label sigi-kernel-buildroot</span><br><span class="line">        kernel /Image</span><br><span class="line">        fdt /hobot-sigi-virt.dtb</span><br><span class="line">        append earlycon=uart8250,mmio32,0x39050000,115200n8 console=ttyS0,115200n8 loglevel=10 root=/dev/mmcblk0p7 rootwait init=/init rw</span><br><span class="line"></span><br><span class="line">label sigi-kernel-ubuntu</span><br><span class="line">        kernel /Image</span><br><span class="line">        fdt /hobot-sigi-virt.dtb</span><br><span class="line">        append earlycon=uart8250,mmio32,0x39050000,115200n8 console=ttyS0,115200n8 loglevel=10 root=/dev/mmcblk0p8 rootwait init=/init rw</span><br><span class="line"></span><br><span class="line">label sigi-kernel-nvme</span><br><span class="line">        kernel /Image</span><br><span class="line">        fdt /hobot-sigi-virt.dtb</span><br><span class="line">        append earlycon=uart8250,mmio32,0x39050000,115200n8 console=ttyS0,115200n8 loglevel=10 root=/dev/nvme0n1p7 rootwait init=/init rw</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面脚本将Image、initramfs、dtb等文件复制到emmc.img的boot_a分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p rootfs</span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"></span><br><span class="line">part_map=$(sudo kpartx -av emmc.img)</span><br><span class="line"></span><br><span class="line">sudo mount /dev/mapper/$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$part_map</span>&quot;</span> | sed -n <span class="string">&#x27;5p&#x27;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>) rootfs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy boot config</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p rootfs/extlinux/</span><br><span class="line">sudo <span class="built_in">cp</span> extlinux.conf rootfs/extlinux/</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy kernel images</span></span><br><span class="line">sudo <span class="built_in">cp</span> linux/arch/arm64/boot/Image rootfs/</span><br><span class="line">sudo <span class="built_in">cp</span> linux/arch/arm64/boot/Image.gz rootfs/</span><br><span class="line">sudo <span class="built_in">cp</span> linux/arch/arm64/boot/dts/hobot/hobot-sigi-virt.dtb rootfs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy initramfs image</span></span><br><span class="line">sudo <span class="built_in">cp</span> buildroot/output/images/rootfs.cpio.lz4 rootfs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy xen image</span></span><br><span class="line"><span class="comment"># sudo cp -r xen-tools/4.17/install/boot/xen* rootfs/</span></span><br><span class="line"><span class="comment"># sudo cp xen/xen/xen rootfs/</span></span><br><span class="line"></span><br><span class="line">sudo umount rootfs</span><br><span class="line">sudo kpartx -dv emmc.img</span><br><span class="line"></span><br><span class="line"><span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu启动"><a href="#Ubuntu启动" class="headerlink" title="Ubuntu启动"></a>Ubuntu启动</h3><h4 id="Ubuntu镜像制作"><a href="#Ubuntu镜像制作" class="headerlink" title="Ubuntu镜像制作"></a>Ubuntu镜像制作</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://cdimage.ubuntu.com/ubuntu-base/releases/20.04.4/release/ubuntu-base-20.04.4-base-arm64.tar.gz</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=ubuntu.img bs=1M count=1024 oflag=direct</span><br><span class="line">mkfs.ext4 ubuntu.img</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p rootfs</span><br><span class="line">sudo mount -t ext4 ubuntu.img rootfs/</span><br><span class="line">sudo tar -xzf ubuntu-base-20.04.4-base-arm64.tar.gz -C rootfs/</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">cp</span> /usr/bin/qemu-aarch64-static rootfs/usr/bin/</span><br><span class="line">sudo <span class="built_in">cp</span> /etc/resolv.conf rootfs/etc/resolv.conf</span><br><span class="line"></span><br><span class="line">sudo mount -t proc /proc rootfs/proc</span><br><span class="line">sudo mount -t sysfs /sys rootfs/sys</span><br><span class="line">sudo mount -o <span class="built_in">bind</span> /dev rootfs/dev</span><br><span class="line">sudo mount -o <span class="built_in">bind</span> /dev/pts rootfs/dev/pts</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">chroot</span> rootfs/</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install sudo vim-tiny -y</span><br><span class="line">apt-get install net-tools iputils-ping -y</span><br><span class="line">apt-get install network-manager netplan.io systemd -y</span><br><span class="line">apt-get install kmod net-tools ifupdown -y</span><br><span class="line"></span><br><span class="line">useradd -m -d /home/charley -s /bin/bash -p ubuntu <span class="string">&quot;charley&quot;</span></span><br><span class="line">usermod -a -G sudo charley</span><br><span class="line">/bin/bash -c <span class="string">&quot;echo \&quot;virt\&quot; &gt;/etc/hostname&quot;</span></span><br><span class="line">/bin/bash -c <span class="string">&quot;echo \&quot;127.0.0.1 localhost\&quot; &gt;/etc/hosts&quot;</span></span><br><span class="line">/bin/bash -c <span class="string">&quot;echo \&quot;127.0.0.1 virt\&quot; &gt;&gt;/etc/hosts&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">sudo umount rootfs/proc</span><br><span class="line">sudo umount rootfs/sys</span><br><span class="line">sudo umount rootfs/dev/pts</span><br><span class="line">sudo umount rootfs/dev</span><br><span class="line">sudo umount rootfs/</span><br></pre></td></tr></table></figure>
<p>将生成的<code>ubuntu.img</code>里面的内容都复制到<code>emmc.img</code>的分区<code>part 8</code>里面，这样U-Boot启动时才能挂载Ubuntu文件系统。</p>
<h4 id="运行验证-1"><a href="#运行验证-1" class="headerlink" title="运行验证"></a>运行验证</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt,emmc=on,virt=on -m 4G -display none -device loader,addr=0x3000200000,file=/path/to/u-boot/u-boot-dtb.bin,cpu-num=0 -drive file=/path/to/emmc.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/28/ubuntu.gif" alt="ubuntu"><br>启动日志附件：<a href="/images/28/ubuntu.txt">U-Boot -&gt; Kernel -&gt; Ubuntu Booting</a></p>
<h3 id="基于Buildroot文件系统启动"><a href="#基于Buildroot文件系统启动" class="headerlink" title="基于Buildroot文件系统启动"></a>基于Buildroot文件系统启动</h3><p>将buildroot生成的rootfs.cpio.lz4里面的内容展开到<code>emmc.img</code>的分区<code>part 7</code>里面，这样U-Boot启动时才能挂载buildroot根文件系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt,emmc=on,virt=on -m 4G -display none -device loader,addr=0x3000200000,file=/path/to/u-boot/u-boot-dtb.bin,cpu-num=0 -drive file=/path/to/emmc.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/28/uboot_kernel.gif" alt="buildroot"><br>启动日志附件：<a href="/images/28/uboot_kernel.txt">U-Boot -&gt; Kernel -&gt; Buildroot Booting</a></p>
<h3 id="eMMC-RPMB访问"><a href="#eMMC-RPMB访问" class="headerlink" title="eMMC RPMB访问"></a>eMMC RPMB访问</h3><h4 id="RPMB介绍"><a href="#RPMB介绍" class="headerlink" title="RPMB介绍"></a>RPMB介绍</h4><p>RPMB(Replay Protected Memory Block) Partition是eMMC中的一个具有安全特性的分区。<br>eMMC在写入数据到RPMB时，会校验数据的合法性，只有指定的Host才能够写入，同时在读数据时，也提供了签名机制，保证Host读取到的数据是RPMB内部数据，而不是攻击者伪造的数据。</p>
<p>RPMB在实际应用中，通常用于存储一些有防止非法篡改需求的数据，例如手机上指纹支付相关的公钥、序列号等。RPMB可以对写入操作进行鉴权，但是读取并不需要鉴权，任何人都可以进行读取的操作，因此存储到RPMB的数据通常会进行加密后再存储。</p>
<h4 id="运行验证-2"><a href="#运行验证-2" class="headerlink" title="运行验证"></a>运行验证</h4><p>上面我们制作的emmc.img镜像里面都没有包含rpmb.img镜像，因此我们要制作一个rpmb.img的空间，和emmc.img拼在一起，这样U-Boot才能够访问RPMB的空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=rpmb.img bs=1M count=2</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=emmc.img bs=1M count=2046</span><br><span class="line"><span class="comment">#emmc.img按照上面制作方法进行分区和复制内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> rpmb.img emmc.img &gt;emmc-with-rpmb.img</span><br></pre></td></tr></table></figure>
<p><strong>emmc.img大小必须是1G、2G、4G等（要满足2的N次方形式）</strong><br>否者，就会报如下的错误信息：<br><img data-src="/images/28/emmc-size.svg" alt="emmc-size"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 -M hobot-sigi-virt,emmc=on,part-config=0x20,virt=on -m 4G -display none -device loader,addr=0x3000200000,file=/path/to/u-boot/u-boot-dtb.bin,cpu-num=0 -drive file=/path/to/emmc-with-rpmb.img,format=raw,<span class="keyword">if</span>=emmc -serial stdio</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/28/rpmb.gif" alt="rpmb"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 烧写rpmb key，每个eMMC只能烧写一次</span></span><br><span class="line">load mmc 0:5 0x3090000000 /rpmb-key.txt;mmc rpmb key 0x3090000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用这个key，把data写入到RPMB分区内</span></span><br><span class="line">fatload mmc 0:5 0x3091000000 Image;mmc rpmb write 0x3091000000 0x0 0x10 0x3090000000</span><br><span class="line"></span><br><span class="line">md 0x3092000000 0x10</span><br><span class="line"><span class="comment"># 读取RPMB分区里面的data，可以不用key校验</span></span><br><span class="line">mmc rpmb <span class="built_in">read</span> 0x3092000000 0x0 0x10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次，做对比，看看数据有没有正确读出来</span></span><br><span class="line">md  0x3092000000 0x10</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>u-boot</tag>
        <tag>linux</tag>
        <tag>ATF</tag>
        <tag>eMMC</tag>
      </tags>
  </entry>
  <entry>
    <title>早期内存分配器：memblock</title>
    <url>/posts/6c782175/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;内核启动初期，常用内存分配器（memory allocator）还未被初始化而不能使用，在此期间memblock是一种用于管理内存区域的方法。memblock也是一种内存分配器，在内核启动阶段它是第一个被启用的内存分配器，在其他内存分配器可用之前使用它向内核注册指定的物理内存区间。memblock主要在启动阶段被使用，但若启用了内存热插拔机制，在内核运行时也需要使用memblock功能。2010年内核v.2.6.35版本首次引入memblock补丁，在此之前使用的内存分配器是bootmem。bootmem仅能管理启动时所需的部分物理内存（lowmem），但memblock能管理全部可用物理内存。在内核的buddy allocator（也是一种page allocator）可用之前，memblock是唯一能够在早期启动阶段管理内存的内存分配器。因此，这正是早期内存分配器（early memory allocator）术语的由来。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h3 id="memblock结构"><a href="#memblock结构" class="headerlink" title="memblock结构"></a>memblock结构</h3><p>memblock可分为如下三种类型：</p>
<ul>
<li>memory类型：memory类型用于描述可用的物理内存区域。通过设置内核参数能够仅注册实际物理内存的有限部分。最初，该类型的regions数组最多可以描述128个内存区域，但可以调整这个数组的大小，每次扩大都是以翻倍的形式扩充数组。</li>
<li>reserved类型：reserved类型用于描述正在使用的或即将被使用的物理内存块。起初，该类型的regions数组最多可以描述128个物理内存块，但可以通过翻倍的形式扩充这个数组。</li>
<li>physmem类型：physmem类型是在2014年额外添加的一种类型，用于描述硬件探查到的真实物理内存区间，一旦注册了将不能改变这个区间的大小。与memory类型的区间不同，physmem类型的区间只能是真实大小的物理内存区域，而不能是通过内核参数指定的，目前s390架构相关代码会注册这种类型的内存区域。该类型的regions数组起初最多可以描述四个物理内存区域。<ul>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=70210ed950b538ee7eb811dccc402db9df1c9be4">mm&#x2F;memblock: add physical memory list</a></li>
</ul>
</li>
</ul>
<p>如图1所示给出了memblock的内存区间类型和memblock数据结构的关系。</p>
<p><img data-src="/images/22/memblock_struct.svg" alt="memblock_struct.svg"></p>
<center>图1 memblock结构</center>

<p>&ensp;&ensp;&ensp;&ensp;如图2所示给出了一个例子，用一个memblock_region实例描述memory类型的1GiB可用物理内存区间，并用两个memblock_region实例描述reserved类型的两个子区间，指示两个子内存区间正在被使用而保留。</p>
<p><img data-src="/images/22/memblock_config_struct.svg" alt="memblock_config_struct.svg"></p>
<center>图2 物理内存配置与memblock数据结构的联系</center>

<p>通过下面三个表格分别说明memblock、memblock_type和memblock_region三个数据结构及其各个字段含义。</p>
<div align="center">表1 memblock 数据结构说明
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">字段类型</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">字段名</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">bool</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">bottom_up</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">在分配内存时决定是自底向上地还是自顶向下地搜寻空闲内存区间，不管哪种方式都适用于x86_64 NUMA系统。若在NUMA系统启用了hotplug功能，不管哪种方式也都能有效地分配热插拔内存。比如尝试从内存低地址处开始搜寻空闲内存时，应尽量从某一个内存节点分配空闲内存区间，这样能使从其他节点获取内存区间的频率最小化（true=自底向上）<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">phys_addr_t</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">current_limit</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">用于限定分配的物理地址。比如在64位系统，由于所有物理内存能与虚拟内存直接映射，那也就不存在低端内存(lowmem)，所以该字段会被设置为MEMBLOCK_ALLOC_ANYWHERE(0xffffffff_ffffffff)</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">struct memblock_type</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">memory</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">可用的物理内存区域<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">struct memblock_type<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">reserved<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">正被使用而保留的内存区间<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">struct memblock_type<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">physmem<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">系统存在的所有物理内存区域（只有部分体系架构支持</td></tr></table></div>


<div align="center">表2 memblock_type数据结构说明
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#fff;background-color:#409cff;text-align:center">字段类型</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#fff;background-color:#409cff;text-align:center">字段名</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#fff;background-color:#409cff;text-align:center">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">cnt</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">当前regions数组的大小</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">max</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">regions数组最大容量，也就是最多能描述的物理内存区间个数</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">phys_addr_t</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">total_size</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">所有已注册内存区间的长度总和</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">struct memblock_region &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">regions</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">指向描述内存区间的数组</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:center">char &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:center">name</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left">内存区间的类型名称</td></tr></table></div>

<div align="center">表3 memblock_region数据结构说明
<table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">字段类型</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">字段名</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#fff;background-color:#409cff;text-align:center">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">phys_addr_t<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">base</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">物理内存区间的起始地址（基地址）<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">phys_addr_t</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">size</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">物理内存区间的长度（大小）<br></td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">enum memblock_flags<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">flags</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">物理内存区间的属性，flags可以单独使用如下四个宏常量，也可以通过组合使用最后三个bit flag：<br>1. MEMBLOCK_NONE(0x0)：没有具体要求<br>2. MEMBLOCK_HOTPLUG(0x1)：可热插拔的内存区间<br>3. MEMBLOCK_MIRROR(0x2)：像镜子一样的内存区域<br>4. MEMBLOCK_NOMAP(0x4)：不能加入内核直接映射(kernel direct mapping)的内存区间</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:center">int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:center">nid</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left">内存节点编号<br></td></tr></table></div>

<h3 id="memblock初始化"><a href="#memblock初始化" class="headerlink" title="memblock初始化"></a>memblock初始化</h3><p>我们先看一下在编译时memblock的初始值。<br><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> </span></span><br><span class="line"><span class="class">	<span class="title">memblock_memory_init_regions</span>[<span class="title">INIT_MEMBLOCK_REGIONS</span>] __<span class="title">initdata_memblock</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> </span></span><br><span class="line"><span class="class">	<span class="title">memblock_reserved_init_regions</span>[<span class="title">INIT_MEMBLOCK_REGIONS</span>] __<span class="title">initdata_memblock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_MEMBLOCK_PHYS_MAP</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> </span></span><br><span class="line"><span class="class">	<span class="title">memblock_physmem_init_regions</span>[<span class="title">INIT_PHYSMEM_REGIONS</span>] __<span class="title">initdata_memblock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memblock</span> <span class="title">memblock</span> __<span class="title">initdata_memblock</span> =</span> &#123;</span><br><span class="line">	.memory.regions		= memblock_memory_init_regions,</span><br><span class="line">	.memory.cnt		= <span class="number">1</span>,	<span class="comment">/* empty dummy entry */</span></span><br><span class="line">	.memory.max		= INIT_MEMBLOCK_REGIONS,</span><br><span class="line">	.memory.name		= <span class="string">&quot;memory&quot;</span>,</span><br><span class="line"></span><br><span class="line">	.reserved.regions	= memblock_reserved_init_regions,</span><br><span class="line">	.reserved.cnt		= <span class="number">1</span>,	<span class="comment">/* empty dummy entry */</span></span><br><span class="line">	.reserved.max		= INIT_MEMBLOCK_REGIONS,</span><br><span class="line">	.reserved.name		= <span class="string">&quot;reserved&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_MEMBLOCK_PHYS_MAP</span></span><br><span class="line">	.physmem.regions	= memblock_physmem_init_regions,</span><br><span class="line">	.physmem.cnt		= <span class="number">1</span>,	<span class="comment">/* empty dummy entry */</span></span><br><span class="line">	.physmem.max		= INIT_PHYSMEM_REGIONS,</span><br><span class="line">	.physmem.name		= <span class="string">&quot;physmem&quot;</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	.bottom_up		= <span class="literal">false</span>,</span><br><span class="line">	.current_limit		= MEMBLOCK_ALLOC_ANYWHERE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>1～8行：在编译时memblock定义了三种描述内存区间的数组<ul>
<li>memory memblock准备了能描述128个内存区域的数组</li>
<li>reserved memblock也准备了能描述128个内存区间的数组</li>
<li>physmem memblock 只准备了能描述4个内存区域的数组</li>
</ul>
</li>
</ul>
<h4 id="memory-memblock添加内存区域"><a href="#memory-memblock添加内存区域" class="headerlink" title="memory memblock添加内存区域"></a>memory memblock添加内存区域</h4><p>&ensp;&ensp;&ensp;&ensp;内核通过解析DTB文件的memory节点获得可用物理内存的起始地址和大小，并能通过类memblock_add的API往memory.regions数组添加一个memblock_region实例，用于管理这个物理内存区域。不过，某些特别的体系架构还支持自动识别出已安装内存的起始地址和大小等属性。若通过解析DTB文件添加物理内存区域，memory节点的reg属性给出内存的起始地址和大小，内核执行如下的函数调用路径来完成物理内存区域的注册。如图3所示显示了解析设备树和通过memblock_add API注册物理内存区间的处理流程。</p>
<p><img data-src="/images/22/memblock_add.svg" alt="memblock_add.svg"></p>
<center>图3 memblock_add调用流程</center>

<p>&ensp;&ensp;&ensp;&ensp;不管ARM还是ARM64都能够人为地限定可用物理内存的大小。在ARM64系统，若已安装DRAM的大小超过了虚拟内存的寻址界限（VA39-1，VA42-1，VA48-1等），则超过的物理内存区间目前将不能被利用。通过<code>mem=</code>内核参数能够限定可用物理内存的大小。</p>
<h4 id="arm64-memblock-init：初始化memblock"><a href="#arm64-memblock-init：初始化memblock" class="headerlink" title="arm64_memblock_init：初始化memblock"></a>arm64_memblock_init：初始化memblock</h4><p>&ensp;&ensp;&ensp;&ensp;在内核启动初始化阶段，会使用reserved类型的memblock_region实例来描述下列物理内存区间，表示物理内存区间被预留和使用。根据不同架构和平台的配置，所预留的物理内存区间也是存在差异的。</p>
<ul>
<li>存放kernel映像的内存区间</li>
<li>存放initrd数据的内存区间</li>
<li>存放页表（page table）的内存区间</li>
<li>存放DTB文件和其中<code>reserved-mem</code>节点指定的内存区间</li>
<li>用于CMA-DMA的内存区间</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;此外，DTB文件中<code>chosen</code>节点的<code>linux,usable-memory-range</code>属性能指定可用物理内存的范围，在此范围外的物理内存区间将从memory memblock移除。如图4所示显示了arm64_memblock_init函数会预留的物理内存区间。</p>
<p><img data-src="/images/22/arm64_memblock_init.svg" alt="arm64_memblock_init.svg"></p>
<center>图4 arm64_memblock_init会预留的物理内存区间</center>

<p>在arch&#x2F;arm64&#x2F;mm&#x2F;init.c中arm64_memblock_init函数（1&#x2F;2）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">arm64_memblock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> s64 linear_region_size = -(s64)PAGE_OFFSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Handle linux,usable-memory-range property */</span></span><br><span class="line">	fdt_enforce_memory_region();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remove memory above our supported physical address size */</span></span><br><span class="line">	memblock_remove(<span class="number">1ULL</span> &lt;&lt; PHYS_MASK_SHIFT, ULLONG_MAX);</span><br><span class="line"></span><br><span class="line">	BUILD_BUG_ON(linear_region_size != BIT(VA_BITS - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	memstart_addr = round_down(memblock_start_of_DRAM(),</span><br><span class="line">				   ARM64_MEMSTART_ALIGN);</span><br><span class="line"></span><br><span class="line">	memblock_remove(<span class="type">max_t</span>(u64, memstart_addr + linear_region_size,</span><br><span class="line">			__pa_symbol(_end)), ULLONG_MAX);</span><br><span class="line">	<span class="keyword">if</span> (memstart_addr + linear_region_size &lt; memblock_end_of_DRAM()) &#123;</span><br><span class="line">		<span class="comment">/* ensure that memstart_addr remains sufficiently aligned */</span></span><br><span class="line">		memstart_addr = round_up(memblock_end_of_DRAM() - linear_region_size,</span><br><span class="line">					 ARM64_MEMSTART_ALIGN);</span><br><span class="line">		memblock_remove(<span class="number">0</span>, memstart_addr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (memory_limit != PHYS_ADDR_MAX) &#123;</span><br><span class="line">		memblock_mem_limit_remove_map(memory_limit);</span><br><span class="line">		memblock_add(__pa_symbol(_text), (u64)(_end - _text));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_BLK_DEV_INITRD) &amp;&amp; initrd_start) &#123;</span><br><span class="line">		u64 base = initrd_start &amp; PAGE_MASK;</span><br><span class="line">		u64 size = PAGE_ALIGN(initrd_end) - base;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN(base &lt; memblock_start_of_DRAM() ||</span><br><span class="line">			 base + size &gt; memblock_start_of_DRAM() +</span><br><span class="line">				       linear_region_size,</span><br><span class="line">			<span class="string">&quot;initrd not fully accessible via the linear mapping -- please check your bootloader ...\n&quot;</span>)) &#123;</span><br><span class="line">			initrd_start = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			memblock_remove(base, size); <span class="comment">/* clear MEMBLOCK_ flags */</span></span><br><span class="line">			memblock_add(base, size);</span><br><span class="line">			memblock_reserve(base, size);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.......</span><br></pre></td></tr></table></figure>

<ul>
<li>3行：在arm64内核，linear_region_size正好等于虚拟地址空间大小的二分之一，比如虚拟内存大小为512GiB（VA_BITS&#x3D;39），那么linear_region_size &#x3D; 256GiB</li>
<li>13～14行：鉴于内核不同配置，通过向下舍去方式使DRAM起始地址对齐<code>SECTION_SIZE</code>或<code>PUD_SIZE</code>或<code>PMD_SIZE</code>，memstart_addr得到一个合适的物理内存基地址</li>
<li>16～17行：内核映像有可能位于物理内存的顶端，顶部多余的物理内存区间将从memory memblock移除</li>
<li>18～23行：若物理内存还超过linear mapping region的大小，底部超过的物理内存区间将从memory memblock移除。比如VA_BITS&#x3D;39和DRAM&#x3D;1TiB，linear mapping region只能有256GiB，其他768GiB内存区间不能被linear mapping容纳，需要从memory memblock中删除。</li>
<li>25～28行：通过<code>mem=</code>内核参数缩减FDT指定的物理内存，多出的内存区间需从memory memblock剔除 </li>
<li>30～44行：在reserved memblock添加用于保存initrd数据的内存区间</li>
</ul>
<p>在arch&#x2F;arm64&#x2F;mm&#x2F;init.c中arm64_memblock_init函数（2&#x2F;2）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) &#123;</span><br><span class="line">		<span class="keyword">extern</span> u16 memstart_offset_seed;</span><br><span class="line">		u64 range = linear_region_size -</span><br><span class="line">			    (memblock_end_of_DRAM() - memblock_start_of_DRAM());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (memstart_offset_seed &gt; <span class="number">0</span> &amp;&amp; range &gt;= ARM64_MEMSTART_ALIGN) &#123;</span><br><span class="line">			range = range / ARM64_MEMSTART_ALIGN + <span class="number">1</span>;</span><br><span class="line">			memstart_addr -= ARM64_MEMSTART_ALIGN *</span><br><span class="line">					 ((range * memstart_offset_seed) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memblock_reserve(__pa_symbol(_text), _end - _text);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line">	<span class="keyword">if</span> (initrd_start) &#123;</span><br><span class="line">		memblock_reserve(initrd_start, initrd_end - initrd_start);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* the generic initrd code expects virtual addresses */</span></span><br><span class="line">		initrd_start = __phys_to_virt(initrd_start);</span><br><span class="line">		initrd_end = __phys_to_virt(initrd_end);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	early_init_fdt_scan_reserved_mem();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4GB maximum for 32-bit only capable devices */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_ZONE_DMA32))</span><br><span class="line">		arm64_dma_phys_limit = max_zone_dma_phys();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		arm64_dma_phys_limit = PHYS_MASK + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	reserve_crashkernel();</span><br><span class="line"></span><br><span class="line">	reserve_elfcorehdr();</span><br><span class="line"></span><br><span class="line">	high_memory = __va(memblock_end_of_DRAM() - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	dma_contiguous_reserve(arm64_dma_phys_limit);</span><br><span class="line"></span><br><span class="line">	memblock_allow_resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3～14行：出于安全考虑，CONFIG_RANDOMIZE_BASE选项决定是否随机地改变物理内存起始地址memstart_addr</li>
<li>15行：保留kernel 映像的内存区间</li>
<li>17～23行：在（1&#x2F;2）代码片段中为initrd保留了足够的内存区间，这里将物理地址initrd_start和initrd_end转换成对应的虚拟地址并保存</li>
<li>26行：将保留与DTB有关的三种内存区间：<ul>
<li>用于存储DTB的内存区间</li>
<li>DTB头部的off_mem_rsvmap成员会指向描述预留内存区块的信息（二进制形式），解析并保留这些内存区间</li>
<li>DTB中<code>reserved-mem</code>节点指定的内存区间</li>
</ul>
</li>
<li>29～40行：在reserved memblock中保留设备驱动（DMA for Coherent &#x2F; CMA for DMA）所需的DMA物理内存区间，并交给CMA（Contiguous Memory Allocator）进行管理。为了初始化CMA，将已保留的连续内存区间注册入cma_areas数组。</li>
<li>42行：允许memblock regions数组扩容</li>
</ul>
<h3 id="memblock分配"><a href="#memblock分配" class="headerlink" title="memblock分配"></a>memblock分配</h3><p>&ensp;&ensp;&ensp;&ensp;在内核启动的早期和内存热插拔「hotplug」过程都会使用涉及内存分配与释放的各种memblock API。如下图所示给出了在分配内时memblock API的调用流程。</p>
<p><img data-src="/images/22/memblock_alloc.svg" alt="memblock_alloc.svg"></p>
<center>图5 memblock_alloc的调用关系</center>

<p>&ensp;&ensp;&ensp;&ensp;接下来，让我们仔细研究一下memblcok分配过程中涉及的各种函数。</p>
<h4 id="memblock-alloc：从memblock中分配内存"><a href="#memblock-alloc：从memblock中分配内存" class="headerlink" title="memblock_alloc：从memblock中分配内存"></a>memblock_alloc：从memblock中分配内存</h4><p>&ensp;&ensp;&ensp;&ensp;size是从memblock分配时要求的内存区间长度，align是使内存区间起始地址对齐的数值，这两参数直接传递给被调用的memblock_alloc_base函数。此外，指定max_addr为MEMBLOCK_ALLOC_ACCESSIBLE来限定可分配内存的最大物理地址。<br><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">phys_addr_t</span> __init <span class="title function_">memblock_alloc</span><span class="params">(<span class="type">phys_addr_t</span> size, <span class="type">phys_addr_t</span> align)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> memblock_alloc_base(size, align, MEMBLOCK_ALLOC_ACCESSIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解了上面的函数后，我们查看下面这个函数的实现。<br><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">phys_addr_t</span> __init <span class="title function_">memblock_alloc_base</span><span class="params">(<span class="type">phys_addr_t</span> size, <span class="type">phys_addr_t</span> align, <span class="type">phys_addr_t</span> max_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">phys_addr_t</span> alloc;</span><br><span class="line"></span><br><span class="line">	alloc = __memblock_alloc_base(size, align, max_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc == <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;ERROR: Failed to allocate %pa bytes below %pa.\n&quot;</span>,</span><br><span class="line">		      &amp;size, &amp;max_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> alloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码尝试在没有NUMA内存节点（nid）和flags限定的情况下分配空闲内存区间。<br>mm&#x2F;memblock.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">phys_addr_t</span> __init __memblock_alloc_base(<span class="type">phys_addr_t</span> size, <span class="type">phys_addr_t</span> align, <span class="type">phys_addr_t</span> max_addr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> memblock_alloc_base_nid(size, align, max_addr, NUMA_NO_NODE,</span><br><span class="line">				       MEMBLOCK_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面代码指定了memblock分配范围的起始为0。<br><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">phys_addr_t</span> __init <span class="title function_">memblock_alloc_base_nid</span><span class="params">(<span class="type">phys_addr_t</span> size,</span></span><br><span class="line"><span class="params">					<span class="type">phys_addr_t</span> align, <span class="type">phys_addr_t</span> max_addr,</span></span><br><span class="line"><span class="params">					<span class="type">int</span> nid, <span class="keyword">enum</span> memblock_flags flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> memblock_alloc_range_nid(size, align, <span class="number">0</span>, max_addr, nid, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="memblock-alloc-range-nid：从特定memblock范围分配内存"><a href="#memblock-alloc-range-nid：从特定memblock范围分配内存" class="headerlink" title="memblock_alloc_range_nid：从特定memblock范围分配内存"></a>memblock_alloc_range_nid：从特定memblock范围分配内存</h4><p>&ensp;&ensp;&ensp;&ensp;在分配范围、NUMA内存节点和flags限定的情况下寻找空闲内存区间，并将合适的内存区间插入reserved memblock，指示该区间已被使用和保留。<br><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">phys_addr_t</span> __init <span class="title function_">memblock_alloc_range_nid</span><span class="params">(<span class="type">phys_addr_t</span> size,</span></span><br><span class="line"><span class="params">					<span class="type">phys_addr_t</span> align, <span class="type">phys_addr_t</span> start,</span></span><br><span class="line"><span class="params">					<span class="type">phys_addr_t</span> end, <span class="type">int</span> nid,</span></span><br><span class="line"><span class="params">					<span class="keyword">enum</span> memblock_flags flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">phys_addr_t</span> found;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!align)</span><br><span class="line">		align = SMP_CACHE_BYTES;</span><br><span class="line"></span><br><span class="line">	found = memblock_find_in_range_node(size, align, start, end, nid,</span><br><span class="line">					    flags);</span><br><span class="line">	<span class="keyword">if</span> (found &amp;&amp; !memblock_reserve(found, size)) &#123;</span><br><span class="line">		kmemleak_alloc_phys(found, size, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> found;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>8～9行：若align未设置，将系统的硬件高速缓存行大小赋值给align</li>
<li>11～12行：使用要求的分配范围、内存节点和flags搜寻一个合适的空闲内存区间</li>
<li>13～17行：如果寻找到了，将空闲内存区间插入reserved memblock，指示这段区间已被使用保留。若分配失败，返回0。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;如图6所示显示了memblock_find_in_range_node的处理流程。</p>
<p><img data-src="/images/22/memblock_find.svg" alt="memblock_find.svg"></p>
<center>图6 搜寻特定大小内存块的处理流程</center>

<p><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">phys_addr_t</span> __init_memblock</span><br><span class="line">__memblock_find_range_top_down(<span class="type">phys_addr_t</span> start, <span class="type">phys_addr_t</span> end,</span><br><span class="line">			       <span class="type">phys_addr_t</span> size, <span class="type">phys_addr_t</span> align, <span class="type">int</span> nid,</span><br><span class="line">			       <span class="keyword">enum</span> memblock_flags flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">phys_addr_t</span> this_start, this_end, cand;</span><br><span class="line">	u64 i;</span><br><span class="line"></span><br><span class="line">	for_each_free_mem_range_reverse(i, nid, flags, &amp;this_start, &amp;this_end,</span><br><span class="line">					<span class="literal">NULL</span>) &#123;</span><br><span class="line">		this_start = clamp(this_start, start, end);</span><br><span class="line">		this_end = clamp(this_end, start, end);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (this_end &lt; size)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		cand = round_down(this_end - size, align);</span><br><span class="line">		<span class="keyword">if</span> (cand &gt;= this_start)</span><br><span class="line">			<span class="keyword">return</span> cand;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9～20行：自顶向下地搜寻空闲内存区间，即包含在memory membock但不包含在reserved memblock。如果寻找到的空闲内存来自指定的内存节点（@nid），位于@start~@end范围内，那么从中截取一个子区间，使其起始地址与@align对齐，区间长度大于等于@size，最后得到一个满足这些条件的子区间，并返回该子区间的首地址。</p>
<ul>
<li>循环逐个地搜寻空闲内存区间</li>
<li>若空闲内存区间的尾地址小于size，那么舍弃这个区间，继续进行下一轮搜寻</li>
<li>以this_end为准线向下延伸得到一个不小于@size的子区间，并且通过向下取整的方式使其起始地址对齐@align</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;如图7所示，假如在执行__memblock_find_range_top_down函数时内存已有这些使用和保留，那么在循环搜寻时会得到7个空闲内存区间，不过只有4个内存区间在要求的范围内，因此会依次从这4个内存区间寻找符合要求的子区间。 </p>
<p><img data-src="/images/22/memblock_example_iteration.svg" alt="memblock_example_iteration.svg"></p>
<center>图7 memblock iteration example</center>

<p>&ensp;&ensp;&ensp;&ensp;若不考虑内存节点属性，使用下面函数直接将一个基地址（base）和区间长度（size）给定的内存区间加入reserved memblock。<br><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init_memblock <span class="title function_">memblock_reserve</span><span class="params">(<span class="type">phys_addr_t</span> base, <span class="type">phys_addr_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">phys_addr_t</span> end = base + size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	memblock_dbg(<span class="string">&quot;memblock_reserve: [%pa-%pa] %pF\n&quot;</span>,</span><br><span class="line">		     &amp;base, &amp;end, (<span class="type">void</span> *)_RET_IP_);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> memblock_add_range(&amp;memblock.reserved, base, size, MAX_NUMNODES, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="memblock增添"><a href="#memblock增添" class="headerlink" title="memblock增添"></a>memblock增添</h3><p>&ensp;&ensp;&ensp;&ensp;memblock_add函数只能用于非NUMA系统添加可用物理内存。NUMA系统需要使用具有nid参数的memblock_add_node函数添加NUMA节点中可用物理内存。尽管在设计芯片时会考虑绝不让各个物理内存区域互相重叠，但是可能存在例外情况，并不能保证注册的内存区域一定不与已注册的内存区域出现重叠。如图8所示显示了向memory memblock添加可用物理内存区域的处理流程。</p>
<p><img data-src="/images/22/memblock_add_node.svg" alt="memblock_add_node.svg"></p>
<center>图8 memblock添加的处理流程</center>

<p>&ensp;&ensp;&ensp;&ensp;如图9所示，如果不考虑区间的内存节点属性，当在插入新的内存区域时有可能与已有区间重叠，这时会出现memblock的第一种合并。</p>
<p><img data-src="/images/22/memblock_merge.svg" alt="memblock_merge.svg"></p>
<center>图9 第一种memblock合并</center>

<h4 id="memblock-add-向memory-memblock添加内存区域"><a href="#memblock-add-向memory-memblock添加内存区域" class="headerlink" title="memblock_add: 向memory memblock添加内存区域"></a>memblock_add: 向memory memblock添加内存区域</h4><p>&ensp;&ensp;&ensp;&ensp;由于这个函数只用于注册UMA系统中可用物理内存，因此不必设置描述内存区间的所有属性。只需设置base和size来指定起始物理地址和区间长度，区间所属的内存节点nid默认地设定为MAX_NUMNODES，以及区间flags默认地设为0，指示区间无任何特殊要求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init_memblock <span class="title function_">memblock_add</span><span class="params">(<span class="type">phys_addr_t</span> base, <span class="type">phys_addr_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> memblock_add_range(&amp;memblock.memory, base, size, MAX_NUMNODES, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数将直接调用memblock_add_range函数。</p>
<h4 id="memblock-add-range-将特定内存区间注册入memblock"><a href="#memblock-add-range-将特定内存区间注册入memblock" class="headerlink" title="memblock_add_range: 将特定内存区间注册入memblock"></a>memblock_add_range: 将特定内存区间注册入memblock</h4><p>&ensp;&ensp;&ensp;&ensp;这个函数将具体的内存区间添加到特定类型的memblock。即使新插入的内存区间与已存有的内存区间出现重叠，在插入新内存区间时并不会改变重叠的内存区间，只是将没有重叠的新内存区间插入。在插入之后，相邻且属性兼容的内存区间会合并成一个内存区间。这个函数返回值只是0。</p>
<p>在mm&#x2F;memblock.c中的memblock_add_range函数(1&#x2F;2)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init_memblock <span class="title function_">memblock_add_range</span><span class="params">(<span class="keyword">struct</span> memblock_type *type,</span></span><br><span class="line"><span class="params">				<span class="type">phys_addr_t</span> base, <span class="type">phys_addr_t</span> size,</span></span><br><span class="line"><span class="params">				<span class="type">int</span> nid, <span class="keyword">enum</span> memblock_flags flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> insert = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">phys_addr_t</span> obase = base;</span><br><span class="line">	<span class="type">phys_addr_t</span> end = base + memblock_cap_size(base, &amp;size);</span><br><span class="line">	<span class="type">int</span> idx, nr_new;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> *<span class="title">rgn</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!size)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* special case for empty array */</span></span><br><span class="line">	<span class="keyword">if</span> (type-&gt;regions[<span class="number">0</span>].size == <span class="number">0</span>) &#123;</span><br><span class="line">		WARN_ON(type-&gt;cnt != <span class="number">1</span> || type-&gt;total_size);</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].base = base;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].size = size;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].flags = flags;</span><br><span class="line">		memblock_set_region_node(&amp;type-&gt;regions[<span class="number">0</span>], nid);</span><br><span class="line">		type-&gt;total_size = size;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">repeat:</span><br><span class="line">	base = obase;</span><br><span class="line">	nr_new = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_memblock_type(idx, type, rgn) &#123;</span><br><span class="line">		<span class="type">phys_addr_t</span> rbase = rgn-&gt;base;</span><br><span class="line">		<span class="type">phys_addr_t</span> rend = rbase + rgn-&gt;size;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rbase &gt;= end)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (rend &lt;= base)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rbase &gt; base) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_MEMBLOCK_NODE_MAP</span></span><br><span class="line">			WARN_ON(nid != memblock_get_region_node(rgn));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			WARN_ON(flags != rgn-&gt;flags);</span><br><span class="line">			nr_new++;</span><br><span class="line">			<span class="keyword">if</span> (insert)</span><br><span class="line">				memblock_insert_region(type, idx++, base,</span><br><span class="line">						       rbase - base, nid,</span><br><span class="line">						       flags);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* area below @rend is dealt with, forget about it */</span></span><br><span class="line">		base = min(rend, end);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<ul>
<li>15～22行：如果memblock还没有具体的内存区间，不需要考虑重叠问题，直接根据参数设置第一个内存区间，然后退出这个函数。</li>
<li>24行：借助repeat标签能够再重复执行一次插入过程，第一次执行插入被成为first round，第二次执行插入被成为second round。在first round仅更新nr_new来统计需要插入的内存区间个数，在second round才真正地将这些非重叠的内存区间逐个插入特定类型的memblock。</li>
<li>28行：通过循环遍历特定类型的memblock内存区间，判断是否与新插入的区间重叠。</li>
<li>32行：新内存区间位于相比较的内存区间之下且不重叠，因此不必再继续循环遍历。</li>
<li>34行：新内存区间位于相比较的内存区间之上且不重叠，因而需要继续循环遍历并与下一区间进行比较。</li>
<li>37行：新内存区间与相比较内存区间的底部重叠，所以在此，新内存区间的非重叠部分将会被插入，并且插入的内存区间肯定与比较区间相邻。</li>
<li>49行：若请求的新内存区间还存在需要被插入的子内存区间，提前更新base为下一个待插入子区间的起始地址。</li>
</ul>
<p>在mm&#x2F;memblock.c中的memblock_add_range函数(2&#x2F;2)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* insert the remaining portion */</span></span><br><span class="line">	<span class="keyword">if</span> (base &lt; end) &#123;</span><br><span class="line">		nr_new++;</span><br><span class="line">		<span class="keyword">if</span> (insert)</span><br><span class="line">			memblock_insert_region(type, idx, base, end - base,</span><br><span class="line">					       nid, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nr_new)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!insert) &#123;</span><br><span class="line">		<span class="keyword">while</span> (type-&gt;cnt + nr_new &gt; type-&gt;max)</span><br><span class="line">			<span class="keyword">if</span> (memblock_double_array(type, obase, size) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		insert = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		memblock_merge_regions(type);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4行：在循环遍历结束后，若新内存区间的末端还有需要插入的子区间，这里将待插入子区间加入特定类型的memblock</li>
<li>14行：在first round，只要已有区间个数和待插入区间个数的总和超过memblock最多能管理的区间个数，将重复调用memblock_double_array函数使memblock regions数组空间（regions数组的元素数量）翻倍。</li>
<li>20行：在second round， 如果新插入的区间与已有区间相邻且有相同flag，将使用memblock_merge_regions函数将这些区间合并。</li>
</ul>
<h4 id="memblock-insert-region函数：将内存区间插入memblock"><a href="#memblock-insert-region函数：将内存区间插入memblock" class="headerlink" title="memblock_insert_region函数：将内存区间插入memblock"></a>memblock_insert_region函数：将内存区间插入memblock</h4><p>&ensp;&ensp;&ensp;&ensp;将内存区间插入到具体memblock的给定位置，即在regions数组的指定位置插入一个memblock_region实例。memblock_type实例的cnt字段增加1，total_size字段累加size。</p>
<p>mm&#x2F;memblock.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init_memblock <span class="title function_">memblock_insert_region</span><span class="params">(<span class="keyword">struct</span> memblock_type *type,</span></span><br><span class="line"><span class="params">						   <span class="type">int</span> idx, <span class="type">phys_addr_t</span> base,</span></span><br><span class="line"><span class="params">						   <span class="type">phys_addr_t</span> size,</span></span><br><span class="line"><span class="params">						   <span class="type">int</span> nid,</span></span><br><span class="line"><span class="params">						   <span class="keyword">enum</span> memblock_flags flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> *<span class="title">rgn</span> =</span> &amp;type-&gt;regions[idx];</span><br><span class="line"></span><br><span class="line">	BUG_ON(type-&gt;cnt &gt;= type-&gt;max);</span><br><span class="line">	memmove(rgn + <span class="number">1</span>, rgn, (type-&gt;cnt - idx) * <span class="keyword">sizeof</span>(*rgn));</span><br><span class="line">	rgn-&gt;base = base;</span><br><span class="line">	rgn-&gt;size = size;</span><br><span class="line">	rgn-&gt;flags = flags;</span><br><span class="line">	memblock_set_region_node(rgn, nid);</span><br><span class="line">	type-&gt;cnt++;</span><br><span class="line">	type-&gt;total_size += size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>10行：从给定位置的区间到末尾区间都往后移动一个位置。</li>
<li>14行：设置区间的nid（node ID）属性，更好地支持NUMA架构系统。</li>
</ul>
<h4 id="memblock-double-array函数：使memblock能管理的区间翻倍"><a href="#memblock-double-array函数：使memblock能管理的区间翻倍" class="headerlink" title="memblock_double_array函数：使memblock能管理的区间翻倍"></a>memblock_double_array函数：使memblock能管理的区间翻倍</h4><p>&ensp;&ensp;&ensp;&ensp;用于描述内存区间的memblock regions数组初始化时较小，因此在需要扩大时调用这个函数使数组大小翻倍。根据如下代码分析memblock_double_array函数。</p>
<p>在mm&#x2F;memblock.c中memblock_double_array函数（1&#x2F;2）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init_memblock <span class="title function_">memblock_double_array</span><span class="params">(<span class="keyword">struct</span> memblock_type *type,</span></span><br><span class="line"><span class="params">						<span class="type">phys_addr_t</span> new_area_start,</span></span><br><span class="line"><span class="params">						<span class="type">phys_addr_t</span> new_area_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> *<span class="title">new_array</span>, *<span class="title">old_array</span>;</span></span><br><span class="line">	<span class="type">phys_addr_t</span> old_alloc_size, new_alloc_size;</span><br><span class="line">	<span class="type">phys_addr_t</span> old_size, new_size, addr, new_end;</span><br><span class="line">	<span class="type">int</span> use_slab = slab_is_available();</span><br><span class="line">	<span class="type">int</span> *in_slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!memblock_can_resize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Calculate new doubled size */</span></span><br><span class="line">	old_size = type-&gt;max * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> memblock_region);</span><br><span class="line">	new_size = old_size &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	old_alloc_size = PAGE_ALIGN(old_size);</span><br><span class="line">	new_alloc_size = PAGE_ALIGN(new_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retrieve the slab flag */</span></span><br><span class="line">	<span class="keyword">if</span> (type == &amp;memblock.memory)</span><br><span class="line">		in_slab = &amp;memblock_memory_in_slab;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		in_slab = &amp;memblock_reserved_in_slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (use_slab) &#123;</span><br><span class="line">		new_array = kmalloc(new_size, GFP_KERNEL);</span><br><span class="line">		addr = new_array ? __pa(new_array) : <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* only exclude range when trying to double reserved.regions */</span></span><br><span class="line">		<span class="keyword">if</span> (type != &amp;memblock.reserved)</span><br><span class="line">			new_area_start = new_area_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		addr = memblock_find_in_range(new_area_start + new_area_size,</span><br><span class="line">						memblock.current_limit,</span><br><span class="line">						new_alloc_size, PAGE_SIZE);</span><br><span class="line">		<span class="keyword">if</span> (!addr &amp;&amp; new_area_size)</span><br><span class="line">			addr = memblock_find_in_range(<span class="number">0</span>,</span><br><span class="line">				min(new_area_start, memblock.current_limit),</span><br><span class="line">				new_alloc_size, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">		new_array = addr ? __va(addr) : <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br></pre></td></tr></table></figure>

<ul>
<li>11～12行：memblock_allow_resize函数用于设置全局变量memblock_can_resize。如果memblock_allow_resize函数没有调用，那么memblock_can_resize未被设置为1，因此这个函数将不起作用。</li>
<li>16行：计算准备重新分配的regions数组大小，其是已有regions数组大小的两陪。</li>
<li>22行：为了明确指定类型（memblock_type实例）的regions数组是编译时static定义的或通过memblock操作动态分配的，还是通过slab操作动态分配的。</li>
<li>27行：当正式的slab内存分配器起作用时，通过kmalloc函数给regions数组分配需要的内存。</li>
<li>32行：如果slab不可用，尝试使用来自memblock_add函数的memblock_find_in_range函数去寻找一段空闲内存空间，存放用于管理区间的regions数组。如果指定memblock的类型不是reserved类型，即memory类型，那么要求的分配范围将从0开始。<br>如果在可用物理内存注册入memory类型的memblock期间需要扩充regions数组，那么新分配的内存空间只可能从以前注册的物理内存中搜寻得到。无论如何，新分配的内存空间不能与已用的内存区间相互干涉。因此为了避免与指定内存范围重叠，在第一次搜寻时会从该范围之上的内存寻找空闲内存区间。</li>
<li>38行：如果memblock的类型是reserved且在第一次搜寻没有找到合适的内存空间，为了避免与指定内存范围重叠，将从该范围之下的内存搜寻空闲内存区间。</li>
</ul>
<p>memblock_double_array函数（2&#x2F;2）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!addr) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;memblock: Failed to double %s array from %ld to %ld entries !\n&quot;</span>,</span><br><span class="line">		       type-&gt;name, type-&gt;max, type-&gt;max * <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	new_end = addr + new_size - <span class="number">1</span>;</span><br><span class="line">	memblock_dbg(<span class="string">&quot;memblock: %s is doubled to %ld at [%pa-%pa]&quot;</span>,</span><br><span class="line">			type-&gt;name, type-&gt;max * <span class="number">2</span>, &amp;addr, &amp;new_end);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(new_array, type-&gt;regions, old_size);</span><br><span class="line">	<span class="built_in">memset</span>(new_array + type-&gt;max, <span class="number">0</span>, old_size);</span><br><span class="line">	old_array = type-&gt;regions;</span><br><span class="line">	type-&gt;regions = new_array;</span><br><span class="line">	type-&gt;max &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Free old array. We needn&#x27;t free it if the array is the static one */</span></span><br><span class="line">	<span class="keyword">if</span> (*in_slab)</span><br><span class="line">		kfree(old_array);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (old_array != memblock_memory_init_regions &amp;&amp;</span><br><span class="line">		 old_array != memblock_reserved_init_regions)</span><br><span class="line">		memblock_free(__pa(old_array), old_alloc_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!use_slab)</span><br><span class="line">		BUG_ON(memblock_reserve(addr, new_alloc_size));</span><br><span class="line"></span><br><span class="line">	*in_slab = use_slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>13～17行：将已有regions数组的所有内容全部复制到新分配的内存空间内，剩余未用的部分全部清零。而且还要更新memblock_type实例的max字段为原来值的两倍。</li>
<li>21行：将老regions数组占用的内存空间释放。但由于最初的regions数组是在编译时定义的，因此不能删除和舍弃。只要regions数组不是最初的那个，会根据分配器类型对其采用不同释放方法。<ul>
<li>如果已使用了slab，用kfree函数释放占用的内存空间</li>
<li>如果slab还不可用，用memblock_free函数释放已用的内存空间</li>
</ul>
</li>
</ul>
<h4 id="memblock-merge-regions函数：将memblock的相邻内存区间合并"><a href="#memblock-merge-regions函数：将memblock的相邻内存区间合并" class="headerlink" title="memblock_merge_regions函数：将memblock的相邻内存区间合并"></a>memblock_merge_regions函数：将memblock的相邻内存区间合并</h4><p>&ensp;&ensp;&ensp;&ensp;如果相邻内存区间具有相同flags和nid，合并这两区间为一个较大区间。</p>
<p>mm&#x2F;memblock.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init_memblock <span class="title function_">memblock_merge_regions</span><span class="params">(<span class="keyword">struct</span> memblock_type *type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* cnt never goes below 1 */</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; type-&gt;cnt - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> *<span class="title">this</span> =</span> &amp;type-&gt;regions[i];</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> *<span class="title">next</span> =</span> &amp;type-&gt;regions[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (this-&gt;base + this-&gt;size != next-&gt;base ||</span><br><span class="line">		    memblock_get_region_node(this) !=</span><br><span class="line">		    memblock_get_region_node(next) ||</span><br><span class="line">		    this-&gt;flags != next-&gt;flags) &#123;</span><br><span class="line">			BUG_ON(this-&gt;base + this-&gt;size &gt; next-&gt;base);</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this-&gt;size += next-&gt;size;</span><br><span class="line">		<span class="comment">/* move forward from next + 1, index of which is i + 2 */</span></span><br><span class="line">		memmove(next, next + <span class="number">1</span>, (type-&gt;cnt - (i + <span class="number">2</span>)) * <span class="keyword">sizeof</span>(*next));</span><br><span class="line">		type-&gt;cnt--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>6行：一旦合并，指定类型memblock中的区间个数（cnt）会递减，从而减少循环次数。</li>
<li>10行：如果两个区间不相邻或区间的flags不同，这对区间不能合并，继续检查下一对区间。</li>
<li>19行：若确定这对区间符合限定条件，合并它们。</li>
</ul>
<p>如图10所示，除非具有不同的nid或flags属性，否则相邻的多个区间将被合并。</p>
<p><img data-src="/images/22/memblock_merge_II.svg" alt="memblock_merge_II.svg"></p>
<center>图10 第二种memblock合并</center>

<h3 id="memblock删除"><a href="#memblock删除" class="headerlink" title="memblock删除"></a>memblock删除</h3><p>&ensp;&ensp;&ensp;&ensp;当调用memblock_free和memblock_remove函数时，会执行如图11所示的处理流程。</p>
<p><img data-src="/images/22/memblock_remove.svg" alt="memblock_remove.svg"></p>
<center>图11 memblock_remove函数的执行流程</center>

<h4 id="memblock-free函数：从reserved-memblock中移除一个内存区间"><a href="#memblock-free函数：从reserved-memblock中移除一个内存区间" class="headerlink" title="memblock_free函数：从reserved memblock中移除一个内存区间"></a>memblock_free函数：从reserved memblock中移除一个内存区间</h4><p>&ensp;&ensp;&ensp;&ensp;如果memblock_free函数被调用，则调用memblock_remove_range函数将由起始物理地址base和区间长度size限定的内存区间从reserved memblock中删除。</p>
<p><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init_memblock <span class="title function_">memblock_free</span><span class="params">(<span class="type">phys_addr_t</span> base, <span class="type">phys_addr_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">phys_addr_t</span> end = base + size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	memblock_dbg(<span class="string">&quot;   memblock_free: [%pa-%pa] %pF\n&quot;</span>,</span><br><span class="line">		     &amp;base, &amp;end, (<span class="type">void</span> *)_RET_IP_);</span><br><span class="line"></span><br><span class="line">	kmemleak_free_part_phys(base, size);</span><br><span class="line">	<span class="keyword">return</span> memblock_remove_range(&amp;memblock.reserved, base, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="memblock-remove函数：从memory-memblock中移除一个内存空间"><a href="#memblock-remove函数：从memory-memblock中移除一个内存空间" class="headerlink" title="memblock_remove函数：从memory memblock中移除一个内存空间"></a>memblock_remove函数：从memory memblock中移除一个内存空间</h4><p>&ensp;&ensp;&ensp;&ensp;与memblock_free函数相似，这个函数调用memblock_remove_range函数将由起始物理地址base和区间长度size限定的内存区间从memory memblock中移除。</p>
<p><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init_memblock <span class="title function_">memblock_remove</span><span class="params">(<span class="type">phys_addr_t</span> base, <span class="type">phys_addr_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">phys_addr_t</span> end = base + size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	memblock_dbg(<span class="string">&quot;memblock_remove: [%pa-%pa] %pS\n&quot;</span>,</span><br><span class="line">		     &amp;base, &amp;end, (<span class="type">void</span> *)_RET_IP_);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> memblock_remove_range(&amp;memblock.memory, base, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="memblock-remove-range函数：从一个memblock中移除指定区间"><a href="#memblock-remove-range函数：从一个memblock中移除指定区间" class="headerlink" title="memblock_remove_range函数：从一个memblock中移除指定区间"></a>memblock_remove_range函数：从一个memblock中移除指定区间</h4><p>&ensp;&ensp;&ensp;&ensp;从指定类型的memblock中移除请求的区间。</p>
<p><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init_memblock <span class="title function_">memblock_remove_range</span><span class="params">(<span class="keyword">struct</span> memblock_type *type,</span></span><br><span class="line"><span class="params">					  <span class="type">phys_addr_t</span> base, <span class="type">phys_addr_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> start_rgn, end_rgn;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line"></span><br><span class="line">	ret = memblock_isolate_range(type, base, size, &amp;start_rgn, &amp;end_rgn);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = end_rgn - <span class="number">1</span>; i &gt;= start_rgn; i--)</span><br><span class="line">		memblock_remove_region(type, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>7行：将待删除区间从已存在内存区间分离出来</li>
<li>11行：从end待删除区间的索引值到start待删除区间的索引值逆序地循环调用memblock_remove_region函数将对应的区间删除。相反顺序的循环是为了减少内存复制的大小（内存移动的数据量）。</li>
</ul>
<h4 id="memblock-isolate-range函数：-从给定memblock中分离出请求的区间"><a href="#memblock-isolate-range函数：-从给定memblock中分离出请求的区间" class="headerlink" title="memblock_isolate_range函数： 从给定memblock中分离出请求的区间"></a>memblock_isolate_range函数： 从给定memblock中分离出请求的区间</h4><p>&ensp;&ensp;&ensp;&ensp;从与请求区间重叠的memblock区间中分离出待删除区间。起始待删除区间的索引值保存在输出参数start_rgn中，而末尾待删除区间的索引值保存在end_rgn中。如果memblock任意区间都没有与请求区间重叠，两个输出参数的值都是0.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init_memblock <span class="title function_">memblock_isolate_range</span><span class="params">(<span class="keyword">struct</span> memblock_type *type,</span></span><br><span class="line"><span class="params">					<span class="type">phys_addr_t</span> base, <span class="type">phys_addr_t</span> size,</span></span><br><span class="line"><span class="params">					<span class="type">int</span> *start_rgn, <span class="type">int</span> *end_rgn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">phys_addr_t</span> end = base + memblock_cap_size(base, &amp;size);</span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> *<span class="title">rgn</span>;</span></span><br><span class="line"></span><br><span class="line">	*start_rgn = *end_rgn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!size)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;ll create at most two more regions */</span></span><br><span class="line">	<span class="keyword">while</span> (type-&gt;cnt + <span class="number">2</span> &gt; type-&gt;max)</span><br><span class="line">		<span class="keyword">if</span> (memblock_double_array(type, base, size) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	for_each_memblock_type(idx, type, rgn) &#123;</span><br><span class="line">		<span class="type">phys_addr_t</span> rbase = rgn-&gt;base;</span><br><span class="line">		<span class="type">phys_addr_t</span> rend = rbase + rgn-&gt;size;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rbase &gt;= end)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (rend &lt;= base)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rbase &lt; base) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * @rgn intersects from below.  Split and continue</span></span><br><span class="line"><span class="comment">			 * to process the next region - the new top half.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			rgn-&gt;base = base;</span><br><span class="line">			rgn-&gt;size -= base - rbase;</span><br><span class="line">			type-&gt;total_size -= base - rbase;</span><br><span class="line">			memblock_insert_region(type, idx, rbase, base - rbase,</span><br><span class="line">					       memblock_get_region_node(rgn),</span><br><span class="line">					       rgn-&gt;flags);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rend &gt; end) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * @rgn intersects from above.  Split and redo the</span></span><br><span class="line"><span class="comment">			 * current region - the new bottom half.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			rgn-&gt;base = end;</span><br><span class="line">			rgn-&gt;size -= end - rbase;</span><br><span class="line">			type-&gt;total_size -= end - rbase;</span><br><span class="line">			memblock_insert_region(type, idx--, rbase, end - rbase,</span><br><span class="line">					       memblock_get_region_node(rgn),</span><br><span class="line">					       rgn-&gt;flags);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* @rgn is fully contained, record it */</span></span><br><span class="line">			<span class="keyword">if</span> (!*end_rgn)</span><br><span class="line">				*start_rgn = idx;</span><br><span class="line">			*end_rgn = idx + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>5行：防止内存区间的结束物理地址超过体系架构支持的最大物理地址。</li>
<li>15行：扩充管理区间的regions数组，使其容量是原来的两倍。如果扩充失败，将返回<code>-ENOMEM</code>指示系统内存不足。</li>
<li>19行：会从memblock的第一区间循环遍历到最后一个区间，rbase和rend分别指的是当前遍历区间的起始物理地址和结束物理地址。</li>
<li>23行：如果当前区间的起始地址rbase不小于请求区间的结束地址，则不必再继续遍历后面的区间（下图所示的条件A）。</li>
<li>25行：如果当前区间的结束地址rend不大于请求区间的起始地址，则不可能重叠，因此需要继续遍历下一个区间（下图所示的条件B）。</li>
<li>28行：如果当前区间的起始物理地址小于请求区间的起始地址，也就是说，请求区间的起始地址位于当前区间内，两者出现重叠子区间，则按如下方式处理：（如下图所示的条件C）<br>首先以base为分界线从当前区间分离出包含重叠的上半部子区间，并且将上半部区间向上移动一个索引位置，其次将非重叠的下半部区间重新插入在给定memblock的当前索引位置。因此，这样会将当前区间拆分出两个子区间。</li>
<li>39行：如果当前区间的结束物理地址大于请求区间的结束物理地址，也就是说，请求区间的结束物理地址位于当前区间内，两者出现重叠子区间，则按如下方式处理：（如下图所示的条件D）：<br>首先以end为分界线从当前区间分离出非重叠的上半部子区间，并且将上半部区间向上移动一个索引位置，其次将包含重叠的下半部区间重新插入在给定memblock的当前索引位置，而且索引值idx减1。因此，这样也会将当前区间拆分出两个子区间。</li>
<li>50行：由于不满足上面任何一个条件，所以当前区间被包含于请求区间。在这种情况下，只有end_rgn还未更新，start_rgn才记录当前区间的索引值，但无论如何都会用当前索引值 + 1更新end_rgn。</li>
</ul>
<p><img data-src="/images/22/memblock_isolate_range.svg" alt="memblock_isolate_range.svg"></p>
<center>图12 memblock_isolate_range函数的执行流程</center>

<h4 id="memblock-remove-region函数：从具体memblock中删除指定区间"><a href="#memblock-remove-region函数：从具体memblock中删除指定区间" class="headerlink" title="memblock_remove_region函数：从具体memblock中删除指定区间"></a>memblock_remove_region函数：从具体memblock中删除指定区间</h4><p>&ensp;&ensp;&ensp;&ensp;从给定类型的memblock中删除指定索引位置的区间。</p>
<p><em>mm&#x2F;memblock.c</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init_memblock <span class="title function_">memblock_remove_region</span><span class="params">(<span class="keyword">struct</span> memblock_type *type, <span class="type">unsigned</span> <span class="type">long</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">	type-&gt;total_size -= type-&gt;regions[r].size;</span><br><span class="line">	memmove(&amp;type-&gt;regions[r], &amp;type-&gt;regions[r + <span class="number">1</span>],</span><br><span class="line">		(type-&gt;cnt - (r + <span class="number">1</span>)) * <span class="keyword">sizeof</span>(type-&gt;regions[r]));</span><br><span class="line">	type-&gt;cnt--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Special case for empty arrays */</span></span><br><span class="line">	<span class="keyword">if</span> (type-&gt;cnt == <span class="number">0</span>) &#123;</span><br><span class="line">		WARN_ON(type-&gt;total_size != <span class="number">0</span>);</span><br><span class="line">		type-&gt;cnt = <span class="number">1</span>;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].base = <span class="number">0</span>;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].size = <span class="number">0</span>;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].flags = <span class="number">0</span>;</span><br><span class="line">		memblock_set_region_node(&amp;type-&gt;regions[<span class="number">0</span>], MAX_NUMNODES);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3～6行：将带删除区间后面的所有区间都向前移动一个位置，并将cnt减1以及从total_size减去已删除区间的大小。</li>
<li>9行：如果彻底移除了当前memblock的所有区间，则要将type-&gt;cnt更新为1而不是0。出于设计缘故，即使memblock没有内存区间，type-&gt;cnt也要设置为1，但base和size字段需要清零。</li>
</ul>
]]></content>
      <categories>
        <category>memory management</category>
      </categories>
      <tags>
        <tag>memblock</tag>
      </tags>
  </entry>
  <entry>
    <title>构建XEN on ARM开发环境</title>
    <url>/posts/ccbdb993/</url>
    <content><![CDATA[<p>为了学习了解嵌入式虚拟化的技术，记录一下自己折腾的经历以及搭建验证开发环境的坑。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a> </li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.114</li>
</ul>
<hr>
<h3 id="交叉编译工具"><a href="#交叉编译工具" class="headerlink" title="交叉编译工具"></a>交叉编译工具</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/aarch64-linux-gnu/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-linux-gnu.tar.xz</span><br><span class="line"><span class="built_in">mkdir</span> toolchains</span><br><span class="line">tar -xJf aarch64-linux-gnu/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-linux-gnu.tar.xz -C toolchains</span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改环境变量PATH，使工具方便使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li><p>在文件末尾添加如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/path/to/toolchains/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-linux-gnu/bin</span><br></pre></td></tr></table></figure>
<p><strong>注意：根据实际情况，确保路径设置正确</strong></p>
</li>
<li><p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc -v</span><br></pre></td></tr></table></figure>
<p>在终端会输出aarch64-linux-gnu-gcc的配置及版本信息</p>
</li>
</ul>
<h3 id="配置和编译XEN"><a href="#配置和编译XEN" class="headerlink" title="配置和编译XEN"></a>配置和编译XEN</h3><h4 id="下载xen-4-13-0源代码"><a href="#下载xen-4-13-0源代码" class="headerlink" title="下载xen-4.13.0源代码"></a>下载xen-4.13.0源代码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/chasinglulu/xen.git -b rock960c-xen</span><br><span class="line"><span class="built_in">cd</span> xen</span><br></pre></td></tr></table></figure>
<p>在上面的分支内我已经为Rock960C开发板支持了<code>earlyprintk</code>功能，方便后面我通过输出进行调试和分析。下面给你了使能<code>earlyprinkt</code>功能的补丁：</p>
<figure class="highlight patch"><table><tr><td class="code"><pre><span class="line">commit 4c0e2f50c9114510c04ec42aeaffff9f15f51807</span><br><span class="line">Author: chasinglulu &lt;wangkartx@gmail.com&gt;</span><br><span class="line">Date:   Sat Apr 18 20:18:57 2020 +0800</span><br><span class="line"></span><br><span class="line">    support earlyprintk for RK3399 SoC</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/xen/arch/arm/Rules.mk b/xen/arch/arm/Rules.mk</span></span><br><span class="line"><span class="comment">index 3d9a0ed..e989e9c 100644</span></span><br><span class="line"><span class="comment">--- a/xen/arch/arm/Rules.mk</span></span><br><span class="line"><span class="comment">+++ b/xen/arch/arm/Rules.mk</span></span><br><span class="line"><span class="meta">@@ -47,6 +47,7 @@</span> EARLY_PRINTK_vexpress       := pl011,0x1c090000</span><br><span class="line"> EARLY_PRINTK_xgene-mcdivitt := 8250,0x1c021000,2</span><br><span class="line"> EARLY_PRINTK_xgene-storm    := 8250,0x1c020000,2</span><br><span class="line"> EARLY_PRINTK_zynqmp         := cadence,0xff000000</span><br><span class="line"><span class="addition">+EARLY_PRINTK_rk3399                    := 8250,0xff1a0000,2</span></span><br><span class="line"> </span><br><span class="line"> ifneq ($(EARLY_PRINTK_$(CONFIG_EARLY_PRINTK)),)</span><br><span class="line"> EARLY_PRINTK_CFG := $(subst $(comma), ,$(EARLY_PRINTK_$(CONFIG_EARLY_PRINTK)))</span><br></pre></td></tr></table></figure>
<h4 id="配置Hypervisor"><a href="#配置Hypervisor" class="headerlink" title="配置Hypervisor"></a>配置Hypervisor</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xen</span><br><span class="line">make menuconfig CROSS_COMPILE=aarch64-linux-gnu- XEN_TARGET_ARCH=arm64</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/11/enable_debugging_option.png" alt="enable_debugging_option"></p>
<center>图1 启用debugging选项</center>

<h4 id="编译Hypervisor"><a href="#编译Hypervisor" class="headerlink" title="编译Hypervisor"></a>编译Hypervisor</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line"> make dist-xen CROSS_COMPILE=aarch64-linux-gnu- XEN_TARGET_ARCH=arm64 debug=y CONFIG_EARLY_PRINTK=rk3399</span><br></pre></td></tr></table></figure>
<p>利用mkimage工具制作uboot能够启动加载的Image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkimage -A arm64 -T kernel -a 0x02000000 -e 0x02000000 -C none -d ./xen/xen xen-4.13.0-uImage</span><br></pre></td></tr></table></figure>

<p>至此，我们已经完成Xen的配置与编译，等下面的内核和文件系统编译生成后，我们就能够进行不断重复的调试验证过程。</p>
<h3 id="构建dom0-kernel"><a href="#构建dom0-kernel" class="headerlink" title="构建dom0 kernel"></a>构建dom0 kernel</h3><h4 id="获取内核源代码"><a href="#获取内核源代码" class="headerlink" title="获取内核源代码"></a>获取内核源代码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/chasinglulu/linux.git -b longterm-4.19</span><br><span class="line"><span class="built_in">cd</span> linux</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- xen_dom0_rock960c_defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j8</span><br></pre></td></tr></table></figure>
<h3 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h3><h4 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h4><p>ARM64 Xen在被Bootload启动引导时必须要以EL2模式执行。Rock960C开发板默认携带的u-boot已经能友好地启动XEN，而且uboot也不是本文的重点，因此不再详细说明uboot的编译构建。如果要的话，使用Rockchip提供的<a href="https://github.com/rockchip-linux/u-boot">rockchip-linux&#x2F;u-boot github</a>更新u-boot，构建方法参考<a href="https://github.com/rockchip-linux/u-boot/blob/next-dev/README">rockchip-linux&#x2F;u-boot github README</a>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wiki.xenproject.org/wiki/Xen_ARM_with_Virtualization_Extensions/Ibox3399">Xen ARM with Virtualization Extensions&#x2F;Ibox3399</a><br><a href="https://wiki.xenproject.org/wiki/Xen_ARM_with_Virtualization_Extensions">Xen ARM with Virtualization Extensions</a></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>aarch64</tag>
        <tag>xen</tag>
        <tag>arm64</tag>
      </tags>
  </entry>
  <entry>
    <title>(笔试 &amp; 面试)嵌入式C语言基础知识</title>
    <url>/posts/9fc93f25/</url>
    <content><![CDATA[<blockquote>
<p>把姿态放低，你会发现看不惯的人和事越来越少，琐碎的生活不再是一地鸡毛，你和世界的关系也越来越好。  —- 人民日报 《[夜读] 格局越大，姿态越低》</p>
</blockquote>
<p>通过最近几家公司的笔试及面试，发现他们不仅关注你是否知道存在这个东西，同时还需要你说出这些东西是怎么高效实现以及它们之间的区别。虽然我也答出七七八八，但能够明显发现自己有些基础不牢固，细节掌握不清楚，编码能力有点弱。做技术需要踏踏实实，一步一步脚印，从小事做起，从基础积累，细节决定成败，所以就此在这总结一下最近遇到所有问题及一些基础知识。</p>
<span id="more"></span>
<h3 id="strcpy及相关函数的实现"><a href="#strcpy及相关函数的实现" class="headerlink" title="strcpy及相关函数的实现"></a>strcpy及相关函数的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前提是dest具有足够的空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *tmp = dest;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((*dest++ = *src++) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		<span class="comment">/* nothing */</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这个函数为什么要返回<code>char *</code>类型指针？</strong><br>答： 林锐的《高质量C++编程指南》给出原文如下：</p>
<blockquote>
<p><strong>有时候函数可能不需要返回值，但为了增加灵活性如支持链式表达式，可以附加返回值。</strong><br>例如字符串复制函数strcpy 的原型：<br>char *strcpy(char *dest，const char *src);<br>strcpy 函数将src 拷贝至输出参数sdest 中，同时函数的返回值又是dest。<br>这样做并非多此一举，可以获得如下灵活性：<br>char str[20];<br>int length &#x3D; strlen( strcpy(str, “Hello World”) );</p>
</blockquote>
<h3 id="memcpy及相关函数的实现"><a href="#memcpy及相关函数的实现" class="headerlink" title="memcpy及相关函数的实现"></a>memcpy及相关函数的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前提是dest具有足够的空间， 没有考虑重叠问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *tmp = dest;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *s = src;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (count--)</span><br><span class="line">		*tmp++ = *s++;</span><br><span class="line">	<span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果dest与src指向的内存区域有重叠，怎么实现memcpy？</strong><br>答：代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * memmove实现考虑到了内存区域重叠问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *tmp;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dest &lt;= src) &#123;</span><br><span class="line">		tmp = dest;</span><br><span class="line">		s = src;</span><br><span class="line">		<span class="keyword">while</span> (count--)</span><br><span class="line">			*tmp++ = *s++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tmp = dest;</span><br><span class="line">		tmp += count;</span><br><span class="line">		s = src;</span><br><span class="line">		s += count;</span><br><span class="line">		<span class="keyword">while</span> (count--)</span><br><span class="line">			*--tmp = *--s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>由于<code>memcpy</code>不需要判断重叠，所以它的运行速度比memmove快，在确定dst和src不会重叠的情况下，可以使用<code>memcpy</code></strong></p>
<h3 id="strcpy与memcpy区别"><a href="#strcpy与memcpy区别" class="headerlink" title="strcpy与memcpy区别"></a>strcpy与memcpy区别</h3><ul>
<li>复制的内容不同，<code>strcpy</code>只能复制字符串，但<code>memcpy</code>可以复制任意内容，比如字符数组、整数、浮点数、结构体等</li>
<li>复制的方法不同， <code>strcpy</code>不需要指定长度，直到它遇到被复制字符串的结束符<code>\0</code>才会停止，所以容易溢出。但<code>memcpy</code>则是根据其第三个参数决定复制的长度</li>
<li>用途不同，通常在复制字符串时使用<code>strcpy</code>，而需要复制其他类型数据时一般用<code>memcpy</code></li>
</ul>
<h3 id="最大公约数-Greatest-common-divisor-和最小公倍数-Least-Common-Multiple"><a href="#最大公约数-Greatest-common-divisor-和最小公倍数-Least-Common-Multiple" class="headerlink" title="最大公约数(Greatest common divisor)和最小公倍数(Least Common Multiple)"></a>最大公约数(Greatest common divisor)和最小公倍数(Least Common Multiple)</h3><h4 id="欧几里德法-（辗转相除法）"><a href="#欧几里德法-（辗转相除法）" class="headerlink" title="欧几里德法 （辗转相除法）"></a>欧几里德法 （辗转相除法）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RECURSION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)	<span class="comment">/* 注意这个结束条件 */</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 循环实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)	<span class="comment">/* 注意这个结束条件 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gcd = %d\n&quot;</span>, gcd(a, b));	<span class="comment">/* 最大公约数 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lcm = %d\n&quot;</span>, a*b/gcd(a,b));	<span class="comment">/* 最小公倍数 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="尼考曼彻斯法（辗转相减法）"><a href="#尼考曼彻斯法（辗转相减法）" class="headerlink" title="尼考曼彻斯法（辗转相减法）"></a>尼考曼彻斯法（辗转相减法）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(a != b)	<span class="comment">/* 注意这个结束条件 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">            a = a - b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b = b - a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gcd = %d\n&quot;</span>, gcd(a, b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lcm = %d\n&quot;</span>, a*b/gcd(a,b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两者异同"><a href="#两者异同" class="headerlink" title="两者异同"></a>两者异同</h4><ol>
<li>都是求最大公因子的方法，前者以除法为主，后者以减法为主。特别当两个数相差较大时，前者运算次数较少。</li>
<li>结束条件不同，前者是当相除余数为零时，后者当减数与差相等时。</li>
</ol>
<h3 id="static、const和volatile"><a href="#static、const和volatile" class="headerlink" title="static、const和volatile"></a>static、const和volatile</h3><h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h4><p><strong>作用：</strong></p>
<ol>
<li>给读你代码的人传达非常有用的信息，声明一个参数为常量是为了告诉用户这个参数的应用目的；</li>
<li>通过给优化器一些附加信息，添加关键字<code>const</code>可能产生更紧凑的代码；</li>
<li>合理使用关键字<code>const</code>可以使编译器很自然地保护那些不希望被修改的参数，防止无意的代码修改，可以减少bug的出现。</li>
</ol>
<p>如下声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="type">const</span> a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *a;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> a;</span><br><span class="line"><span class="type">const</span>  <span class="type">int</span> * <span class="type">const</span> a;</span><br></pre></td></tr></table></figure>
<ol>
<li>前两个的作用一样，a是一个常整型数</li>
<li>a是一个指向常整型数的指针，整型数不可修改，指针变量可以修改</li>
<li>a是一个指向整数的常指针，指针指向的整型数可以修改，但是指针变量不可以修改</li>
<li>a是一个指向常整数的常指针，指针指向的整型数不可以修改，指针变量也不可以修改</li>
</ol>
<p><strong>应用：</strong></p>
<ul>
<li>阻止一个变量被修改，可使用<code>const</code>，在定义const变量时，需要先初始化，不然以后没有机会修改</li>
<li>修饰指针，指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const</li>
<li>在一个函数声明中，const修饰形参指示在函数内部不可以改变该形参值</li>
</ul>
<h4 id="static关键字作用"><a href="#static关键字作用" class="headerlink" title="static关键字作用"></a>static关键字作用</h4><ol>
<li>在函数体内，一个声明为<code>static</code>变量在该函数被调用过程中维持其值不变。<strong>注意：</strong>静态局部变量存放位置为<code>.data段</code>，如果没有初始化，编译器会自动为其赋值0。</li>
<li>在编译单元内但在函数提外，一个声明为<code>static</code>变量可以被这个编译单元内所以函数访问，但不能被其他编译单元中函数访问，也就是说它是一个本地全局变量。<strong>注意：</strong>静态全局变量和普通全局变量存储位置要么<code>.data段</code>要么<code>.bss段</code>，这个关键字影响语法层面变量的作用域，不影响变量的生命期。</li>
<li>在编译单元中，一个声明为<code>static</code>函数只能被这个编译单元内的其它函数调用。也就是这个函数被限制在声明它的编译单元的本地范围内使用。</li>
</ol>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4>]]></content>
      <categories>
        <category>Miscellaneous</category>
      </categories>
      <tags>
        <tag>strcpy</tag>
        <tag>memcpy</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练习-01</title>
    <url>/posts/e5eb1c9f/</url>
    <content><![CDATA[<p>九月份算法实战总结，方便以后自己温故知新！</p>
<span id="more"></span>

<h3 id="Problem-01-小数问题"><a href="#Problem-01-小数问题" class="headerlink" title="Problem-01 小数问题"></a>Problem-01 小数问题</h3><p>给定两个正整数A和B，求A&#x2F;B的最后一位小数的值。如果A&#x2F;B是无限循环小数或者是整数则输出0。<br><strong>[输入]</strong></p>
<pre>输入有多行，每行两个正整数A和B </pre>

<p><strong>[输出]</strong></p>
<pre>对于每组输入，输出A/B的最后一位小数的值，如果A/B是无限循环小数或者是整数则输出0 </pre>

<p><strong>[样例输入]</strong></p>
<pre>1 3
1 2
1 5
2 1</pre>

<p><strong>[样例输出]</strong></p>
<pre>0
5
2
0</pre>

<h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>难点是怎么检测出这个分数是无限循环小数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *<span class="built_in">map</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">100</span>; <span class="comment">/* 键值对的数量 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_map</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt;= count)</span><br><span class="line">        &#123;</span><br><span class="line">                buffer = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span>*key*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">2</span>*key*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(buffer, <span class="built_in">map</span>, count);</span><br><span class="line">                count = <span class="number">2</span> * key;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>)</span><br><span class="line">                        <span class="built_in">free</span>(<span class="built_in">map</span>);</span><br><span class="line">                <span class="built_in">map</span> = buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">        assert (n &lt; d &amp;&amp; n % d);</span><br><span class="line">        <span class="type">int</span> <span class="built_in">strlen</span> = <span class="number">1</span>; <span class="comment">/* 小数部分的长度 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n *= <span class="number">10</span>;</span><br><span class="line">                <span class="type">int</span> value = find_map(n);</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">map</span>[n] = <span class="built_in">strlen</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">strlen</span> - value;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n &lt; d)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">strlen</span>++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> mod;</span><br><span class="line">                mod = n % d;</span><br><span class="line">                <span class="keyword">if</span> (mod == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, n / d); <span class="comment">/* 有限小数 */</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">strlen</span>++;</span><br><span class="line">                n = mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(count * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, count*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                <span class="keyword">if</span> (a % b == <span class="number">0</span>) <span class="comment">/* 能够整除 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span> (<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ret = solve(a%b, b);</span><br><span class="line">                <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)    <span class="comment">/* 无限循环小数，返回循环体的长度 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span> (<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>)</span><br><span class="line">                <span class="built_in">free</span>(<span class="built_in">map</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n , <span class="type">const</span> <span class="type">int</span> d, string &amp;ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(n &lt; d &amp;&amp; n % d);</span><br><span class="line">        pos.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                n *= <span class="number">10</span>;</span><br><span class="line">                <span class="type">int</span> value = pos[n];</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        pos[n] = ans.<span class="built_in">size</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> ans.<span class="built_in">size</span>() - value;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n &lt; d)</span><br><span class="line">                &#123;</span><br><span class="line">                        ans += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> mod;</span><br><span class="line">                mod = n % d;</span><br><span class="line">                ans += <span class="built_in">to_string</span>(n/d);</span><br><span class="line">                n = mod;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (a % b == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">                string ans = <span class="built_in">to_string</span>(a/b);</span><br><span class="line">                ans += <span class="string">&quot;.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                ret= <span class="built_in">solve</span>(a%b, b, ans);</span><br><span class="line">                <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cout &lt;&lt; ans.<span class="built_in">c_str</span>()[ans.<span class="built_in">size</span>() <span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，C++版本比较简洁，而C语言版本要自己实现key&#x2F;value映射，而且没有将小数部分以字符串的形式保存。</p>
<h3 id="Problem-02-幂运算"><a href="#Problem-02-幂运算" class="headerlink" title="Problem-02 幂运算"></a>Problem-02 幂运算</h3><p>给定两个值x&#x2F;y，其取值范围均为[1,1000]，将x作为幂运算的底数值，y作为幂运算的指数值，计算 x^y 的结果。</p>
<p><strong>[输入]</strong></p>
<pre>有若干组，每组1 行，每行中包含两个数，分别表示x/y的值，中间使用空格分隔。 </pre>

<p><strong>[输出]</strong></p>
<pre>对于输入的每一行，计算一个结果，输出到一行</pre>

<p><strong>[样例输入]</strong></p>
<pre>34 56
102 356</pre>

<p><strong>[样例输出]</strong></p>
<pre>57918773205287127842044254126179599852840968492056164062843692360166371779746690236416
11525536415592716356648444162121164392687163175948295780407329630004551512959186681381273244602190757058373206291554281875540618042949363675225216676477008497546493670298238521544171633524700764806166227229335118687219889267655183448474160653716777369227626785925762359475294959620339306272244056731636176512806213745898010455096462431289370207384844632477617019982790779702457310729047176281759656263753792457270711025862323789528888545602012704194263073614030101358318488028646734547322466415087427024407008549768556431442559106783257516131690451377322649207503242078203428686238550077244853875462845035889887081653722781635654331259153794693134695552882744378661561578545928174213170104944801295608527030096756736</pre>


<p>基本数据类型未必能表示幂运算的结果，因此为了表示大数，大数运算也就应运而生。利用数组的连续性，将大数的每一位上的数字单独存放到对应的数组位置上，然后再对每位数字进行基本的加减乘除运算。本题只涉及到大数乘运算，且结果最多只有3000个数字（1000^1000）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 3100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];   <span class="comment">//底数</span></span><br><span class="line"><span class="type">int</span> res[MAX];       <span class="comment">//幂运算的结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> num[], <span class="type">int</span> pro[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s[MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX; j++)</span><br><span class="line">            s[i+j] = s[i+j] + num[i] * res[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX; i++)  <span class="comment">/* 处理进位 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            s[i+<span class="number">1</span>] = s[i+<span class="number">1</span>] + s[i]/<span class="number">10</span>;</span><br><span class="line">        res[i] = s[i]%<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">char</span> str[MAX];</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res));</span><br><span class="line">        <span class="built_in">sprintf</span>(str, <span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i,j,k;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>,k=<span class="number">0</span>,i=len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            num[j++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res[k++] = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(y &gt; <span class="number">1</span>) <span class="comment">/* 自乘次数等于y-1 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            mul(num, res, len);</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = MAX<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(res[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-03-快速幂取模"><a href="#Problem-03-快速幂取模" class="headerlink" title="Problem-03 快速幂取模"></a>Problem-03 快速幂取模</h3><h3 id="Problem-04-回文数"><a href="#Problem-04-回文数" class="headerlink" title="Problem-04 回文数"></a>Problem-04 回文数</h3><p>给定一个自然数x，若n的各位数字反向排列所得的自然数y与x相等，则称为x为回文数，比如，x&#x3D;1234321，则x是一个回文数。现在输入一个数，分别判断它以2～16进制的形式呈现时是不是回文数。</p>
<p><strong>[输入]</strong></p>
<pre>输入自然数m， 0&#60;m&#60;50000 </pre>

<p><strong>[输出]</strong></p>
<pre>如果存在，以&#34;Number m is palindrom in basis %d&#34;格式输出所有情况；
如果不存在，输出&#34;Number m is not palindrom&#34;</pre>

<p><strong>[样例输入]</strong></p>
<pre>99</pre>

<p><strong>[样例输出]</strong></p>
<pre>Number 99 is palindrom in basis 2.
Number 99 is palindrom in basis 10.</pre>

<h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>对输入自然数取商取余，从而计算出反向排列的数字，最后将计算得到数字与输入数字比较，相等的话说明它就是当前进制下的回文数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">palindrom</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> basis)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result=<span class="number">0</span>,n=x;</span><br><span class="line">	<span class="keyword">while</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		result=result*basis+n%basis;</span><br><span class="line">		n/=basis;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (result==x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m, i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> record[<span class="number">17</span>];</span><br><span class="line">	<span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m &lt; <span class="number">0</span> || m &gt;= <span class="number">50000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!m)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(record, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(record));</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (palindrom(m, i))</span><br><span class="line">			&#123;</span><br><span class="line">				record[i] = i;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Number %d is palindrom in basis %d.\n&quot;</span>, m, i);</span><br><span class="line">			&#125;</span><br><span class="line">			result += record[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!result)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Number %d is not palindrom\n&quot;</span>, m);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>large number operation</tag>
        <tag>cyclic decimal</tag>
        <tag>suffix array</tag>
        <tag>string</tag>
        <tag>palindrom</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理1「Data structures and PID」</title>
    <url>/posts/413c336a/</url>
    <content><![CDATA[<p>进程管理系列文章将主要关注Linux内核为了描述任务「task」所使用的各种数据结构。除此之外，还会阐述内核是如何管理用于标识任务的PID以及如何创建和终止任务。该系列文章主要涉及如下内容：</p>
<ul>
<li>任务涉及的三个数据结构：<code>struct task_struct</code>、<code>struct thread_info</code>、<code>struct thread_struct</code></li>
<li>PID分配流程以及用于标识任务的相关数据结构</li>
<li>任务在整个生命周期中涉及的执行状态以及相关的API</li>
<li>指示任务重要性的优先级「priority」</li>
<li>任务创建和终止的流程</li>
<li>swapper任务的初始化过程</li>
</ul>
<p>本文主要关注前两点：三个重要的数据结构和PID。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h3 id="任务的表示形式"><a href="#任务的表示形式" class="headerlink" title="任务的表示形式"></a>任务的表示形式</h3><p>在通用操作系统理论中，任务「task」被定义为执行单元「unit of execution」或者被抽象成工作单元「units of work」。下面我们将看到Linux内核是如何定义和描述任务的。</p>
<h4 id="任务、进程和线程三者之间的区别"><a href="#任务、进程和线程三者之间的区别" class="headerlink" title="任务、进程和线程三者之间的区别"></a>任务、进程和线程三者之间的区别</h4><p>从广义上看，程序「program」指的是编译产生的对象文件「compiled object file」，而进程「process」描述的是等待执行的或正在执行的程序实例「instance」。如果存在两个特定程序的实例，那就意味着系统有两个进程。进程本质上可以看作一种抽象概念，它不仅包含被执行的程序代码「program code」同时还包括其他的内容。此外一个进程还可以包含一个或多个线程。进程主要包含下列内容：</p>
<ul>
<li>正在被执行的程序代码「program code」</li>
<li>正在使用的内存地址空间「memory address sapce」</li>
<li>使用的各种资源「resource」（打开的文件和目录、信号「signal」等）</li>
</ul>
<p>线程就是一个轻量级的进程，在所属的进程中它与其他线程共享大部分资源。与进程不同的是在一个线程组中某个线程与其他线程共享一个内存地址空间，但系统中每个进程都拥有自己独立的内存地址空间。除此之外，文件、目录和信号等资源在线程之间也是可以共享的。<br>内核线程「kernel thread」顾名思义是由内核代码创建的线程，但是与用户态任务不同的是它只能运行在内核态并且没有内存地址空间。</p>
<p><img data-src="/images/16/difference-between-process-and-thread.svg" alt="difference-between-process-and-thread"></p>
<center>图1 （从用户角度看）线程与进程之间的差别</center>
]]></content>
      <categories>
        <category>task management and process scheduling</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>process</tag>
        <tag>management</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>时间管理「time management」</title>
    <url>/posts/8b7c2647/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;&ensp;时间是构建事件时间轴的基石，用于识别正在发生的和已发生的事件。定时器是一种特殊的时钟，可用于测量事件的处理时间和控制一系列事件的发生。因此在Linux内核中，时间和定时器管理是至关重要的组成部分，可按功能将其分为如下几方面：</p>
<ul>
<li>支持时间管理的计时「timekeeping」</li>
<li>时钟管理和同步</li>
<li>时间表达方式</li>
<li>定时器的事件中断处理</li>
</ul>
<p>对于这些功能的实现都需要利用时钟装置，不过它们还与系统资源及其他硬件设备密切相关，并且还不能忽悠它们对体系架构的依赖，因此内核代码尽可能尝试对体系架构相关的部分进行抽象以利于时间管理和使用。在以前Linux内核中，已经使用基于HZ的低精度定时器实现了上述这些功能，然而由于物理限制产生的误差，所以要求高精度定时器控制的事件并不能保证在确切时间内处理。为了弥补缺陷和不足，内核在实现高精度定时器时引入了通用时间子系统「generic time subsystem」，同时还尝试修改多个API，使它们能够统一无差别地使用两种截然不同的定时器。本文将讨论通用时钟框架CCF「Common Clock Framework」、通用时间子系统以及定时器，它们都是时间和定时器管理的重要基础。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h3 id="通用时钟框架「common-clock-framework，-CCF」"><a href="#通用时钟框架「common-clock-framework，-CCF」" class="headerlink" title="通用时钟框架「common clock framework， CCF」"></a>通用时钟框架「common clock framework， CCF」</h3><p>在以前的内核中，每种SoC都实现了一套操控时钟的API，而且每种SoC的时钟API都是单独自成体系的，从而导致相关代码大量冗余重复且分散，因此这对时钟管理带来极大不利。为了解决这种问题，在2012年5月发布的kernel 3.4版本内添加了一个新的时钟框架，并为该框架取名为CCF「Common Clock Framework」，其思想最初是由Jeremy Kerr（Canonical）提出的，代码实现却是由Mike Turquette（Texas Instruments）主导完成的。</p>
<h4 id="时钟「clock」"><a href="#时钟「clock」" class="headerlink" title="时钟「clock」"></a>时钟「clock」</h4><p>时钟「时钟控制器」是SoC系统中集成的必要硬件，它能够驱动系统中各种设备正常工作，但为了能够使用时钟，就必须为SoC另外提供能驱使时钟运转的其他硬件。</p>
<h5 id="SoC时钟"><a href="#SoC时钟" class="headerlink" title="SoC时钟"></a>SoC时钟</h5><p>SoC内外的各个硬件通过连接在时钟树的不同分支上以获得不同的时钟输出信号，因此它们能够在不同频率下运行。SoC的时钟树是由多个时钟组件构成的，并且父时钟组件的输出信号可用作子时钟组件的输入信号。大多数时钟组件都是可以软件编程配置的，并且能够在运行时改变以进行电源管理。由于时钟的父子层级结构，时钟的操作需遵守如下约束：</p>
<ul>
<li>当激活下面子时钟时，必须先激活上面父时钟</li>
<li>如果所有后代都被禁用了，则应该禁用父时钟</li>
<li>必须知道什么时候能够启用&#x2F;禁用时钟</li>
</ul>
<h4 id="必要的时钟组件"><a href="#必要的时钟组件" class="headerlink" title="必要的时钟组件"></a>必要的时钟组件</h4><p>组成时钟树的基础组件是fixed时钟、gate时钟、mux时钟、rate可变时钟等，通常SoC所用的时钟树如图1所示。由于使用的设备千差万别，所以供给设备的时钟频率也要适当改变。尽管PLL「锁相环」能够产生固定或可变频率的时钟信号，但是为了使设备更灵活地使用时钟输出信号，还要使用mux时钟和gate时钟等基础组件完成时钟信号的后处理「post」和选择。内核对这些时钟组件进行抽象得出一组标准数据结构，其名称取决于自身的使用方式和特点，如表1所示。</p>
<p><img data-src="/images/20/SoC_clock_arch.svg" alt="SoC_clock_arch"></p>
<center>图1 SoC常用的clock结构</center>

<h4 id="数据结构和API"><a href="#数据结构和API" class="headerlink" title="数据结构和API"></a>数据结构和API</h4><p>为了实现CLK框架结构，内核定义声明了用于描述时钟的多种数据结构以及注册和使用它们的API。如图3所示，以树的形式展示了定义的多个时钟数据结构。</p>
<p>图3 描述时钟的数据结构</p>
<h4 id="相关的初始化函数"><a href="#相关的初始化函数" class="headerlink" title="相关的初始化函数"></a>相关的初始化函数</h4><h5 id="of-clk-init-：初始化CCF"><a href="#of-clk-init-：初始化CCF" class="headerlink" title="of_clk_init()：初始化CCF"></a>of_clk_init()：初始化CCF</h5><p><strong>dirvers&#x2F;clk&#x2F;clk.c的of_clk_init()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">of_clk_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clock_provider</span> *<span class="title">clk_provider</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">bool</span> is_init_done;</span><br><span class="line">	<span class="type">bool</span> force = <span class="literal">false</span>;</span><br><span class="line">	LIST_HEAD(clk_provider_list);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!matches)</span><br><span class="line">		matches = &amp;__clk_of_table;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First prepare the list of the clocks providers */</span></span><br><span class="line">	for_each_matching_node_and_match(np, matches, &amp;match) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">clock_provider</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!of_device_is_available(np))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		parent = kzalloc(<span class="keyword">sizeof</span>(*parent), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!parent) &#123;</span><br><span class="line">			list_for_each_entry_safe(clk_provider, next,</span><br><span class="line">						 &amp;clk_provider_list, node) &#123;</span><br><span class="line">				list_del(&amp;clk_provider-&gt;node);</span><br><span class="line">				of_node_put(clk_provider-&gt;np);</span><br><span class="line">				kfree(clk_provider);</span><br><span class="line">			&#125;</span><br><span class="line">			of_node_put(np);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		parent-&gt;clk_init_cb = match-&gt;data;</span><br><span class="line">		parent-&gt;np = of_node_get(np);</span><br><span class="line">		list_add_tail(&amp;parent-&gt;node, &amp;clk_provider_list);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!list_empty(&amp;clk_provider_list)) &#123;</span><br><span class="line">		is_init_done = <span class="literal">false</span>;</span><br><span class="line">		list_for_each_entry_safe(clk_provider, next,</span><br><span class="line">					&amp;clk_provider_list, node) &#123;</span><br><span class="line">			<span class="keyword">if</span> (force || parent_ready(clk_provider-&gt;np)) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* Don&#x27;t populate platform devices */</span></span><br><span class="line">				of_node_set_flag(clk_provider-&gt;np,</span><br><span class="line">						 OF_POPULATED);</span><br><span class="line"></span><br><span class="line">				clk_provider-&gt;clk_init_cb(clk_provider-&gt;np);</span><br><span class="line">				of_clk_set_defaults(clk_provider-&gt;np, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">				list_del(&amp;clk_provider-&gt;node);</span><br><span class="line">				of_node_put(clk_provider-&gt;np);</span><br><span class="line">				kfree(clk_provider);</span><br><span class="line">				is_init_done = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We didn&#x27;t manage to initialize any of the</span></span><br><span class="line"><span class="comment">		 * remaining providers during the last loop, so now we</span></span><br><span class="line"><span class="comment">		 * initialize all the remaining ones unconditionally</span></span><br><span class="line"><span class="comment">		 * in case the clock parent was not mandatory</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!is_init_done)</span><br><span class="line">			force = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间子系统「time-subsystem」"><a href="#时间子系统「time-subsystem」" class="headerlink" title="时间子系统「time subsystem」"></a>时间子系统「time subsystem」</h3><h4 id="基础配置概述"><a href="#基础配置概述" class="headerlink" title="基础配置概述"></a>基础配置概述</h4><h4 id="时钟源「clock-source」"><a href="#时钟源「clock-source」" class="headerlink" title="时钟源「clock source」"></a>时钟源「clock source」</h4><h4 id="时钟事件「clock-event」"><a href="#时钟事件「clock-event」" class="headerlink" title="时钟事件「clock event」"></a>时钟事件「clock event」</h4><h4 id="滴答设备「tick-device」"><a href="#滴答设备「tick-device」" class="headerlink" title="滴答设备「tick device」"></a>滴答设备「tick device」</h4><h5 id="使用时钟源「clock-source」初始化timekeeper"><a href="#使用时钟源「clock-source」初始化timekeeper" class="headerlink" title="使用时钟源「clock source」初始化timekeeper"></a>使用时钟源「clock source」初始化timekeeper</h5><p><em><strong>timekeeping_init()：设置xtime</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">timekeeping_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">wall_time</span>, <span class="title">boot_offset</span>, <span class="title">wall_to_mono</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timekeeper</span> *<span class="title">tk</span> =</span> &amp;tk_core.timekeeper;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clocksource</span> *<span class="title">clock</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	read_persistent_wall_and_boot_offset(&amp;wall_time, &amp;boot_offset);</span><br><span class="line">	<span class="keyword">if</span> (timespec64_valid_strict(&amp;wall_time) &amp;&amp;</span><br><span class="line">	    timespec64_to_ns(&amp;wall_time) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		persistent_clock_exists = <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timespec64_to_ns(&amp;wall_time) != <span class="number">0</span>) &#123;</span><br><span class="line">		pr_warn(<span class="string">&quot;Persistent clock returned invalid value&quot;</span>);</span><br><span class="line">		wall_time = (<span class="keyword">struct</span> timespec64)&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timespec64_compare(&amp;wall_time, &amp;boot_offset) &lt; <span class="number">0</span>)</span><br><span class="line">		boot_offset = (<span class="keyword">struct</span> timespec64)&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We want set wall_to_mono, so the following is true:</span></span><br><span class="line"><span class="comment">	 * wall time + wall_to_mono = boot time</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	wall_to_mono = timespec64_sub(boot_offset, wall_time);</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);</span><br><span class="line">	write_seqcount_begin(&amp;tk_core.seq);</span><br><span class="line">	ntp_init();</span><br><span class="line"></span><br><span class="line">	clock = clocksource_default_clock();</span><br><span class="line">	<span class="keyword">if</span> (clock-&gt;enable)</span><br><span class="line">		clock-&gt;enable(clock);</span><br><span class="line">	tk_setup_internals(tk, clock);</span><br><span class="line"></span><br><span class="line">	tk_set_xtime(tk, &amp;wall_time);</span><br><span class="line">	tk-&gt;raw_sec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	tk_set_wall_to_mono(tk, wall_to_mono);</span><br><span class="line"></span><br><span class="line">	timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);</span><br><span class="line"></span><br><span class="line">	write_seqcount_end(&amp;tk_core.seq);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="time-init"><a href="#time-init" class="headerlink" title="time_init()"></a>time_init()</h5><p><strong>arch&#x2F;arm64&#x2F;kernel&#x2F;time.c的time_init()</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">time_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 arch_timer_rate;</span><br><span class="line"></span><br><span class="line">	of_clk_init(<span class="literal">NULL</span>);</span><br><span class="line">	timer_probe();</span><br><span class="line"></span><br><span class="line">	tick_setup_hrtimer_broadcast();</span><br><span class="line"></span><br><span class="line">	arch_timer_rate = arch_timer_get_rate();</span><br><span class="line">	<span class="keyword">if</span> (!arch_timer_rate)</span><br><span class="line">		panic(<span class="string">&quot;Unable to initialise architected timer.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Calibrate the delay loop directly */</span></span><br><span class="line">	lpj_fine = arch_timer_rate / HZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="定时器管理「timer-management」"><a href="#定时器管理「timer-management」" class="headerlink" title="定时器管理「timer management」"></a>定时器管理「timer management」</h3><h4 id="定时器「timer」概述"><a href="#定时器「timer」概述" class="headerlink" title="定时器「timer」概述"></a>定时器「timer」概述</h4><h4 id="低精度定时器「low-resolution-timer」"><a href="#低精度定时器「low-resolution-timer」" class="headerlink" title="低精度定时器「low resolution timer」"></a>低精度定时器「low resolution timer」</h4><h4 id="高精度定时器「high-resolution-timer」"><a href="#高精度定时器「high-resolution-timer」" class="headerlink" title="高精度定时器「high resolution timer」"></a>高精度定时器「high resolution timer」</h4>]]></content>
      <categories>
        <category>time management</category>
      </categories>
      <tags>
        <tag>time management</tag>
        <tag>timer</tag>
        <tag>clock</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练习-02</title>
    <url>/posts/7ce24d25/</url>
    <content><![CDATA[<p>本文记录自己实践的算法相关练习，方便以后自己温故知新！</p>
<span id="more"></span>


<h3 id="Problem-01-购物最少问题"><a href="#Problem-01-购物最少问题" class="headerlink" title="Problem-01 购物最少问题"></a>Problem-01 购物最少问题</h3><p>小明最近往购物车中添加了N件商品，每件商品的价格是m<sub>1</sub>…….m<sub>n</sub>，0&lt;N&lt;1000, 0&lt;m<sub>i</sub>&lt;&#x3D;100，但是在结帐时发现超过自已的期望预算Y元，0&lt;Y&lt;10000，遂决定从购物车删除部分商品，从而没有超过预算，请帮助小明计算<strong>最多</strong>需要从购物车删除多少件商品？</p>
<p><strong>[输入]</strong></p>
<pre>第一行的一个数字表示测试用例个数，接下来每两行表示具体的用例内容
用例的格式：
预算Y元  购物车里商品数量N
N件商品的价格（以空格为分界符）</pre>

<p><strong>[输出]</strong></p>
<pre>每一个用例对应的结果</pre>

<p><strong>[样例输入]</strong></p>
<pre>2
90 6
40 40 50 50 10 10
30 3
30 20 10</pre>

<p><strong>[样例输出]</strong></p>
<pre>4 #最多需要删除4件商品，比如分别删除一个50、40和两个10元商品
2 #最多需要删除2件商品，比如删除一个20和10元的商品</pre>

<h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>本题的本质就是<strong>花Y元购买最少的商品数量</strong>，核心算法就是排序+贪心，先将N件商品从大到小的排序，然后以此迭代循环决定是否购买当前的商品，只要当前剩余的额度大于当前商品的价格，就选择购买。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">﻿<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (*(<span class="type">int</span> *)b - *(<span class="type">int</span> *)a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> num, <span class="type">int</span> budget)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (budget &lt; <span class="built_in">array</span>[i])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		budget -= <span class="built_in">array</span>[i];</span><br><span class="line">		<span class="keyword">if</span>(budget &gt;= <span class="number">0</span>)</span><br><span class="line">			count++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m, i, j;</span><br><span class="line">	<span class="type">int</span> budget, num;</span><br><span class="line">	<span class="type">int</span> *price = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;budget, &amp;num);</span><br><span class="line">			price = (<span class="type">int</span> *)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, price+j);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			qsort(price, num, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num - solve(price, num, budget));</span><br><span class="line">			<span class="keyword">if</span> (price)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">free</span>(price);</span><br><span class="line">				price = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-02-购物最多问题"><a href="#Problem-02-购物最多问题" class="headerlink" title="Problem-02 购物最多问题"></a>Problem-02 购物最多问题</h3><p>小明最近往购物车中添加了N件商品，每件商品的价格是m<sub>1</sub>…….m<sub>n</sub>，0&lt;N&lt;1000, 0&lt;m<sub>i</sub>&lt;&#x3D;100，但其预算只有Y元，0&lt;Y&lt;10000，请帮助小明计算<strong>最多</strong>能够从购物车购买多少件商品才不会超出预算？</p>
<p><strong>[输入]</strong></p>
<pre>第一行的一个数字表示测试用例个数，接下来每两行表示具体的用例内容
用例的格式：
预算Y元  购物车里商品数量N
N件商品的价格（以空格为分界符）</pre>

<p><strong>[输出]</strong></p>
<pre>每一个用例对应的结果</pre>

<p><strong>[样例输入]</strong></p>
<pre>2
90 5
40 40 50 50 10
30 3
30 20 10</pre>

<p><strong>[样例输出]</strong></p>
<pre>3
2</pre>


<h4 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h4><p>本题与上面那题看似一样，其本质是<strong>花Y元购买最多的商品数量</strong>，核心算法就是动态规划（DP）。本题实现使用了一维数组num来记录在当前预算下的最大购买数量，num[j]表示在预算为j的情况下最大购买商品数量，但对于第i件商品来说，它有存在两种状态，购买num[j-price[i]]+1，或者不购买num[j]，我们需要的是这两者中的较大的一个，即：num[j] &#x3D; max(num[j],num[j-price[i]]+1)。与此题相似的题目是<a href="https://blog.csdn.net/qq2512446791/article/details/66475466">【动态规划入门】装箱问题</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">﻿<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b)    ((a &gt; b) ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[<span class="number">10005</span>];</span><br><span class="line"><span class="type">int</span> price[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> count, n, i, j, y, k;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;count) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; count; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;y, &amp;n);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;price[i]);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (j = y; j &gt;= price[i]; j--)</span><br><span class="line">				&#123;</span><br><span class="line">					num[j]=MAX(num[j], (num[j-price[i]]+<span class="number">1</span>));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num[y]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-03-序列排序"><a href="#Problem-03-序列排序" class="headerlink" title="Problem-03 序列排序"></a>Problem-03 序列排序</h3><p>给定一个长度为N的序列，通过交换任意两个元素给序列重新排序，求需要的最少交换次数，就能将序列排列成递增的顺序，（序列中的元素互不重复）</p>
<p><strong>[输入]</strong></p>
<pre>第一行测试用例个数，接下来每两行描述一个测试用例
用例的格式：
序列长度N
序列的各个元素a<sub>1</sub>......a<sub>n</sub></pre>

<p><strong>[输出]</strong></p>
<pre>每一个用例需要的最少交换次数</pre>

<p><strong>[样例输入]</strong></p>
<pre>2
6
2 4 3 6 5 7
10
10 2 3 4 5 6 7 8 9 1</pre>

<p><strong>[样例输出]</strong></p>
<pre>2
1</pre>

<h4 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h4><p>思路：构造“循环节”， 原位置与排序后位置不一致的元素将至少需要一次交换。</p>
<p><img data-src="/images/21/problem1060.svg" alt="problem1060.svg"></p>
<center>图1 序列排序的图例</center>

<p>为了计算最少的交换次数，我们肯定希望一次交换将一个元素放入正确的位置，或者一次交换将两个元素都放入正确位置。如上图所示，循环节<code>loop #1</code>和<code>loop #3</code>都是一次交换就能够将两个元素放入正确位置，循环节<code>loop #2</code>每次交换只能将一个元素放入正确位置，所以其至少需要两次交换，循环节<code>loop #4</code>无需交换。我们可以推算出一个循环节至少需要的交换次数等于<strong>循环节内元素个数 - 1</strong>。<br>总结归纳，假设一个序列存在m个循环节，总交换次数&#x3D;（loop#1内元素个数 - 1） + （loop#2内元素个数 - 1）+ … + （loop#m内元素个数 - 1） &#x3D; 序列的长度 - m</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos, i,loops = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 有序的序列 */</span></span><br><span class="line">    <span class="type">int</span> *b = (<span class="type">int</span> *)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">map</span>, *flags;</span><br><span class="line">    <span class="built_in">memcpy</span>(b, a, len*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    qsort(b, len, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>((b[len<span class="number">-1</span>]+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(pos = <span class="number">0</span>; pos &lt; len; pos++)</span><br><span class="line">        <span class="built_in">map</span>[b[pos]] = pos;	<span class="comment">/* 记录每个元素应该放入的位置 */</span></span><br><span class="line"></span><br><span class="line">    flags = (<span class="type">int</span> *)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">/* 标记元素是否被访问过 */</span></span><br><span class="line">    <span class="built_in">memset</span>(flags, <span class="number">0</span>, len*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt; len; pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flags[pos])</span><br><span class="line">        &#123;</span><br><span class="line">            i = pos;</span><br><span class="line">            <span class="keyword">while</span>(!flags[i])	<span class="comment">/* 构造循环节 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                flags[i] = <span class="number">1</span>;</span><br><span class="line">                i = <span class="built_in">map</span>[a[i]];	<span class="comment">/* 原序列中i位置的元素在有序序列中的位置 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            loops++;	<span class="comment">/* 循环节计数 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b)</span><br><span class="line">        <span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>)</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags)</span><br><span class="line">        <span class="built_in">free</span>(flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len - loops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">            <span class="built_in">array</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">array</span>+i);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, solve(<span class="built_in">array</span>, n));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">                <span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果题目稍微修改一下：将任意两个元素交换改成相邻两个元素交换，结果就变成求<em>序列的逆序对数</em>，可以借鉴参考<a href="https://blog.csdn.net/linux_kernel_fan/article/details/26405873">小朋友排列</a>和<a href="https://blog.csdn.net/lfb637/article/details/78309507">归并排序（逆序对的解决）</a></p>
<h3 id="Problem-04-找数字"><a href="#Problem-04-找数字" class="headerlink" title="Problem-04 找数字"></a>Problem-04 找数字</h3><p>从一个n位数中选出m位按原来顺序组成新的数字并使其最大。（n, m &lt; 100）</p>
<p><strong>[输入]</strong></p>
<pre>第一行测试用例个数，接下来每一行描述一个测试用例
用例的格式：
位数n m 一个位数为n的数字</sub></pre>

<p><strong>[输出]</strong></p>
<pre>每一个用例得到的最大数字</pre>

<p><strong>[样例输入]</strong></p>
<pre>2
7 3 9123487
5 2 51234</pre>

<p><strong>[样例输出]</strong></p>
<pre>987
54</pre>

<h4 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h4><p>最优解法应该是贪心法，能够边输入边处理，由于需要选出m个数字，即删除n-m个数字。假设<em>变量i</em>表示遍历到输入的第i个数字（从0开始），那么待输入的数字还有n-i个需要遍历。<em>变量k</em>表示第k个已经选中的数字，只有当k&lt;m时才能继续挑选数字。若k+(n-i)&gt;m，即已选出的数字个数加上等待遍历的数字个数大于要选出的位数时，需要用后面较大的数替换前面已经选出的数字，此处的贪心策略是：设当前输入的数是c，通过k从已选出数字中向前寻找恰好大于c的那个数字所对应的位置p，然后替换掉第p+1位的数字，这种策略可以保证所选出的m位数字的结果是最大的。参考<a href="https://blog.csdn.net/consciousman/article/details/52675941">UVa11491- Erasing and Winning（从一题看多解）</a>和<a href="https://blog.csdn.net/u014800748/article/details/43671343">习题8-4 奖品的价值 UVa11491</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> n, m, i, k;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;count) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(count--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">105</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">            getchar();</span><br><span class="line"></span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                c = getchar();</span><br><span class="line">                <span class="comment">/* 需选出m个数字， 已选中到第k个数字， 还有n-i个未遍历，若k+(n-i) &gt; m，</span></span><br><span class="line"><span class="comment">                 * 说明若后面有比前面选中数字大的，还需要替换掉， 此时选择替换掉小于c的数字</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; (i - k &lt; (n - m)) &amp;&amp; a[k] &lt; c)</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">if</span> (k  &lt; m)</span><br><span class="line">                    a[++k] = c;	<span class="comment">/* 若k&lt;m，说明还没有选够m个数字 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[++k] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题解法也适用从一个n位数字中删除d个数字，使剩下数字最大。</p>
]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>greedy</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理2「State and Priority」</title>
    <url>/posts/cbbc24f9/</url>
    <content><![CDATA[<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>task management and process scheduling</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>process</tag>
        <tag>management</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理3「Creation and Termination」</title>
    <url>/posts/b48891d0/</url>
    <content><![CDATA[<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>task management and process scheduling</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>process</tag>
        <tag>management</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度2「Core」</title>
    <url>/posts/3a441eb3/</url>
    <content><![CDATA[<p>Linux内核是一个支持多任务「multitasking」的操作系统，可以同时执行多个任务，但是CPU在某个时刻只能运行一个任务，因此为了使Linux内核真的看起来像多个任务在同时运行，调度器将连续不断地替换当前正在运行的任务，这个替换的过程被称为任务切换「task switch」或者调度「scheduling」。<br>内核通过处理定时器「timer」中断能够周期循环地检查当前进程的need_resched标志是否设置以及时间片「time slice」是否用尽，若当前进程设置了need_resched标志或者用完了时间片，那么将发生任务切换，这个过程就是利用定时器「timer」中断处理函数实现的周期调度「periodic scheduling 」。除此之外，内核还有很多其他代码会随时检查当前进程的need_resched标志是否设置，若need_resched标志被设置了，则将进行任务切换，这个过程属于非周期调度。在内核中这两种调度能够保证调度器尽可能经常地进行任务切换，以致于所有现存的进程能够尽可能公平地被执行。与周期调度不同，内核常见的非周期调度大致可分两种：被动式非周期调度和主动式非周期调度，比如如下所述的两个场景：</p>
<ul>
<li>进程相关事件发生时会调用设置need_resched标志的函数，比如一个进程的状态发生了变化（进程唤醒事件出现、进程优先级改变）或者当前进程主动让出「yield」CPU执行时间，这只是触发了调度请求「scheduling request」，而真正的任务切换却发生于调用schedule()的函数，或检测need_resched标志是否设置的函数。</li>
<li>与前者不同的是有些代码（sleep、blocking API、lock API）会使当前进程进入睡眠状而不能继续执行，则会直接显式调用核心调度函数__schedule()进行任务切换。</li>
</ul>
<p>下面给出了触发任务切换的调度点「scheduling point」，它们将检查need_resched标志是否被设置，如果设置的话，则会调用核心调度函数进行任务切换。</p>
<ul>
<li>在中断处理完成后</li>
<li>在系统调用处理完成后</li>
<li>在使能内核抢占后</li>
</ul>
<p>总之，本文主要分析使用timer中断实现的周期调度、非周期调度涉及的调度请求「scheduling request」以及任务切换。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li>**ARCH:**arm64</li>
<li>**Linux Kernel:**linux-4.19.27</li>
</ul>
<hr>
<h3 id="基于timer-interrupt的周期调度"><a href="#基于timer-interrupt的周期调度" class="headerlink" title="基于timer interrupt的周期调度"></a>基于timer interrupt的周期调度</h3><h4 id="scheduler-tick"><a href="#scheduler-tick" class="headerlink" title="scheduler_tick()"></a>scheduler_tick()</h4><h3 id="非周期调度"><a href="#非周期调度" class="headerlink" title="非周期调度"></a>非周期调度</h3><h4 id="调度的检查场合"><a href="#调度的检查场合" class="headerlink" title="调度的检查场合"></a>调度的检查场合</h4><h5 id="任务唤醒"><a href="#任务唤醒" class="headerlink" title="任务唤醒"></a>任务唤醒</h5><p><img data-src="/images/14/wakeup_task_routine.svg" alt="wakeup_task_routine"></p>
<center>图1 任务唤醒的调用流程</center>


<h5 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h5><p>调度器也会周期检查如下的情况是否需要进行调度。</p>
<ul>
<li>任务显示地让出「yield」CPU执行时间</li>
<li>高优先级的任务插入运行队列</li>
<li>任务的优先级改变</li>
<li>任务的调度类改变</li>
<li>新创建的任务首次被执行</li>
</ul>
<h4 id="调度点「scheduling-point」"><a href="#调度点「scheduling-point」" class="headerlink" title="调度点「scheduling point」"></a>调度点「scheduling point」</h4><p><a href="https://github.com/torvalds/linux/commit/421dd6fa6709ebee4f888ed89da5c103c77caee1">arm64: factor work_pending state machine to C</a></p>
<p><img data-src="/images/14/el0_irq_process.svg" alt="el0_irq_process"></p>
<center>图2 在用户态下发生中断后可能进行的调度过程</center>

<p><img data-src="/images/14/el1_irq_process.svg" alt="el1_irq_process"></p>
<center>图3 在内核态下发生中断后可能进行的调度过程</center>

<p><a href="https://github.com/torvalds/linux/commit/4141c857fd09dbed480f021b3eece4f46c653161">arm64: convert raw syscall invocation to C</a><br><a href="https://github.com/torvalds/linux/commit/f37099b6992a0b818c7b51b899e435f4006a9f90#diff-5852c4f382c23511d037a653b271b3fd">arm64: convert syscall trace logic to C</a><br><a href="https://github.com/torvalds/linux/commit/3b7142752e4bee153df6db4a76ca104ef0d7c0b4#">arm64: convert native&#x2F;compat syscall entry to C</a></p>
<p><img data-src="/images/14/el0_svc_process.svg" alt="el0_svc_process"></p>
<center>图4 在用户态下触发系统调用后可能进行的调度过程</center>

<h5 id="内核抢占「kernel-preemption」开启时"><a href="#内核抢占「kernel-preemption」开启时" class="headerlink" title="内核抢占「kernel preemption」开启时"></a>内核抢占「kernel preemption」开启时</h5><p><img data-src="/images/14/preempt_enable.svg" alt="preempt_enable"></p>
<center>图4 在内核抢占被使能时可能进行的调度过程</center>


<h5 id="主动式非周期调度：在当前任务进入睡眠时"><a href="#主动式非周期调度：在当前任务进入睡眠时" class="headerlink" title="主动式非周期调度：在当前任务进入睡眠时"></a>主动式非周期调度：在当前任务进入睡眠时</h5><h6 id="由User-space-sleep-API和blocking-API触发的调度"><a href="#由User-space-sleep-API和blocking-API触发的调度" class="headerlink" title="由User-space sleep API和blocking  API触发的调度"></a>由User-space sleep API和blocking  API触发的调度</h6><p><img data-src="/images/14/sleep_schedule.svg" alt="sleep_schedule"></p>
<center>图5 当任务进入睡眠时引起的调度</center>

<h3 id="关键调度函数：schedule-、preempt-schedule-irq-和preempt-schedule-common"><a href="#关键调度函数：schedule-、preempt-schedule-irq-和preempt-schedule-common" class="headerlink" title="关键调度函数：schedule()、preempt_schedule_irq()和preempt_schedule_common()"></a>关键调度函数：schedule()、preempt_schedule_irq()和preempt_schedule_common()</h3><h3 id="调度请求「scheduling-request」"><a href="#调度请求「scheduling-request」" class="headerlink" title="调度请求「scheduling request」"></a>调度请求「scheduling request」</h3><h3 id="调度核心：-schedule"><a href="#调度核心：-schedule" class="headerlink" title="调度核心：__schedule()"></a>调度核心：__schedule()</h3><h3 id="任务唤醒-try-to-wake-up"><a href="#任务唤醒-try-to-wake-up" class="headerlink" title="任务唤醒: try_to_wake_up()"></a>任务唤醒: try_to_wake_up()</h3><p><img data-src="/images/14/try_to_wake_up.svg" alt="try_to_wake_up"></p>
<center>图10 try_to_wake_up</center>


]]></content>
      <categories>
        <category>task management and process scheduling</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>process</tag>
        <tag>management</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理4「idel thread(swapper)」</title>
    <url>/posts/ac242ecc/</url>
    <content><![CDATA[<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>task management and process scheduling</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>process</tag>
        <tag>management</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度3「CFS-Completely Fair Scheduling」</title>
    <url>/posts/954687ec/</url>
    <content><![CDATA[<p>CFS是内核使用的一种调度器或调度类，它主要负责处理三种调度策略：SCHED_NORMAL、SCHED_BATCH和SCHED_IDLE。从<a href="https://chasinglulu.github.io/2019/11/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A62%E3%80%8CCore%E3%80%8D/">上一篇文章</a> 可知，调度器的核心在挑选下一个运行的进程时有可能会遍历所有的调度类别。实际上系统大多数进程通常都是CFS调度类负责处理的，因此为了优化下一个进程的挑选调度器核心会先判断当前进程是否采用了CFS调度策略，若是，则直接调用CFS代码来挑选下一个进程，若不是或CFS代码未能挑选到一个合适的进程，则会调用各个调度类的挑选函数来寻找一个合适的进程。若CFS代码寻找到了合适的下一个运行的进程，则直接返回该进程的实例而不会再遍历调度类。本文将主要关注下列的CFS活动和行为：</p>
<ul>
<li>将一个任务插入运行队列</li>
<li>从运行队列中挑选一个合适的任务</li>
<li>从运行队列中移除一个任务</li>
<li>处理周期滴答「periodic ticks」</li>
<li>管理调度实体「scheduling entities」的运行时间</li>
<li>管理时间片「time slices」</li>
</ul>
<span id="more"></span>
<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a></li>
<li>**ARCH:**arm64</li>
<li>**Linux Kernel:**linux-4.19.27</li>
</ul>
<hr>
<h3 id="将一个任务插入运行队列"><a href="#将一个任务插入运行队列" class="headerlink" title="将一个任务插入运行队列"></a>将一个任务插入运行队列</h3><p><img data-src="/images/15/enqueue_task_fair_codeflow.svg" alt="enqueue_task_fair_codeflow.svg"></p>
<center>图1 enqueue_task_fair函数的调用路径</center>

<h4 id="enqueue-task-fair-：将一个任务插入CFS运行队列"><a href="#enqueue-task-fair-：将一个任务插入CFS运行队列" class="headerlink" title="enqueue_task_fair()：将一个任务插入CFS运行队列"></a>enqueue_task_fair()：将一个任务插入CFS运行队列</h4><h5 id="enqueue-entity-：更新调度实体的vruntime字段并将它插入红黑树"><a href="#enqueue-entity-：更新调度实体的vruntime字段并将它插入红黑树" class="headerlink" title="enqueue_entity()：更新调度实体的vruntime字段并将它插入红黑树"></a>enqueue_entity()：更新调度实体的vruntime字段并将它插入红黑树</h5><h5 id="place-entity-：计算调度实体的vruntime"><a href="#place-entity-：计算调度实体的vruntime" class="headerlink" title="place_entity()：计算调度实体的vruntime"></a>place_entity()：计算调度实体的vruntime</h5><h5 id="enqueue-entity-：将调度实体插入红黑树"><a href="#enqueue-entity-：将调度实体插入红黑树" class="headerlink" title="__enqueue_entity()：将调度实体插入红黑树"></a>__enqueue_entity()：将调度实体插入红黑树</h5><h3 id="从运行队列中挑选一个任务"><a href="#从运行队列中挑选一个任务" class="headerlink" title="从运行队列中挑选一个任务"></a>从运行队列中挑选一个任务</h3><p><img data-src="/images/15/pick_next_task_fair_codeflow.svg" alt="pick_next_task_fair_codeflow.svg"></p>
<center>图2 pick_next_task_fair函数的调用路径</center>

<h4 id="pick-next-task-：寻找将要运行的下一个任务"><a href="#pick-next-task-：寻找将要运行的下一个任务" class="headerlink" title="pick_next_task()：寻找将要运行的下一个任务"></a>pick_next_task()：寻找将要运行的下一个任务</h4><h5 id="pick-next-task-fair-：从CFS运行队列中寻找下一个任务"><a href="#pick-next-task-fair-：从CFS运行队列中寻找下一个任务" class="headerlink" title="pick_next_task_fair()：从CFS运行队列中寻找下一个任务"></a>pick_next_task_fair()：从CFS运行队列中寻找下一个任务</h5><h5 id="pick-next-entity-：在红黑树上寻找下一个即将运行的调度实体"><a href="#pick-next-entity-：在红黑树上寻找下一个即将运行的调度实体" class="headerlink" title="pick_next_entity()：在红黑树上寻找下一个即将运行的调度实体"></a>pick_next_entity()：在红黑树上寻找下一个即将运行的调度实体</h5><h5 id="put-prev-entity-：删除当前的调度实体"><a href="#put-prev-entity-：删除当前的调度实体" class="headerlink" title="put_prev_entity()：删除当前的调度实体"></a>put_prev_entity()：删除当前的调度实体</h5><h5 id="set-next-entity-：将以参数形式传入的调度实体设置成当前调度实体"><a href="#set-next-entity-：将以参数形式传入的调度实体设置成当前调度实体" class="headerlink" title="set_next_entity()：将以参数形式传入的调度实体设置成当前调度实体"></a>set_next_entity()：将以参数形式传入的调度实体设置成当前调度实体</h5><h3 id="从运行队列中移除一个任务"><a href="#从运行队列中移除一个任务" class="headerlink" title="从运行队列中移除一个任务"></a>从运行队列中移除一个任务</h3><p><img data-src="/images/15/dequeue_task_fair_codeflow.svg" alt="dequeue_task_fair_codeflow.svg"></p>
<center>图3 dequeue_task_fair函数的调用路径</center>

<h4 id="dequeue-task-fair-：从CFS运行队列中移除一个任务"><a href="#dequeue-task-fair-：从CFS运行队列中移除一个任务" class="headerlink" title="dequeue_task_fair()：从CFS运行队列中移除一个任务"></a>dequeue_task_fair()：从CFS运行队列中移除一个任务</h4><h5 id="dequeue-entity-：从红黑树中移除一个调度实体"><a href="#dequeue-entity-：从红黑树中移除一个调度实体" class="headerlink" title="dequeue_entity()：从红黑树中移除一个调度实体"></a>dequeue_entity()：从红黑树中移除一个调度实体</h5><h3 id="周期滴答「periodic-ticks」的处理"><a href="#周期滴答「periodic-ticks」的处理" class="headerlink" title="周期滴答「periodic ticks」的处理"></a>周期滴答「periodic ticks」的处理</h3><h4 id="task-tick-fair-：尝试抢占当前的任务"><a href="#task-tick-fair-：尝试抢占当前的任务" class="headerlink" title="task_tick_fair()：尝试抢占当前的任务"></a>task_tick_fair()：尝试抢占当前的任务</h4><h5 id="entity-tick-：更新CFS运行队列的调度信息以及尝试抢占当前调度实体"><a href="#entity-tick-：更新CFS运行队列的调度信息以及尝试抢占当前调度实体" class="headerlink" title="entity_tick()：更新CFS运行队列的调度信息以及尝试抢占当前调度实体"></a>entity_tick()：更新CFS运行队列的调度信息以及尝试抢占当前调度实体</h5><h5 id="check-preempt-tick-：尝试抢占当前调度实体"><a href="#check-preempt-tick-：尝试抢占当前调度实体" class="headerlink" title="check_preempt_tick()：尝试抢占当前调度实体"></a>check_preempt_tick()：尝试抢占当前调度实体</h5><h3 id="调度实体的runtime管理"><a href="#调度实体的runtime管理" class="headerlink" title="调度实体的runtime管理"></a>调度实体的runtime管理</h3><p><img data-src="/images/15/update_curr_codeflow.svg" alt="update_curr_codeflow.svg"></p>
<center>图3 update_curr函数的调用路径</center>

<h4 id="update-curr-：更新CFS运行队列和调度实体的runtime相关字段"><a href="#update-curr-：更新CFS运行队列和调度实体的runtime相关字段" class="headerlink" title="update_curr()：更新CFS运行队列和调度实体的runtime相关字段"></a>update_curr()：更新CFS运行队列和调度实体的runtime相关字段</h4><h5 id="calc-delta-fair-：根据NICE-0-LOAD和se-load加权计算更新delta"><a href="#calc-delta-fair-：根据NICE-0-LOAD和se-load加权计算更新delta" class="headerlink" title="calc_delta_fair()：根据NICE_0_LOAD和se-&gt;load加权计算更新delta"></a>calc_delta_fair()：根据NICE_0_LOAD和se-&gt;load加权计算更新delta</h5><h5 id="calc-delta-：根据load-weight和delta-exec计算权重「weight」"><a href="#calc-delta-：根据load-weight和delta-exec计算权重「weight」" class="headerlink" title="__calc_delta()：根据load_weight和delta_exec计算权重「weight」"></a>__calc_delta()：根据load_weight和delta_exec计算权重「weight」</h5><h3 id="时间片「time-slice」管理"><a href="#时间片「time-slice」管理" class="headerlink" title="时间片「time slice」管理"></a>时间片「time slice」管理</h3><h4 id="sched-slice-：计算调度实体的时间片「time-slice」"><a href="#sched-slice-：计算调度实体的时间片「time-slice」" class="headerlink" title="sched_slice()：计算调度实体的时间片「time slice」"></a>sched_slice()：计算调度实体的时间片「time slice」</h4><h5 id="sched-period-：根据任务数量计算调度延迟「scheduling-latency」"><a href="#sched-period-：根据任务数量计算调度延迟「scheduling-latency」" class="headerlink" title="__sched_period()：根据任务数量计算调度延迟「scheduling latency」"></a>__sched_period()：根据任务数量计算调度延迟「scheduling latency」</h5><h4 id="sched-vslice-：依据调度实体的负载权重计算其虚拟时间片「virtual-time-slice」"><a href="#sched-vslice-：依据调度实体的负载权重计算其虚拟时间片「virtual-time-slice」" class="headerlink" title="sched_vslice()：依据调度实体的负载权重计算其虚拟时间片「virtual time slice」"></a>sched_vslice()：依据调度实体的负载权重计算其虚拟时间片「virtual time slice」</h4><h4 id="update-sysctl-：初始化时间片相关的变量"><a href="#update-sysctl-：初始化时间片相关的变量" class="headerlink" title="update_sysctl()：初始化时间片相关的变量"></a>update_sysctl()：初始化时间片相关的变量</h4><p><img data-src="/images/15/update_sysctl_codeflow.svg" alt="update_sysctl_codeflow.svg"></p>
<center>图3 update_sysctl函数的调用路径</center>
]]></content>
      <categories>
        <category>task management and process scheduling</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>process</tag>
        <tag>management</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度1「Key Concepts」</title>
    <url>/posts/4a123606/</url>
    <content><![CDATA[<p>本文主要关注内核中用于调度进程的各种机制，以及为了实现这些机制而引入的各种概念和数据结构。首先了解调度器「scheduler」的如下关键概念，有了这些基础才能深入理解调度器的各种不同活动和行为。</p>
<ul>
<li>刻画进程重要性的负载权重「load weight」</li>
<li>进程的虚拟运行时间「virtual runtime」</li>
<li>进程时间片「time slice」和CFS运行队列的调度延迟「scheduling latency」</li>
<li>运行队列「run queue」、CFS运行队列和红黑树「Red Black Tree」</li>
<li>组调度「group scheduling」涉及的任务组「task group」和调度实体「scheduling entity」</li>
<li>调度类别「scheduling class」和调度策略「scheduling policy」</li>
</ul>
<p>后续第二篇文章会分析调度器的核心部分，也就是常用的调度代码。涉及的知识点如下：</p>
<ul>
<li>基于定时器「timer」中断的周期调度「periodic scheduling 」</li>
<li>非周期调度「aperiodic scheduling」</li>
<li>触发任务切换的调度点「scheduling points」</li>
<li>设置need_resched标志的调度请求「scheduling request」</li>
<li>调度核心函数__schedule()</li>
<li>进程唤醒函数</li>
</ul>
<p>在研究完调度器核心之后，最后一篇文章将分析CFS「Completely Fair Scheduling)」调度器，它负责处理SCHED_NORMAL、SCHED_BATCH和SCHED_IDLE三种调度策略。涉及的内容如下：</p>
<ul>
<li>将一个进程插入运行队列</li>
<li>从运行队列中挑选一个合适的进程</li>
<li>从运行队列中移除一个进程</li>
<li>处理周期滴答「periodic ticks」</li>
<li>管理调度实体「scheduling entities」的运行时间</li>
<li>管理时间片「time slices」</li>
</ul>
<p>本文在最后会分析sched_init()函数，它会完成调度器正常工作所要求的初始化任务。</p>
<span id="more"></span>

<hr>
<ul>
<li><strong>Target Platform:</strong> <a href="https://www.96boards.org/product/rock960c/">Rock960c</a> </li>
<li><strong>ARCH:</strong> arm64</li>
<li><strong>Linux Kernel:</strong> linux-4.19.27</li>
</ul>
<hr>
<h3 id="负载权重「load-weight」和虚拟运行时间「virtual-runtime」"><a href="#负载权重「load-weight」和虚拟运行时间「virtual-runtime」" class="headerlink" title="负载权重「load weight」和虚拟运行时间「virtual runtime」"></a>负载权重「load weight」和虚拟运行时间「virtual runtime」</h3><h4 id="负载权重「load-weight」：描述进程的重要性"><a href="#负载权重「load-weight」：描述进程的重要性" class="headerlink" title="负载权重「load weight」：描述进程的重要性"></a>负载权重「load weight」：描述进程的重要性</h4><p>CFS一个重要任务是公平地分配CPU运行时间给每个进程，但是这儿的公平并不是意味每个进程都花费相同的CPU运行时间。相反地，它更多的是说根据进程的重要性为每个进程分配相对应的CPU运行时间。浅显地说，一个重要的进程将获得更多的CPU执行时间，而一个不重要的进程将获得更少的CPU执行时间。尽管在引入CFS之前使用优先级「priority」的概念能够很好地表达进程的重要性，但是使用完全公平分配机制能够更完美地表达进程的重要性。为了公平分配CPU时间引入了负载权重的概念，其是由进程优先级「priority」决定的。负载权重不仅能够决定进程的虚拟运行时间，而且还能够确定进程占用的CPU份额和可用的时间片。<br>CFS调度器不仅会使具有较大负载权重的进程获得更少的运行时间，而且还会使它们更频繁地被运行。除此之外，进程可用的时间片「time slice」也将增大。进程优先级越高，负载权重也就越大，反之，进程优先级越低，负载权重也就越小。在内核中结构体<code>struct load_weight</code>用于表示和记录负载权重，因此当前进程的负载权重由结构体<code>struct sched_entity</code>的<code>load</code>字段表示。</p>
<p><img data-src="/images/13/priority_and_load_weight_relationship.svg" alt="priority_and_load_weight_relationship"></p>
<center>图1 负载权重和进程优先级的关系</center>

<p>由图可推知，进程优先级增加一级，那么进程负载权重则增大约25%，相反进程优先级减少一级，那么进程负载权重则减少约20%。尽管进程的负载权重是由其优先级决定的，但是进程获得的CPU运行时间并不是恒定不变的。进程获得的CPU运行时间是根据当前进程的负载权重占总负载权重的比例确定的，总负载权重等于CFS运行队列中所有进程的负载权重之和。图2是CPU占用比例的示意图，占用比例会随着进程负载权重的不同而变化。</p>
<p><img data-src="/images/13/cpu_share_I.svg" alt="cpu_share_I"></p>
<center>图2 进程的负载权重与CPU份额的关系 I</center>

<p>一个特定进程能够享用的CPU份额不仅取决于其自身的负载权重「load weight」，而且还依赖于CFS运行队列的总负载权重。假设进程A的负载权重是1024且始终不变，如果CFS运行队列的总负载权重增大了（有新的进程C加入队列），那么进程A占用的CPU份额自然就会降低，如图3 所示。</p>
<p><img data-src="/images/13/cpu_share_II.svg" alt="cpu_share_II"></p>
<center>图3 进程的负载权重与CPU份额的关系 II</center>

<p>如果CFS运行队列存在两个进程，那么较高优先级的进程将能够多占用大约10%的CPU运行时间。</p>
<h4 id="vruntime-virtual-runtime"><a href="#vruntime-virtual-runtime" class="headerlink" title="vruntime(virtual runtime)"></a>vruntime(virtual runtime)</h4><p>在每次挑选合适的进程时，调度器都会选择虚拟运行时间最小的进程来作为下一个被执行的进程。进程实际花费的CPU执行时间被成为实际运行时间「real runtime」，而由负载权重加权计算得到时间被称为虚拟运行时间「virtual runtime」。如图4所示给出了计算虚拟运行时间的公式。</p>
<p><img data-src="/images/13/vruntime_load_weight.svg" alt="vruntime_load_weight.svg"></p>
<center>图4 负载权重「load weight」与虚拟运行时间「virtual runtime」的关系式</center>

<p>从上面计算公式可以算出，进程的负载权重越大，虚拟运行时间就会越小，当负载权重等于1024时，虚拟运行时间与实际运行时间是相等的。实际上在系统运行时，进程的虚拟运行时间是通过不断累加计算得到的，若进程的负载权重越大，那么虚拟运行时间的增涨也就越慢。相反，若负载权重越小，则虚拟运行时间的增涨也就相对更快一些。<br>如图5所示给出了虚拟运行时间的变化速率，三个进程的负载权重之比大约是1:2:3并且每个进程都实际执行了10s，然而三个虚拟运行时间之比大约是1:0.5:0.33，正好是负载权重之比的倒数（1&#x2F;1 : 1&#x2F;2 : 1&#x2F;3）。</p>
<p><img data-src="/images/13/real_runtime_to_virtual_runtime.svg" alt="real_runtime_to_virtual_runtime"></p>
<center>图5 虚拟运行时间「virtual runtime」的变化快慢（斜率）</center>

<p>即使消耗了相同的实际时间，但是虚拟运行时间还是会有所不同，因此进程被调度器选中执行的频率也会不相同。对于具有较大负载权重的进程，在运行一段时间后它们的虚拟运行时间会较少地增加，因此它们比负载权重较小的进程会更频繁地被调度执行。如图6所示展示了调度器根据虚拟运行时间挑选下一个进程的过程，三个进程的负载权重之比大约是1:2:3，在一段时间后每个进程所消耗的实际CPU时间之比也是1:2:3。</p>
<p><img data-src="/images/13/execution_time_task.svg" alt="execution_time_task"></p>
<center>图6 由负载权重决定的进程实际执行时间</center>

<p>基于调度器的工作机制，我们应该可以根据进程的重要性给不同进程赋予相应的优先级，从而保证不同重要性的进程能够享用不相等的CPU执行时间。在内核代码中进程的虚拟运行时间「virtual runtime」是记录在结构体<code>struct sched_entity</code>的成员<code>vruntime</code>中。</p>
<h4 id="min-vruntime"><a href="#min-vruntime" class="headerlink" title="min_vruntime"></a>min_vruntime</h4><p>从上述可知，vruntime一般都是单调递增的，这是因为进程总共消耗的CPU执行时间只可能增多不可能减少。但vruntime的单调递增特点却很可能导致一些问题，比如在创建新的进程时会调用__sched_fork()函数将<code>vruntime</code>初始化为0，如下列所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;kernel/core.c&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __sched_fork(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *p)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	p-&gt;se.vruntime = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若新进程与已长时间运行的进程被放入到同一个运行队列，那么新进程的vruntime将是最小的，因此该进程将持续地运行直到它的vruntime大于其他进程的vruntime为止，调度器别无选择而只能让新进程长时间独自占用CPU执行时间，究其本质原因是新进程的vruntime只有花很长时间才能增长到与已有进程的vruntime相同。不同时刻上线「online」的两个CPU会产生两个不同步的运行队列，在这样两个运行队列中进行进程迁移「migration」时同样的问题也会发生，这是因为新进程运行在较晚创建的运行队列上，其vruntime也会相对较小一些，因此与较早运行队列的进程相比，它们的vruntime必然存在一定的差距。<br>上述两种情况在一定程度上都存在不公平性。为了解决这种问题，最小的虚拟运行时间被记录在每个<code>struct cfs_rq</code>实例的<code>min_vruntime</code>成员中。这样可以确保新建进程或被迁移的进程能够基于min_vruntime更新自身的vruntime来维持公平性。实际上，内核多处代码会根据min_vruntime更新特定进程的vruntime。此外，一旦有进程从运行队列移出「depueue」或滴答「tick」出现，<code>min_vruntime</code>也将会被更新。</p>
<h3 id="调度延迟「scheduling-latency」和时间片「time-slice」"><a href="#调度延迟「scheduling-latency」和时间片「time-slice」" class="headerlink" title="调度延迟「scheduling latency」和时间片「time slice」"></a>调度延迟「scheduling latency」和时间片「time slice」</h3><p>调度延迟或调度等待时间「scheduling latency」等于在CFS运行队列内所有进程的时间片之和，时间片意味着进程可用的执行时间。每个CFS运行队列都有各自的调度延迟，CFS运行队列的每个进程会依据自身的负载权重与CFS运行队列的总负载权重之比分割调度延迟「scheduling latency」而得到各自的时间片。</p>
<p><img data-src="/images/13/scheduling_latency.svg" alt="scheduling_latency"></p>
<center>图7 调度延迟与时间片的关系</center>

<p>调度延迟的默认大小由内核全局变量<code>sysctl_sched_latency</code>（以下统称为默认调度延迟）指定并初始化设置为6ms，不过在系统启动阶段内核代码会根据CPU数量重新计算来更新它的值，比如系统拥有4个CPU，那么它会被更新为18ms（6ms × 3）。仅当CFS运行队列的进程数量小于sched_nr_latency时才会以默认调度延迟为准，在这样情况下，每个进程都会按比例计算分割默认调度延迟而得到各自能享用的时间片， 如图8所示。</p>
<p><img data-src="/images/13/scheduling_latency_divided.svg" alt="scheduling_latency_divided"></p>
<center>图8 调度延迟的分割方法</center>

<p>如图8所示，上面的情况是每个进程都具有相同的负载权重，从而每个进程将获得相同的时间片。然而下面的情况是每个进程具有不同的负载权重，因此每个进程也获得了不同的时间片。如图9所示给出了以默认调度延迟为准时计算进程时间片的公式。</p>
<p><img data-src="/images/13/task_timeslice.svg" alt="task_timeslice"></p>
<center>图9 进程负载权重与时间片的关系式</center>

<p><code>sched_nr_latency</code>表示在默认调动等待时间内CFS运行队列能容纳的最大进程数，由另外两个变量决定， 如图10所示。</p>
<p><img data-src="/images/13/sched_nr_latency.svg" alt="sched_nr_latency.svg"></p>
<center>图10 schec_nr_latency的计算公式</center>

<p><code>sysctl_sched_min_granularity</code>表示进程的最短执行时间，用于保证进程在极端情况下能够执行的最小时间片。如果在系统运行时改变了<code>sysctl_sched_min_granularity</code>或者<code>sysctl_sched_latency</code>，那么<code>sched_nr_latency</code>也将会自动地被更新。对于4个CPU的硬件系统，<code>sysctl_sched_min_granularity</code>的默认值是2.25ms（075ms × 3），因此<code>sched_nr_latency</code>还是等于8，参考表1。如果CFS运行队列中进程数量大于<code>sched_nr_latency</code>，那么调度延迟需要重新计算以确保进程能够享用最短的执行时间。如图11所示给出了重新计算调度延迟的公式。</p>
<p><img data-src="/images/13/scheduling_latency_calculation.svg" alt="scheduling_latency_calculation"></p>
<center>图11 调度延迟的计算公式</center>

<p>如图12所示给出了一个当CFS运行队列中进程数量大于<code>sched_nr_latency</code>时重新计算调度延迟的例子。</p>
<p><img data-src="/images/13/scheduling_latency_task.svg" alt="scheduling_latency_task"></p>
<center>图12 重新计算调度延迟的例子</center>

<p>总之，通过上面方法计算得到的时间片指的是进程可消耗的实际CPU运行时间。在内核调度点处会检查当前进程是否已经用完自己的时间片，一旦用完，将进行调度并执行其他的进程。</p>
<h4 id="时间片相关的变量"><a href="#时间片相关的变量" class="headerlink" title="时间片相关的变量"></a>时间片相关的变量</h4><p>下表给出了用于计算调度延迟和进程时间片的相关变量。</p>
<div align="center">表1 计算调度延迟和进程时间片的常用变量
<style type="text/css">.tg-sort-header::-moz-selection{background:0 0}.tg-sort-header::selection{background:0 0}.tg-sort-header{cursor:pointer}.tg-sort-header:after{content:'';float:right;margin-top:7px;border-width:0 5px 5px;border-style:solid;border-color:#404040 transparent;visibility:hidden}.tg-sort-header:hover:after{visibility:visible}.tg-sort-asc:after,.tg-sort-asc:hover:after,.tg-sort-desc:after{visibility:visible;opacity:.4}.tg-sort-desc:after{border-bottom:none;border-width:5px 5px 0}@media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;margin: auto 0px;}}</style><div class="tg-wrap"><table id="tg-69mDT" style="border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:0px auto;table-layout: fixed; width: 900px" class="tg"><colgroup><col style="width: 230px"><col style="width: 265px"><col style="width: 240px"><col style="width: 165px"></colgroup><thead><tr><th style="background-color:#409cff;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 8px;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform;word-break:normal">变量名</th><th style="background-color:#409cff;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 8px;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform;word-break:normal">含义解释</th><th style="background-color:#409cff;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 8px;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform;word-break:normal">初始值</th><th style="background-color:#409cff;border-color:inherit;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 8px;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform;word-break:normal">启动后使用的值<br>（前提条件: 4个CPU）</th></tr></thead><tbody><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">sysctl_sched_latency</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">认的调度延迟（单位：ns）</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">6ms</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">18ms</td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">sysctl_sched_min_granularity</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">进程的最小时间片</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">0.75ms</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">2.25ms</td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">sysctl_sched_wakeup_granularity</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">唤醒进程能够抢占当前进程的条件，也就是说唤醒进程与当前进程的vruntime之差要大于这个参数才能够抢占，其与唤醒抢占功能息息相关。换句话说，当前进程在指定的时间内不会被唤醒进程抢占</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">1ms</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">3ms</td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">sched_nr_latency</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">在默认调度等待时间内能够调度的最大进程数</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">8<br>(sysctl_sched_latency /<br>sysctl_sched_min_granularity)</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">与左边相同</td></tr><tr><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">sysctl_sched_tunable_scaling</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">根据CPU数量缩放相关变量值的方法</td><td style="background-color:#EBF5FF;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">SCHED_TUNABLESCALING_LOG</td><td style="background-color:#D2E4FC;border-color:inherit;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">与左边相同</td></tr></tbody></table></div><script charset="utf-8">var TGSort=window.TGSort||function(n){"use strict";function r(n){return n?n.length:0}function t(n,t,e,o=0){for(e=r(n);o<e;++o)t(n[o],o)}function e(n){return n.split("").reverse().join("")}function o(n){var e=n[0];return t(n,function(n){for(;!n.startsWith(e);)e=e.substring(0,r(e)-1)}),r(e)}function u(n,r,e=[]){return t(n,function(n){r(n)&&e.push(n)}),e}var a=parseFloat;function i(n,r){return function(t){var e="";return t.replace(n,function(n,t,o){return e=t.replace(r,"")+"."+(o||"").substring(1)}),a(e)}}var s=i(/^(?:\s*)([+-]?(?:\d+)(?:,\d{3})*)(\.\d*)?$/g,/,/g),c=i(/^(?:\s*)([+-]?(?:\d+)(?:\.\d{3})*)(,\d*)?$/g,/\./g);function f(n){var t=a(n);return!isNaN(t)&&r(""+t)+1>=r(n)?t:NaN}function d(n){var e=[],o=n;return t([f,s,c],function(u){var a=[],i=[];t(n,function(n,r){r=u(n),a.push(r),r||i.push(n)}),r(i)<r(o)&&(o=i,e=a)}),r(u(o,function(n){return n==o[0]}))==r(o)?e:[]}function v(n){if("TABLE"==n.nodeName){for(var a=function(r){var e,o,u=[],a=[];return function n(r,e){e(r),t(r.childNodes,function(r){n(r,e)})}(n,function(n){"TR"==(o=n.nodeName)?(e=[],u.push(e),a.push(n)):"TD"!=o&&"TH"!=o||e.push(n)}),[u,a]}(),i=a[0],s=a[1],c=r(i),f=c>1&&r(i[0])<r(i[1])?1:0,v=f+1,p=i[f],h=r(p),l=[],g=[],N=[],m=v;m<c;++m){for(var T=0;T<h;++T){r(g)<h&&g.push([]);var C=i[m][T],L=C.textContent||C.innerText||"";g[T].push(L.trim())}N.push(m-v)}t(p,function(n,t){l[t]=0;var a=n.classList;a.add("tg-sort-header"),n.addEventListener("click",function(){var n=l[t];!function(){for(var n=0;n<h;++n){var r=p[n].classList;r.remove("tg-sort-asc"),r.remove("tg-sort-desc"),l[n]=0}}(),(n=1==n?-1:+!n)&&a.add(n>0?"tg-sort-asc":"tg-sort-desc"),l[t]=n;var i,f=g[t],m=function(r,t){return n*f[r].localeCompare(f[t])||n*(r-t)},T=function(n){var t=d(n);if(!r(t)){var u=o(n),a=o(n.map(e));t=d(n.map(function(n){return n.substring(u,r(n)-a)}))}return t}(f);(r(T)||r(T=r(u(i=f.map(Date.parse),isNaN))?[]:i))&&(m=function(r,t){var e=T[r],o=T[t],u=isNaN(e),a=isNaN(o);return u&&a?0:u?-n:a?n:e>o?n:e<o?-n:n*(r-t)});var C,L=N.slice();L.sort(m);for(var E=v;E<c;++E)(C=s[E].parentNode).removeChild(s[E]);for(E=v;E<c;++E)C.appendChild(s[v+L[E-v]])})})}}n.addEventListener("DOMContentLoaded",function(){for(var t=n.getElementsByClassName("tg"),e=0;e<r(t);++e)try{v(t[e])}catch(n){}})}(document)</script></div>


<h3 id="运行队列「run-queue」、CFS运行队列和红黑树「Red-Black-tree」"><a href="#运行队列「run-queue」、CFS运行队列和红黑树「Red-Black-tree」" class="headerlink" title="运行队列「run queue」、CFS运行队列和红黑树「Red-Black tree」"></a>运行队列「run queue」、CFS运行队列和红黑树「Red-Black tree」</h3><p>为了让进程执行起来，须先将进程加入运行队列，然后内核才有机会调度执行它。内核会为每个CPU都创建了一个运行队列（<code>struct rq</code>），它包含三个子运行队列：CFS、RT和DeadLine，不过每个子运行队列都根据各自调度策略进行单独管理。一旦确定进程将在哪个CPU上执行，就会将它加入CPU对应的运行队列中。实际上，进程是被加入了CPU运行队列中的一个子运行队列。</p>
<p><img data-src="/images/13/per_cpu_run_queue_and_sub_run_queue.svg" alt="per_cpu_run_queue_and_sub_run_queue"></p>
<center>图13 每个CPU的运行队列和包含的子运行队列</center>

<p>尽管这里不会详细分析代码细节，但事实是采用<code>SCHED_RR</code>和<code>SCHED_FIFO</code>调度策略的实时进程将会被加入RT运行队列，采用<code>SCHED_DEADLINE</code>调度策略的进程将会被加入DeadLine运行队列，采用<code>SCHED_NORMAL</code>、<code>SCHED_BATCH</code>和<code>SCHED_IDLE</code>调度策略的进程将会被加入CFS运行队列。</p>
<p>CFS运行队列通过使用红黑树「Red-Black tree」管理加入运行队列的进程。实际上并不是直接将一个进程（任务）或任务组加入CFS运行队列，而是将一个进程（任务）或任务组抽象成一个调度实体「<code>struct sched_entity</code>」，并将调度实体用作一个节点按照vruntime的排序插入到红黑树的合适位置。</p>
<p><img data-src="/images/13/redblack_tree_sched_entity.svg" alt="redblack_tree_sched_entity"></p>
<center>图14 调度实体「sched_entity」与红黑树</center>

<p>由于调度实体的节点在红黑树中以vruntime的大小排序，因此通过访问最左边的节点就能快速地找出最小vruntime的调度实体。当新调度实体「struct sched_entity」插入红黑树时，会通过比较vruntime的大小从根节点开始遍历直到叶子节点，这样就能找出新调度实体的合适位置。因此为了方便快捷，struct cfs_rq实例包含一个<code>struct rb_root_cached</code>类型的成员变量<code>tasks_timeline</code>，它包含一个<code>struct rb_root</code>类型的成员变量<code>rb_root</code>和一个<code>struct rb_node</code>类型的指针变量<code>rb_leftmost</code>，前者用于追踪红黑树的根节点，后者指向红黑树的最左边节点。</p>
<h4 id="描述运行队列的数据结构：struct-rq"><a href="#描述运行队列的数据结构：struct-rq" class="headerlink" title="描述运行队列的数据结构：struct rq"></a>描述运行队列的数据结构：<code>struct rq</code></h4><div align="center">表2 数据结构`struct rq`的部分字段
<style type="text/css">@media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;margin: auto 0px;}}</style><div class="tg-wrap"><table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto" class="tg"><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#fff;background-color:#409cff;text-align:center;vertical-align:middle">数据类型</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#fff;background-color:#409cff;text-align:center;vertical-align:middle">字段名称</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#fff;background-color:#409cff;text-align:center;vertical-align:middle">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">raw_spinlock_t</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">lock</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">自旋锁，用于防止并发修改数据结构struct rq</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">unsigned int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">nr_running</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">所有子运行队列中已经插入的进程数</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">cpu_load[CPU_LOAD_IDX_MAX]</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指示运行队列的负载</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">last_load_update_tick</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指示更新cpu_load的时间，单位为jiffies</td></tr><tr><td style="font-family:Arial, Helvetica, sans-serif !important;;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct load_weight</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">load</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">刻画运行队列的总体负载</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">nr_load_updates</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">指示cpu_load的更新次数</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">u64</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">nr_switches</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">指示上下文切换的次数</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct cfs_rq</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">rq</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">描述当前运行队列中的CFS子运行队列</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct rt_rq</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">rt</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">描述RT子运行队列</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct dl_rq</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">dl</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">描述Deadline子运行队列</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">nr_uninterruptible</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">统计运行队列中同时满足下列情形的进程数：<br>1. 处在TASK_UNINTERRUPTIBLE状态<br>2. 不处在TASK_NOLOAD状态<br>3. PT_FROZEN标志位未设置</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct task_struct &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">curr</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">指向运行队列绑定CPU上正在运行进程的struct task_struct实例</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct task_struct &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">idle</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">指向idle线程的struct task_struct实例</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct task_struct &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">stop</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">指向stopper线程的struct task_struct实例</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">next_balance</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">记录下一次尝试负载均衡的时间，单位是jiffies</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct mm_struct &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">prev_mm</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">指向上一个内核线程所用的struct mm_struct实例</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct sched_domain &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">sd</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">指向struct sched_domain实例，用于描述运行队列绑定CPU所属的调度域</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">cpu_capacity</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">记录运行队列绑定CPU的能力值</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">unsigned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">cpu_capacity_orig</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">更新能力值之前保存运行队列绑定CPU的原始能力值</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">cpu</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">保存运行队列绑定CPU的ID</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">online</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">追踪运行队列的就绪状态</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct list_head</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">cfs_tasks</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于链接所有插入CFS运行队列的进程</td></tr></table></div></div>

<h4 id="描述CFS运行队列的数据结构：struct-cfs-rq"><a href="#描述CFS运行队列的数据结构：struct-cfs-rq" class="headerlink" title="描述CFS运行队列的数据结构：struct cfs_rq"></a>描述CFS运行队列的数据结构：<code>struct cfs_rq</code></h4><div align="center">表3 数据结构`struct cfs_rq`的部分字段
<style type="text/css">@media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;margin: auto 0px;}}</style><div class="tg-wrap"><table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto;table-layout: fixed; width: 900px" class="tg"><colgroup><col style="width: 165px"><col style="width: 175px"><col style="width: 560px"></colgroup><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#fff;background-color:#409cff;text-align:center;vertical-align:middle">数据类型</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#fff;background-color:#409cff;text-align:center;vertical-align:middle">字段名称</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#fff;background-color:#409cff;text-align:center;vertical-align:middle">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct load_weight<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">load</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">描述CFS运行队列中所有任务的总负载</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">unsigned int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">nr_running</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">只记录当前层级上加入CFS运行队列的调度实体「struct sched_entity」数量</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">unsigned int</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">h_nr_running</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">记录各个层的nr_running之和「hierarchical nr_running」。从当前层级开始记录下面所有层级上加入CFS运行队列的调度实体总数，也就是累加上所有子CFS运行队列中的调度实体数量，它仅与组调度「group scheduling」相关</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">u64</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">exec_clock</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">记录CFS运行队列中所有调度实体的执行时间之和</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">u64</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">min_vruntime</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">追踪CFS运行队列的最小虚拟运行时间</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct rb_root_cached</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">tasks_timeline</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">用于追踪红黑树的根节点和最左节点</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct sched_entity &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">curr</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指向当前正在运行的调度实体</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:le[CFS scheduler, -v17](https://lwn.net/Articles/238541/) ft;vertical-align:middle">struct sched_entity &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">next</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指向在唤醒任务「wakeup task」不抢占当前调度实体的情况下下次调度会优先选择的调度实体</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct sched_entity &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">last</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指向被唤醒任务抢占的调度实体「wakeup preemption」 ，以便于在下一次调度时它将首先被选择</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct sched_entity &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">skip</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指向主动出让「yield」CPU的调度实体，在后来调度程序选择下一个调度实体时会把它排除在外</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct rq &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">rq</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指向每个CPU所绑定的运行队列「percpu rq」，其包含当前的CFS运行队列</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct task_group &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">tg</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:inherit;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">当CFS运行队列被抽象成任务组时，也就是启用了组调度功能时它指向一个描述任务组的实例</td></tr></table></div></div>

<h3 id="任务组「task-group」和调度实体「scheduling-entity」"><a href="#任务组「task-group」和调度实体「scheduling-entity」" class="headerlink" title="任务组「task group」和调度实体「scheduling entity」"></a>任务组「task group」和调度实体「scheduling entity」</h3><p>在Ingo Molnart提交<a href="https://lwn.net/Articles/238541/">CFS scheduler, -v17</a> 补丁时已经存在很多关于调度器公平性的抱怨和讨论，出现这种状况的本质原因是CFS更关注任务（进程）之间的公平性。例如，假设系统存在50个进程，根据CFS的原理每个进程都能够公平地分享2%的CPU运行时间，但是如果其中49个进程属于某一个特定用户，另一个进程属于另外一个用户，那么两个用户占用的CPU时间会有很大差异，从而导致显而易见的用户间的不公平性。如图15所示显示了进程间的公平性和用户间的不公平性。<br><img data-src="/images/13/CFS_fairness_process.svg" alt="CFS_fairness_process.svg"></p>
<center>图15 CFS调度器只保证任务间的公平性</center>

<p>为了确保CFS调度器能够处理这种不公平性，必须保证每个用户能够获得50%的CPU时间，因此需要将每个用户创建的进程都划分到一个任务组，从而每个用户对应一个任务组。若给图15添加上任务组的概念，那么它正如图16所示。<br><img data-src="/images/13/CFS_fairness_user.svg" alt="CFS_fairness_user"></p>
<center>图16 基于任务组「task group」的CFS调度器保证用户间的公平性</center>

<p>实现任务组「task group」概念的CFS调度器能够保证用户间的公平性，因此CFS调度器的这个特性被称为组调度「<a href="https://lwn.net/Articles/240474/">CFS group scheduling</a> 」，并且目前最新的内核中对RT调度器也支持了该功能。目前内核CFS代码早已集成整合了由 Srivatsa Vaddagiri所开发的系列组调度补丁，比如<a href="https://lwn.net/Articles/239619/">Add group awareness to CFS - v2</a> ，同时该系列补丁还实现了一种用于配置任务组的用户ID机制，不过它已从2.6.35内核中删除了，目前仅支持通过cgroup文件系统进行任务组的设置。<br>任务组不仅可以包含进程，还可以包含其他任务组。如图17所示，进程1和进程2归属于一个任务组，说明任务组既可包含进程也可以包含子任务组。</p>
<p><img data-src="/images/13/task_group_and_sub-task_group.svg" alt="task_group_and_sub-task_group"></p>
<center>图17 包含子任务组「subtask group」的任务组</center>

<p>Srivatsa提出了调度实体「scheduling entity」的概念，用于将进程和任务组统一抽象成最小的调度单元，并且引入数据结构struct sched_entity去描述调度实体。因此描述进程的数据结构struct task_struct静态定义了一个描述调度实体的成员变量「struct sched_entity对象」，然而描述任务组的数据结构struct task_group只定义了一个指向调度实体的指针变量，从而在创建任务组对象时将会动态分配调度实体「struct sched_entity对象」。当调度器要调度安排一个进程或任务组时不再是直接地将进程或任务组插入CFS运行队列，而是将调度实体插入CFS运行队列。<br><img data-src="/images/13/task_and_task_group_entity.svg" alt="task_and_task_group_entity"></p>
<center>图18 抽象成调度实体「scheduling entity」的任务「task」和任务组「task group」</center>

<p>如图18所示，进程「任务(task)」和任务组都被抽象成了最小调度单元的调度实体，一个任务或任务组对应一个调动实体。如图19所示，调度实体被加入每个任务组指向的CFS运行队列，任务组既能包含一个或多个任务，也能其他的子任务组，构成一个任务组的所有任务和子任务组都会被抽象成调度实体并加入该任务组指向的CFS运行队列，最上层的任务组也会被抽象成调度实体并被加入CFS运行队列。<br><img data-src="/images/13/entity_enqueued_CFS.svg" alt="entity_enqueued_CFS"></p>
<center>图19 任务组的调度实体被加入CFS运行队列「scheduling entity」</center>

<p>在逻辑上，调度实体具有层次关系和结构。如图20所示，在最左边子图中一个任务组包含一个任务，并且那个任务的调度实体通过parent字段指向任务组的调度实体。</p>
<p><img data-src="/images/13/sched_entity_hierarchy.svg" alt="sched_entity_hierarchy"></p>
<center>图20 调度实体的层级结构</center>

<p>自从内核开始支持任务组，用于调度的相关字段就从task_struct数据结构转移到描述调度实体的sched_entity数据结构中，并且调度实体被调度器看作最小的调度单元。从最右边的子图可以看出一个任务组对应的调度实体都有一个指向自己的CFS运行队列的指针，并且如果该任务组是另外一个任务组的子任务组，那么它的调度实体将被加入父任务组的CFS运行队列。除此之外，每个调度实体都拥有一个指向父调度实体的指针和一个指向所加入的CFS运行队列的指针。</p>
<h4 id="最顶层的任务组：root-task-group"><a href="#最顶层的任务组：root-task-group" class="headerlink" title="最顶层的任务组：root_task_group"></a>最顶层的任务组：root_task_group</h4><p>Linux内核至少存在一个根任务组「root task group」，也称为最顶层的任务组「top-level task group」。如果内核不存在其他独立的任务组，那么所有的调度实体对应任务都归属根任务组，而且它们都被加入到根任务组指向的CFS运行队列。和上述的任务组不同的是根任务组直接使用per-cpu运行队列的CFS运行队列，而不会再单独地分配创建自己私有的CFS运行队列。如图21所示包含了根任务组的概念。</p>
<p><img data-src="/images/13/root_task_group.svg" alt="root_task_group"></p>
<center>图21 最顶层的任务组「root_task_group」</center>

<p>注意：一个任务组的调度实体会指向一个父调度实体，父调度实体一定是父任务组的调度实体。</p>
<h4 id="描述任务组的数据结构：struct-task-group"><a href="#描述任务组的数据结构：struct-task-group" class="headerlink" title="描述任务组的数据结构：struct task_group"></a>描述任务组的数据结构：<code>struct task_group</code></h4><div align="center">表4 数据结构`struct task_group`的部分字段
<style type="text/css">@media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;margin: auto 0px;}}</style><div class="tg-wrap"><table style="border-collapse:collapse;border-spacing:0;border-color:#9ABAD9;margin:0px auto;table-layout: fixed; width: 900px" class="tg"><colgroup><col style="width: 170px"><col style="width: 170px"><col style="width: 560px"></colgroup><tr><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#fff;background-color:#409cff;text-align:center;vertical-align:middle">数据类型</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#fff;background-color:#409cff;text-align:center;vertical-align:middle">字段名称</th><th style="font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#fff;background-color:#409cff;text-align:center;vertical-align:middle">含义解释</th></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct sched_entity &#42;&#42;<br></td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">se</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指针数组，每个元素都是指向调度实体的指针，元素的个数等于系统可能拥有的CPU数量「possible CPUs」。一个任务组对应的进程集合可被调度到多个CPU上运行，这样每个CPU对应的进程子集会被抽象成一个调度实体，并且指向它的指针将被存入这个数组</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct cfs_rq &#42;&#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">cfs_rq</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指针数组，每个元素都是指向CFS运行队列的指针，元素的个数等于系统可能拥有的CPU数量「possible CPUs」。一个任务组对应的进程集合可被调度到多个CPU上运行，这样每个CPU对应的进程会被单独加入一个CFS运行队列，而且指向它的指针将被存入这个数组</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">usingned long</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">share</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指定任务组的CFS运行队列「group cfs_rq」能够获得的CPU时间份额</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct list_head</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">list</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">用于连接描述任务组的实例「struct task_group对象」</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct task_group &#42;</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">parent</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">指向描述父任务组的实例</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">struct list_head</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:middle">siblings</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9abad9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:middle">父任务组可能还存在其他的子任务组，这些其他的子任务组与当前任务组是兄弟姐妹的关系，因此它用于连接处在同等级的任务组实例，也就是连接父任务组的多个子任务组</td></tr><tr><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">struct list_head</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#D2E4FC;text-align:left;vertical-align:top">children</td><td style="font-family:Arial, sans-serif;font-size:14px;padding:10px 8px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#9ABAD9;color:#444;background-color:#EBF5FF;text-align:left;vertical-align:top">用于连接当前任务组的子任务组</td></tr></table></div></div>

<h4 id="描述调度实体的数据结构：struct-sched-entity"><a href="#描述调度实体的数据结构：struct-sched-entity" class="headerlink" title="描述调度实体的数据结构：struct sched_entity"></a>描述调度实体的数据结构：<code>struct sched_entity</code></h4><div align="center">表5 数据结构`struct sched_entity`的部分字段
<style type="text/css">.tg-sort-header::-moz-selection{background:0 0}.tg-sort-header::selection{background:0 0}.tg-sort-header{cursor:pointer}.tg-sort-header:after{content:'';float:right;margin-top:7px;border-width:0 5px 5px;border-style:solid;border-color:#404040 transparent;visibility:hidden}.tg-sort-header:hover:after{visibility:visible}.tg-sort-asc:after,.tg-sort-asc:hover:after,.tg-sort-desc:after{visibility:visible;opacity:.4}.tg-sort-desc:after{border-bottom:none;border-width:5px 5px 0}@media screen and (max-width: 767px) {.tg {width: auto !important;}.tg col {width: auto !important;}.tg-wrap {overflow-x: auto;-webkit-overflow-scrolling: touch;margin: auto 0px;}}</style><div class="tg-wrap"><table id="tg-EzR0e" style="border-collapse:collapse;border-color:#9ABAD9;border-spacing:0;margin:0px auto;table-layout: fixed; width: 900px" class="tg"><colgroup><col style="width: 160px"><col style="width: 180px"><col style="width: 560px"></colgroup><thead><tr><th style="background-color:#409cff;border-color:#9abad9;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 8px;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform;word-break:normal">数据类型</th><th style="background-color:#409cff;border-color:#9abad9;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 8px;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform;word-break:normal">字段名称</th><th style="background-color:#409cff;border-color:#9abad9;border-style:solid;border-width:1px;color:#fff;font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 8px;position:-webkit-sticky;position:sticky;text-align:center;top:-1px;vertical-align:middle;will-change:transform;word-break:normal">含义解释</th></tr></thead><tbody><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">struct load_weight</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">load</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">描述调度实体的负载权重，即使两个调度实体消耗了相同的CPU执行时间，只要它的负载权重比另外一个大，那么它的虚拟运行时间「vruntime」就比另外一个增加的少</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">struct rb_node</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">run_node</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">用于将调度实体插入红黑树「RedBlack tree」</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">struct list_head</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">group_node</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">用于将普通任务「normal task」对应的调度实体插入运行队列「struct rq」管理的cfs_tasks链表</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">unsigned int</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">on_rq</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">指示调度实体是否插入红黑树。如果当前调度实体被插入红黑树，那么其将被设置为1。如果当前调度实体被移出「dequeue」红黑树，那么其会被设置成0</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">u64</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">exec_start</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">记录当前调度实体在这次被调度执行的起始时刻</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">u64</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">sum_exec_runtime</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">记录调度实体总共占用的CPU运行时间</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">u64</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">vruntime</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">根据消耗掉的总CPU运行时间和负载权重计算其虚拟执行时间。该值越小，调度实体就越靠近红黑树的最左侧，因此其被调度运行的频率就越高</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">u64</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">prev_sum_exec_runtime</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">记录截至上一次被调度执行结束时当前调度实体消耗掉的CPU执行时间，通过使用sum_exec_runtime和prev_sum_exec_runtime能够计算出在这次调度执行期间当前调度实体实际占用的CPU执行时间</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">u64</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">nr_migrations</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">记录当前调度实体已切换执行CPU的次数</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">int</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">depth</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">记录当前调度实体在层级结构中的深度</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">struct sched_entity &#42;</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">parent</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">指向父调度实体</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">struct cfs_rq &#42;</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">cfs_rq</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">指向当前调度实体将插入的CFS运行队列</td></tr><tr><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">struct cfs_rq &#42;</td><td style="background-color:#D2E4FC;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">my_q</td><td style="background-color:#EBF5FF;border-color:#9abad9;border-style:solid;border-width:1px;color:#444;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 8px;text-align:left;vertical-align:middle;word-break:normal">在创建一个任务组时，其对应的调度实体将动态分配一个私有的内部CFS运行队列来管理它的任务。该字段指向这个私有的内部CFS运行队列</td></tr></tbody></table></div><script charset="utf-8">var TGSort=window.TGSort||function(n){"use strict";function r(n){return n?n.length:0}function t(n,t,e,o=0){for(e=r(n);o<e;++o)t(n[o],o)}function e(n){return n.split("").reverse().join("")}function o(n){var e=n[0];return t(n,function(n){for(;!n.startsWith(e);)e=e.substring(0,r(e)-1)}),r(e)}function u(n,r,e=[]){return t(n,function(n){r(n)&&e.push(n)}),e}var a=parseFloat;function i(n,r){return function(t){var e="";return t.replace(n,function(n,t,o){return e=t.replace(r,"")+"."+(o||"").substring(1)}),a(e)}}var s=i(/^(?:\s*)([+-]?(?:\d+)(?:,\d{3})*)(\.\d*)?$/g,/,/g),c=i(/^(?:\s*)([+-]?(?:\d+)(?:\.\d{3})*)(,\d*)?$/g,/\./g);function f(n){var t=a(n);return!isNaN(t)&&r(""+t)+1>=r(n)?t:NaN}function d(n){var e=[],o=n;return t([f,s,c],function(u){var a=[],i=[];t(n,function(n,r){r=u(n),a.push(r),r||i.push(n)}),r(i)<r(o)&&(o=i,e=a)}),r(u(o,function(n){return n==o[0]}))==r(o)?e:[]}function v(n){if("TABLE"==n.nodeName){for(var a=function(r){var e,o,u=[],a=[];return function n(r,e){e(r),t(r.childNodes,function(r){n(r,e)})}(n,function(n){"TR"==(o=n.nodeName)?(e=[],u.push(e),a.push(n)):"TD"!=o&&"TH"!=o||e.push(n)}),[u,a]}(),i=a[0],s=a[1],c=r(i),f=c>1&&r(i[0])<r(i[1])?1:0,v=f+1,p=i[f],h=r(p),l=[],g=[],N=[],m=v;m<c;++m){for(var T=0;T<h;++T){r(g)<h&&g.push([]);var C=i[m][T],L=C.textContent||C.innerText||"";g[T].push(L.trim())}N.push(m-v)}t(p,function(n,t){l[t]=0;var a=n.classList;a.add("tg-sort-header"),n.addEventListener("click",function(){var n=l[t];!function(){for(var n=0;n<h;++n){var r=p[n].classList;r.remove("tg-sort-asc"),r.remove("tg-sort-desc"),l[n]=0}}(),(n=1==n?-1:+!n)&&a.add(n>0?"tg-sort-asc":"tg-sort-desc"),l[t]=n;var i,f=g[t],m=function(r,t){return n*f[r].localeCompare(f[t])||n*(r-t)},T=function(n){var t=d(n);if(!r(t)){var u=o(n),a=o(n.map(e));t=d(n.map(function(n){return n.substring(u,r(n)-a)}))}return t}(f);(r(T)||r(T=r(u(i=f.map(Date.parse),isNaN))?[]:i))&&(m=function(r,t){var e=T[r],o=T[t],u=isNaN(e),a=isNaN(o);return u&&a?0:u?-n:a?n:e>o?n:e<o?-n:n*(r-t)});var C,L=N.slice();L.sort(m);for(var E=v;E<c;++E)(C=s[E].parentNode).removeChild(s[E]);for(E=v;E<c;++E)C.appendChild(s[v+L[E-v]])})})}}n.addEventListener("DOMContentLoaded",function(){for(var t=n.getElementsByClassName("tg"),e=0;e<r(t);++e)try{v(t[e])}catch(n){}})}(document)</script></div>

<h3 id="调度类别「scheduling-class」和调度策略「scheduling-policy」"><a href="#调度类别「scheduling-class」和调度策略「scheduling-policy」" class="headerlink" title="调度类别「scheduling class」和调度策略「scheduling policy」"></a>调度类别「scheduling class」和调度策略「scheduling policy」</h3><p>在Linux内核中调度器包含5种调度类，支持6个调度策略，其中STOP调度类用于处理最高优先级的stop任务，还有DEADLINE调度类实现了EDF「Early Deadline Firs」算法。</p>
<p><img data-src="/images/13/scheduling_policy_and_class.svg" alt="scheduling_policy_and_class"></p>
<center>图22 调度类别「scheduling class」与调度策略「scheduling policy」</center>

<p>与调度类无关的调度器核心代码都放在core.c文件中，每种调度类的自身实现代码单独放在一个文件中，还有这种实现方式能够将调度策略的实现代码从核心调度器「core scheduler」的代码中抽象剥离出，使两者之间能够尽量地解耦，从而使调度器具有良好的可扩展性和灵活性。调度类具有优先级，它会影响系统中被挑选出任务的执行顺序。</p>
<p><img data-src="/images/13/all_shceduling_class.svg" alt="all_shceduling_class"></p>
<center>图23 按优先级的顺序遍历调度类别（调度器）</center>

<h3 id="调度器「scheduler」的初始化"><a href="#调度器「scheduler」的初始化" class="headerlink" title="调度器「scheduler」的初始化"></a>调度器「scheduler」的初始化</h3><h4 id="sched-init-：初始化调度器"><a href="#sched-init-：初始化调度器" class="headerlink" title="sched_init()：初始化调度器"></a>sched_init()：初始化调度器</h4><p><img data-src="/images/13/init_root_task_group.svg" alt="init_root_task_group"></p>
<center>图24 root_task_group初始化</center>

<h5 id="初始化最顶层的任务组（root-task-group）"><a href="#初始化最顶层的任务组（root-task-group）" class="headerlink" title="初始化最顶层的任务组（root_task_group）"></a>初始化最顶层的任务组（root_task_group）</h5><h5 id="初始化CFS运行队列的数据结构"><a href="#初始化CFS运行队列的数据结构" class="headerlink" title="初始化CFS运行队列的数据结构"></a>初始化CFS运行队列的数据结构</h5><h5 id="初始化swapper和注册用于负载均衡「load-balancing」的softirq处理函数"><a href="#初始化swapper和注册用于负载均衡「load-balancing」的softirq处理函数" class="headerlink" title="初始化swapper和注册用于负载均衡「load balancing」的softirq处理函数"></a>初始化swapper和注册用于负载均衡「load balancing」的softirq处理函数</h5>]]></content>
      <categories>
        <category>task management and process scheduling</category>
      </categories>
      <tags>
        <tag>task</tag>
        <tag>process</tag>
        <tag>management</tag>
        <tag>schedule</tag>
      </tags>
  </entry>
</search>
